{"version":3,"sources":["src/header.js","index.js","interact.js","src/Eventable.js","src/InteractEvent.js","src/Interactable.js","src/Interaction.js","src/actions/drag.js","src/actions/drop.js","src/actions/gesture.js","src/actions/index.js","src/actions/resize.js","src/autoScroll.js","src/autoStart/delay.js","src/autoStart/drag.js","src/autoStart/gesture.js","src/autoStart/index.js","src/autoStart/resize.js","src/defaultOptions.js","src/index.js","src/inertia.js","src/interact.js","src/interactablePreventDefault.js","src/legacyBrowsers.js","src/modifiers/index.js","src/modifiers/restrict.js","src/modifiers/snap.js","src/pointerEvents/index.js","src/pointerEvents/interactableTargets.js","src/scope.js","src/utils/Signals.js","src/utils/arr.js","src/utils/browser.js","src/utils/domObjects.js","src/utils/domUtils.js","src/utils/events.js","src/utils/extend.js","src/utils/getOriginXY.js","src/utils/hypot.js","src/utils/index.js","src/utils/interactionFinder.js","src/utils/isType.js","src/utils/isWindow.js","src/utils/pointerExtend.js","src/utils/pointerUtils.js","src/utils/raf.js","src/utils/window.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","interact","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","init","./src/index","./src/utils/window","2","_classCallCheck","instance","Constructor","TypeError","fireUntilImmediateStopped","event","listeners","len","immediatePropagationStopped","_require","indexOf","Eventable","prototype","fire","undefined","onEvent","type","propagationStopped","on","eventType","listener","push","off","eventList","index","splice","./utils/arr","3","extend","getOriginXY","defaults","signals","InteractEvent","interaction","action","phase","element","related","target","deltaSource","options","origin","starting","ending","coords","startCoords","curCoords","page","client","x","y","ctrlKey","altKey","shiftKey","metaKey","button","buttons","currentTarget","relatedTarget","t0","downTimes","interactable","signalArg","iEvent","prevEvent","pageX","pageY","clientX","clientY","x0","y0","clientX0","clientY0","timeStamp","dt","pointerDelta","duration","speed","velocityX","vx","velocityY","vy","swipe","getSwipe","angle","Math","atan2","PI","overlap","left","up","right","down","velocity","preventDefault","stopImmediatePropagation","stopPropagation","_ref","dx","dy","./defaultOptions","./utils/Signals","./utils/extend","./utils/getOriginXY","4","isType","events","actions","scope","getElementRect","nodeContains","_require2","contains","_require3","wheelEvent","interactables","Interactable","_context","document","_iEvents","_window","trySelector","context","getWindow","Node","isElement","_doc","win","addDocument","set","setOnEvents","phases","onAction","isFunction","onstart","onmove","onend","oninertiastart","setPerAction","option","isObject","perAction","enabled","isBool","getRect","isString","querySelector","rectChecker","checker","newValue","cursorTarget","inContext","ownerDocument","_onOffMultiple","method","useCapture","search","trim","split","isArray","prop","eventTypes","addDelegate","add","removeDelegate","remove","base","perActions","actionName","methodDict","methodName","_iterator","settingsMethods","_isArray","Array","_i","Symbol","iterator","next","done","value","setting","unset","delegatedEvents","delegated","selectors","contexts","delegateListener","delegateUseCapture","_iterator2","interactions","_isArray2","_i2","_ref2","interacting","stop","indexOfElement","get","forEachSelector","callback","ret","./Eventable","./actions","./scope","./utils/browser","./utils/domUtils","./utils/events","./utils/isType","5","doOnInteractions","eventTarget","utils","getActualElement","path","curEventTarget","matches","browser","supportsTouch","test","prevTouchTime","Date","getTime","changedTouches","pointer","finder","Interaction","invalidPointer","supportsPointerEvent","mouse","pointerIsDown","pointerType","_updateEventTargets","endAll","end","onDocSignal","signalName","doc","eventMethod","docEvents","methodNames","prepared","name","axis","edges","pointers","pointerIds","downTargets","holdTimers","prevCoords","downEvent","downPointer","_eventTarget","_curEventTarget","pointerWasMoved","_interacting","pointerDown","pointerIndex","updatePointer","setCoords","copyCoords","pointerExtend","start","copyAction","pointerMove","simulation","duplicateMove","hypot","pointerMoveTolerance","duplicate","interactingBeforeMove","setCoordDeltas","doMove","_dontFireMove","pointerUp","getPointerId","clearTimeout","removePointer","currentAction","id","pEventTypes","PointerEvent","move","cancel","mousedown","mousemove","mouseup","touchstart","touchmove","touchend","touchcancel","blur","endAllInteractions","./utils","./utils/interactionFinder","6","defaultOptions","drag","snap","restrict","inertia","autoScroll","startAxis","lockAxis","dragOptions","getCursor","dragEvent","abs","_ref3","_ref4","draggable","names","merge","../InteractEvent","../Interactable","../Interaction","../defaultOptions","../utils","./index","7","collectDrops","drops","elements","current","drop","accept","matchesSelector","dropElements","querySelectorAll","currentElement","dropzones","fireActiveDrops","prevElement","activeDrops","setActiveDrops","dragElement","possibleDrops","rects","getDrop","validDrops","dynamicDrop","j","rect","dropCheck","dropIndex","indexOfDeepestElement","dropzone","getDropEvents","pointerEvent","dropEvents","enter","leave","activate","deactivate","tmpl","dropElement","dropTarget","prevDropElement","prevDropTarget","dragLeave","prevDropzone","dragEnter","dragmove","fireDropEvents","draggableElement","dropResult","_ref5","_ref6","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","isNumber","max","min","dropped","dropOverlap","getPageXY","horizontal","vertical","top","bottom","dragRect","cx","width","cy","height","overlapArea","overlapRatio","_ref7","_ref8","../interact","../scope","8","gesture","gestureEvent","ds","startDistance","prevDistance","distance","startAngle","prevAngle","scale","Infinity","isNaN","gesturable","touches","touchDistance","box","touchBBox","touchAngle","da","prevScale","9","10","checkResizeEdge","interactableElement","margin","matchesUpTo","defaultMargin","resize","square","preserveAspectRatio","NaN","invert","resizeOptions","resizeEdges","edge","axes","cursors","isIe9OrOlder","xy","topleft","bottomright","topright","bottomleft","cursorKey","edgeNames","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","restricted","previous","delta","deltaRect","invertible","originalEdges","startAspectRatio","swap","resizable","resizeAxes","../utils/browser","11","raf","isWindow","domUtils","container","isScrolling","prevTime","request","scroll","now","scrollBy","scrollLeft","scrollTop","check","onInteractionMove","innerWidth","innerHeight","getElementClientRect","./Interaction","./utils/raf","./utils/window","12","autoStart","delayTimer","delay","setTimeout","13","checkStartAxis","thisAxis","parentNode","setActionDefaults","absX","absY","currentAxis","getDraggable","selector","useMatchesSelectorPolyfill","manualStart","testIgnore","testAllow","getAction","withinInteractionLimit","elementInteractable","selectorInteractable","../actions/drag","../utils/domUtils","../utils/isType","14","../actions/gesture","15","ignoreFrom","allowFrom","validateAction","validateSelector","matchElements","match","matchElement","getActionInfo","pushMatches","actionInfo","prepare","styleCursor","documentElement","style","cursor","maxActions","maxPerElement","activeInteractions","targetCount","targetElementCount","maxInteractions","otherAction","perActionDefaults","arg","defaultActionChecker","actionChecker","../actions","../utils/Signals","16","../actions/resize","17","resistance","minSpeed","endSpeed","allowResume","smoothEndDuration","_holdDuration","18","./actions/drop","./autoScroll","./autoStart/delay","./autoStart/drag","./autoStart/gesture","./autoStart/resize","./inertia","./interact","./interactablePreventDefault.js","./legacyBrowsers","./modifiers/restrict","./modifiers/snap","./pointerEvents","./pointerEvents/interactableTargets","19","calcInertia","status","inertiaOptions","lambda","inertiaDur","log","v0","startEvent","sx","sy","modifiedXe","xe","vx0","modifiedYe","ye","vy0","te","lambda_v0","one_ve_v0","inertiaFrame","updateInertiaCoords","inertiaStatus","progress","exp","quadPoint","getQuadraticCurvePoint","animationFrame","boundInertiaFrame","active","smoothEndFrame","easeOutQuad","boundSmoothEndFrame","smoothEnd","pageUp","upCoords","clientUp","modifiers","vys","apply","resumeEvent","resetStatuses","modifierStatuses","statuses","pointerSpeed","inertiaPossible","modifierResult","setAll","shouldMove","locked","./InteractEvent","./modifiers","20","globalEvents","isSet","debug","getPointerAverage","pointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","closest","removeDocument","./Interactable","21","onInteractionEvent","checkAndPreventDefault","nodeName","_arr","eventSignal","dragstart","22","onIE8Dblclick","iFinder","prevTap","pointerEvents","collectEventTargets","toString","Object","obj","String","replace","isIE8","selectFix","onDocIE8","23","setOffsets","startOffset","setModifierOffsets","modifierOffsets","offsets","modifierName","setOffset","coordsArg","preEnd","requireEndOnly","result","changed","currentStatus","modifier","shouldDo","reset","modifyCoords","../utils/extend","24","endOnly","restriction","elementRect","restrictOptions","offset","pageCoords","useStatusXY","restrictedX","restrictedY","modifiedX","modifiedY","25","range","targets","relativePoints","snapOptions","snapOffset","relativeX","relativeY","realX","realY","offsetX","offsetY","_iterator3","_isArray3","_i3","snapTarget","inRange","snapChanged","snappedX","snappedY","createSnapGrid","grid","limits","gridx","round","gridy","newX","newY","26","preventOriginalDefault","originalEvent","firePointers","interval","createNewDoubleTap","pointerId","tapTime","props","eventable","doubleTap","getPath","createSignalListener","simpleSignals","simpleEvents","eventCopy","types","27","collectSelectors","els","../utils/arr","28","documents","onWindowUnload","./utils/domObjects","29","Signals","targetListeners","./arr","30","array","source","31","domObjects","DocumentTouch","isOperaMobile","navigator","appName","userAgent","isIOS7","platform","appVersion","all","atob","prefixedMatchesSelector","Element","MSPointerEvent","over","out","./domObjects","./isType","./window","32","blank","DocumentFragment","SVGElement","SVGSVGElement","SVGElementInstance","HTMLElement","Event","Touch","33","parent","child","node","isDocFrag","host","matchesSelectorPolyfill","elems","nodeList","realWindow","deepestZoneParents","dropzoneParents","deepestZone","unshift","ownerSVGElement","parents","lastChild","previousSibling","limit","correspondingUseElement","getScrollXY","relevantWindow","scrollX","scrollY","clientRect","getBoundingClientRect","getClientRects","_scroll","./browser","34","elementIndex","typeCount","attachedListeners","useAttachEvent","supplied","wrapped","useCount","_attachedListeners$elementIndex","listenerIndex","wrappedListener","srcElement","preventDef","stopProp","stopImmProp","addEvent","removeEvent","hasOwnProperty","matchFound","fn","useCap","fakeEvent","pExtend","returnValue","cancelBubble","arr","_elements","_targets","_attachedListeners","./domUtils","./pointerExtend","35","dest","36","37","sqrt","38","warnOnce","message","warned","console","warn","arguments","_getQBezierValue","p1","p2","p3","iT","startX","startY","cpX","cpY","endX","endY","position","b","c","d","src","./extend","./getOriginXY","./hypot","./pointerUtils","39","methodOrder","mouseEvent","details","simulationResume","firstNonActive","_iterator4","_isArray4","_i4","hasPointer","_ref9","_iterator5","_isArray5","_i5","idle","_ref10","_iterator6","_isArray6","_i6","40","nodeType","thing","./isWindow","41","Window","42","prefixedPropREs","deprecated","vendor","webkit","43","dom","pointerUtils","targetObj","prev","cur","isNativePointer","getXY","getClientXY","identifier","tmpXY","getTouchPair","average","screenX","screenY","minX","minY","maxX","maxY","sourceX","sourceY","44","vendors","lastTime","requestAnimationFrame","currTime","timeToCall","45","el","createTextNode","wrap","rootNode","defaultView","parentWindow"],"mappings":"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","file":"interact.min.js","sourcesContent":["/**\r\n * interact.js undefined\r\n *\r\n * Copyright (c) 2012-2016 Taye Adeyemi <dev@taye.me>\r\n * Open source under the MIT License.\r\n * https://raw.github.com/taye/interact.js/master/LICENSE\r\n */\r\n","/*\r\n * In a (windowless) server environment this file exports a factory function\r\n * that takes the window to use.\r\n *\r\n *     var interact = require('interact.js')(windowObject);\r\n *\r\n * See https://github.com/taye/interact.js/issues/187\r\n */\r\nif (typeof window === 'undefined') {\r\n  module.exports = function (window) {\r\n    require('./src/utils/window').init(window);\r\n\r\n    return require('./src/index');\r\n  };\r\n}\r\nelse {\r\n  module.exports = require('./src/index');\r\n}\r\n","/**\r\n * interact.js undefined\r\n *\r\n * Copyright (c) 2012-2016 Taye Adeyemi <dev@taye.me>\r\n * Open source under the MIT License.\r\n * https://raw.github.com/taye/interact.js/master/LICENSE\r\n */\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\r\n * In a (windowless) server environment this file exports a factory function\r\n * that takes the window to use.\r\n *\r\n *     var interact = require('interact.js')(windowObject);\r\n *\r\n * See https://github.com/taye/interact.js/issues/187\r\n */\nif (typeof window === 'undefined') {\n  module.exports = function (window) {\n    require('./src/utils/window').init(window);\n\n    return require('./src/index');\n  };\n} else {\n  module.exports = require('./src/index');\n}\n\n},{\"./src/index\":18,\"./src/utils/window\":45}],2:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _require = require('./utils/arr');\n\nvar indexOf = _require.indexOf;\n\nfunction fireUntilImmediateStopped(event, listeners) {\n  for (var i = 0, len = listeners.length; i < len && !event.immediatePropagationStopped; i++) {\n    listeners[i](event);\n  }\n}\n\nvar Eventable = (function () {\n  function Eventable() {\n    _classCallCheck(this, Eventable);\n  }\n\n  Eventable.prototype.fire = function fire(event) {\n    var listeners = undefined;\n    var onEvent = 'on' + event.type;\n    var global = this.global;\n\n    // Interactable#on() listeners\n    if (listeners = this[event.type]) {\n      fireUntilImmediateStopped(event, listeners);\n    }\n\n    // interactable.onevent listener\n    if (this[onEvent]) {\n      this[onEvent](event);\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners);\n    }\n  };\n\n  Eventable.prototype.on = function on(eventType, listener) {\n    // if this type of event was never bound\n    if (!(eventType in this)) {\n      this[eventType] = [listener];\n    } else {\n      this[eventType].push(listener);\n    }\n  };\n\n  Eventable.prototype.off = function off(eventType, listener) {\n    // if it is an action event type\n    var eventList = this[eventType];\n    var index = eventList ? indexOf(eventList, listener) : -1;\n\n    if (index !== -1) {\n      this[eventType].splice(index, 1);\n    }\n  };\n\n  return Eventable;\n})();\n\nmodule.exports = Eventable;\n\n},{\"./utils/arr\":30}],3:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar extend = require('./utils/extend');\nvar getOriginXY = require('./utils/getOriginXY');\nvar defaults = require('./defaultOptions');\nvar signals = require('./utils/Signals')['new']();\n\nvar InteractEvent = (function () {\n  function InteractEvent(interaction, event, action, phase, element, related) {\n    _classCallCheck(this, InteractEvent);\n\n    var target = interaction.target;\n    var deltaSource = (target && target.options || defaults).deltaSource;\n    var origin = getOriginXY(target, element);\n    var starting = phase === 'start';\n    var ending = phase === 'end';\n    var coords = starting ? interaction.startCoords : interaction.curCoords;\n\n    element = element || interaction.element;\n\n    var page = extend({}, coords.page);\n    var client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    this.ctrlKey = event.ctrlKey;\n    this.altKey = event.altKey;\n    this.shiftKey = event.shiftKey;\n    this.metaKey = event.metaKey;\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.target = element;\n    this.currentTarget = element;\n    this.relatedTarget = related || null;\n    this.t0 = interaction.downTimes[interaction.downTimes.length - 1];\n    this.type = action + (phase || '');\n    this.interaction = interaction;\n    this.interactable = target;\n\n    var signalArg = {\n      interaction: interaction,\n      event: event,\n      action: action,\n      phase: phase,\n      element: element,\n      related: related,\n      page: page,\n      client: client,\n      coords: coords,\n      starting: starting,\n      ending: ending,\n      deltaSource: deltaSource,\n      iEvent: this\n    };\n\n    signals.fire('set-xy', signalArg);\n\n    if (ending) {\n      var prevEvent = interaction.prevEvent;\n\n      // use previous coords when ending\n      this.pageX = prevEvent.pageX;\n      this.pageY = prevEvent.pageY;\n      this.clientX = prevEvent.clientX;\n      this.clientY = prevEvent.clientY;\n    } else {\n      this.pageX = page.x;\n      this.pageY = page.y;\n      this.clientX = client.x;\n      this.clientY = client.y;\n    }\n\n    this.x0 = interaction.startCoords.page.x - origin.x;\n    this.y0 = interaction.startCoords.page.y - origin.y;\n    this.clientX0 = interaction.startCoords.client.x - origin.x;\n    this.clientY0 = interaction.startCoords.client.y - origin.y;\n\n    signals.fire('set-delta', signalArg);\n\n    this.timeStamp = coords.timeStamp;\n    this.dt = interaction.pointerDelta.timeStamp;\n    this.duration = this.timeStamp - interaction.downTimes[0];\n\n    // speed and velocity in pixels per second\n    this.speed = interaction.pointerDelta[deltaSource].speed;\n    this.velocityX = interaction.pointerDelta[deltaSource].vx;\n    this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null;\n\n    signals.fire('new', signalArg);\n  }\n\n  InteractEvent.prototype.getSwipe = function getSwipe() {\n    var interaction = this.interaction;\n\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null;\n    }\n\n    var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\n    var overlap = 22.5;\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    var left = 135 - overlap <= angle && angle < 225 + overlap;\n    var up = 225 - overlap <= angle && angle < 315 + overlap;\n\n    var right = !left && (315 - overlap <= angle || angle < 45 + overlap);\n    var down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n\n    return {\n      up: up,\n      down: down,\n      left: left,\n      right: right,\n      angle: angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY\n      }\n    };\n  };\n\n  InteractEvent.prototype.preventDefault = function preventDefault() {};\n\n  InteractEvent.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n    this.immediatePropagationStopped = this.propagationStopped = true;\n  };\n\n  InteractEvent.prototype.stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n\n  return InteractEvent;\n})();\n\nsignals.on('set-delta', function (_ref) {\n  var iEvent = _ref.iEvent;\n  var interaction = _ref.interaction;\n  var starting = _ref.starting;\n  var deltaSource = _ref.deltaSource;\n\n  var prevEvent = starting ? iEvent : interaction.prevEvent;\n\n  if (deltaSource === 'client') {\n    iEvent.dx = iEvent.clientX - prevEvent.clientX;\n    iEvent.dy = iEvent.clientY - prevEvent.clientY;\n  } else {\n    iEvent.dx = iEvent.pageX - prevEvent.pageX;\n    iEvent.dy = iEvent.pageY - prevEvent.pageY;\n  }\n});\n\nInteractEvent.signals = signals;\n\nmodule.exports = InteractEvent;\n\n},{\"./defaultOptions\":17,\"./utils/Signals\":29,\"./utils/extend\":35,\"./utils/getOriginXY\":36}],4:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar isType = require('./utils/isType');\nvar events = require('./utils/events');\nvar extend = require('./utils/extend');\nvar actions = require('./actions');\nvar scope = require('./scope');\nvar Eventable = require('./Eventable');\nvar defaults = require('./defaultOptions');\nvar signals = require('./utils/Signals')['new']();\n\nvar _require = require('./utils/domUtils');\n\nvar getElementRect = _require.getElementRect;\nvar nodeContains = _require.nodeContains;\n\nvar _require2 = require('./utils/arr');\n\nvar indexOf = _require2.indexOf;\nvar contains = _require2.contains;\n\nvar _require3 = require('./utils/browser');\n\nvar wheelEvent = _require3.wheelEvent;\n\n// all set interactables\nscope.interactables = [];\n\n/*\\\r\n * Interactable\r\n [ property ]\r\n **\r\n * Object type returned by @interact\r\n\\*/\n\nvar Interactable = (function () {\n  function Interactable(target, options) {\n    _classCallCheck(this, Interactable);\n\n    this.target = target;\n    this._context = scope.document;\n    this._iEvents = new Eventable();\n\n    var _window = undefined;\n\n    if (isType.trySelector(target)) {\n      this.target = target;\n\n      var context = options && options.context;\n\n      _window = context ? scope.getWindow(context) : scope.window;\n\n      if (context && (_window.Node ? context instanceof _window.Node : isType.isElement(context) || context === _window.document)) {\n\n        this._context = context;\n      }\n    } else {\n      _window = scope.getWindow(target);\n    }\n\n    this._doc = _window.document;\n\n    signals.fire('new', {\n      target: target,\n      options: options,\n      interactable: this,\n      win: _window\n    });\n\n    scope.addDocument(this._doc, _window);\n\n    scope.interactables.push(this);\n\n    this.set(options);\n  }\n\n  Interactable.prototype.setOnEvents = function setOnEvents(action, phases) {\n    var onAction = 'on' + action;\n\n    if (isType.isFunction(phases.onstart)) {\n      this._iEvents[onAction + 'start'] = phases.onstart;\n    }\n    if (isType.isFunction(phases.onmove)) {\n      this._iEvents[onAction + 'move'] = phases.onmove;\n    }\n    if (isType.isFunction(phases.onend)) {\n      this._iEvents[onAction + 'end'] = phases.onend;\n    }\n    if (isType.isFunction(phases.oninertiastart)) {\n      this._iEvents[onAction + 'inertiastart'] = phases.oninertiastart;\n    }\n\n    return this;\n  };\n\n  Interactable.prototype.setPerAction = function setPerAction(action, options) {\n    // for all the default per-action options\n    for (var option in options) {\n      // if this option exists for this action\n      if (option in defaults[action]) {\n        // if the option in the options arg is an object value\n        if (isType.isObject(options[option])) {\n          // duplicate the object\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n          if (isType.isObject(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\n            this.options[action][option].enabled = options[option].enabled === false ? false : true;\n          }\n        } else if (isType.isBool(options[option]) && isType.isObject(defaults.perAction[option])) {\n          this.options[action][option].enabled = options[option];\n        } else if (options[option] !== undefined) {\n          // or if it's not undefined, do a plain assignment\n          this.options[action][option] = options[option];\n        }\n      }\n    }\n  };\n\n  /*\\\r\n   * Interactable.getRect\r\n   [ method ]\r\n   *\r\n   * The default function to get an Interactables bounding rect. Can be\r\n   * overridden using @Interactable.rectChecker.\r\n   *\r\n   - element (Element) #optional The element to measure.\r\n   = (object) The object's bounding rectangle.\r\n   o {\r\n   o     top   : 0,\r\n   o     left  : 0,\r\n   o     bottom: 0,\r\n   o     right : 0,\r\n   o     width : 0,\r\n   o     height: 0\r\n   o }\r\n  \\*/\n\n  Interactable.prototype.getRect = function getRect(element) {\n    element = element || this.target;\n\n    if (isType.isString(this.target) && !isType.isElement(element)) {\n      element = this._context.querySelector(this.target);\n    }\n\n    return getElementRect(element);\n  };\n\n  /*\\\r\n   * Interactable.rectChecker\r\n   [ method ]\r\n   *\r\n   * Returns or sets the function used to calculate the interactable's\r\n   * element's rectangle\r\n   *\r\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\r\n   = (function | object) The checker function or this Interactable\r\n  \\*/\n\n  Interactable.prototype.rectChecker = function rectChecker(checker) {\n    if (isType.isFunction(checker)) {\n      this.getRect = checker;\n\n      return this;\n    }\n\n    if (checker === null) {\n      delete this.options.getRect;\n\n      return this;\n    }\n\n    return this.getRect;\n  };\n\n  /*\\\r\n   * Interactable.origin\r\n   [ method ]\r\n   *\r\n   * Gets or sets the origin of the Interactable's element.  The x and y\r\n   * of the origin will be subtracted from action event coordinates.\r\n   *\r\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\r\n   * OR\r\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\r\n   **\r\n   = (object) The current origin or this Interactable\r\n  \\*/\n\n  Interactable.prototype.origin = function origin(newValue) {\n    if (isType.trySelector(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    } else if (isType.isObject(newValue)) {\n      this.options.origin = newValue;\n      return this;\n    }\n\n    return this.options.origin;\n  };\n\n  /*\\\r\n   * Interactable.deltaSource\r\n   [ method ]\r\n   *\r\n   * Returns or sets the mouse coordinate types used to calculate the\r\n   * movement of the pointer.\r\n   *\r\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\r\n   = (string | object) The current deltaSource or this Interactable\r\n  \\*/\n\n  Interactable.prototype.deltaSource = function deltaSource(newValue) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue;\n\n      return this;\n    }\n\n    return this.options.deltaSource;\n  };\n\n  Interactable.prototype.cursorTarget = function cursorTarget(newValue) {\n    this.options.cursorTarget = newValue;\n    return this;\n  };\n\n  /*\\\r\n   * Interactable.context\r\n   [ method ]\r\n   *\r\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\r\n   *\r\n   = (Node) The context Node of this Interactable\r\n   **\r\n  \\*/\n\n  Interactable.prototype.context = function context() {\n    return this._context;\n  };\n\n  Interactable.prototype.inContext = function inContext(element) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element);\n  };\n\n  /*\\\r\n   * Interactable.fire\r\n   [ method ]\r\n   *\r\n   * Calls listeners for the given InteractEvent type bound globally\r\n   * and directly to this Interactable\r\n   *\r\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\r\n   = (Interactable) this Interactable\r\n  \\*/\n\n  Interactable.prototype.fire = function fire(iEvent) {\n    this._iEvents.fire(iEvent);\n\n    return this;\n  };\n\n  Interactable.prototype._onOffMultiple = function _onOffMultiple(method, eventType, listener, useCapture) {\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\n      eventType = eventType.trim().split(/ +/);\n    }\n\n    if (isType.isArray(eventType)) {\n      for (var i = 0; i < eventType.length; i++) {\n        this[method](eventType[i], listener, useCapture);\n      }\n\n      return true;\n    }\n\n    if (isType.isObject(eventType)) {\n      for (var prop in eventType) {\n        this[method](prop, eventType[prop], listener);\n      }\n\n      return true;\n    }\n  };\n\n  /*\\\r\n   * Interactable.on\r\n   [ method ]\r\n   *\r\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\r\n   *\r\n   - eventType  (string | array | object) The types of events to listen for\r\n   - listener   (function) The function event (s)\r\n   - useCapture (boolean) #optional useCapture flag for addEventListener\r\n   = (object) This Interactable\r\n  \\*/\n\n  Interactable.prototype.on = function on(eventType, listener, useCapture) {\n    // convert to boolean\n    useCapture = !!useCapture;\n\n    if (this._onOffMultiple('on', eventType, listener, useCapture)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') {\n      eventType = wheelEvent;\n    }\n\n    if (contains(Interactable.eventTypes, eventType)) {\n      this._iEvents.on(eventType, listener);\n    }\n    // delegated event for selector\n    else if (isType.isString(this.target)) {\n        events.addDelegate(this.target, this._context, eventType, listener, useCapture);\n      } else {\n        events.add(this.target, eventType, listener, useCapture);\n      }\n\n    return this;\n  };\n\n  /*\\\r\n   * Interactable.off\r\n   [ method ]\r\n   *\r\n   * Removes an InteractEvent, pointerEvent or DOM event listener\r\n   *\r\n   - eventType  (string | array | object) The types of events that were listened for\r\n   - listener   (function) The listener function to be removed\r\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\r\n   = (object) This Interactable\r\n  \\*/\n\n  Interactable.prototype.off = function off(eventType, listener, useCapture) {\n    // convert to boolean\n    useCapture = !!useCapture;\n\n    if (this._onOffMultiple('off', eventType, listener, useCapture)) {\n      return this;\n    }\n\n    if (eventType === 'wheel') {\n      eventType = wheelEvent;\n    }\n\n    // if it is an action event type\n    if (contains(Interactable.eventTypes, eventType)) {\n      this._iEvents.on(eventType, listener);\n    }\n    // delegated event\n    else if (isType.isString(this.target)) {\n        events.removeDelegate(this.target, this._context, eventType, listener, useCapture);\n      }\n      // remove listener from this Interatable's element\n      else {\n          events.remove(this.target, eventType, listener, useCapture);\n        }\n\n    return this;\n  };\n\n  /*\\\r\n   * Interactable.set\r\n   [ method ]\r\n   *\r\n   * Reset the options of this Interactable\r\n   - options (object) The new settings to apply\r\n   = (object) This Interactable\r\n  \\*/\n\n  Interactable.prototype.set = function set(options) {\n    if (!isType.isObject(options)) {\n      options = {};\n    }\n\n    this.options = extend({}, defaults.base);\n\n    var perActions = extend({}, defaults.perAction);\n\n    for (var actionName in actions.methodDict) {\n      var methodName = actions.methodDict[actionName];\n\n      this.options[actionName] = extend({}, defaults[actionName]);\n\n      this.setPerAction(actionName, perActions);\n\n      this[methodName](options[actionName]);\n    }\n\n    for (var _iterator = Interactable.settingsMethods, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var setting = _ref;\n\n      this.options[setting] = defaults.base[setting];\n\n      if (setting in options) {\n        this[setting](options[setting]);\n      }\n    }\n\n    return this;\n  };\n\n  /*\\\r\n   * Interactable.unset\r\n   [ method ]\r\n   *\r\n   * Remove this interactable from the list of interactables and remove\r\n   * it's action capabilities and event listeners\r\n   *\r\n   = (object) @interact\r\n  \\*/\n\n  Interactable.prototype.unset = function unset() {\n    events.remove(this.target, 'all');\n\n    if (isType.isString(this.target)) {\n      // remove delegated events\n      for (var type in events.delegatedEvents) {\n        var delegated = events.delegatedEvents[type];\n\n        for (var i = 0; i < delegated.selectors.length; i++) {\n          if (delegated.selectors[i] === this.target && delegated.contexts[i] === this._context) {\n\n            delegated.selectors.splice(i, 1);\n            delegated.contexts.splice(i, 1);\n            delegated.listeners.splice(i, 1);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegated[type] = null;\n            }\n          }\n\n          events.remove(this._context, type, events.delegateListener);\n          events.remove(this._context, type, events.delegateUseCapture, true);\n\n          break;\n        }\n      }\n    } else {\n      events.remove(this, 'all');\n    }\n\n    signals.fire('unset', { interactable: this });\n\n    scope.interactables.splice(indexOf(scope.interactables, this), 1);\n\n    // Stop related interactions when an Interactable is unset\n    for (var _iterator2 = scope.interactions || [], _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var interaction = _ref2;\n\n      if (interaction.target === this && interaction.interacting()) {\n        interaction.stop();\n      }\n    }\n\n    return scope.interact;\n  };\n\n  return Interactable;\n})();\n\nscope.interactables.indexOfElement = function indexOfElement(target, context) {\n  context = context || scope.document;\n\n  for (var i = 0; i < this.length; i++) {\n    var interactable = this[i];\n\n    if (interactable.target === target && (!isType.isString(target) || interactable._context === context)) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nscope.interactables.get = function interactableGet(element, options) {\n  return this[this.indexOfElement(element, options && options.context)];\n};\n\nscope.interactables.forEachSelector = function (callback) {\n  for (var i = 0; i < this.length; i++) {\n    var interactable = this[i];\n\n    // skip non CSS selector targets\n    if (!isType.isString(interactable.target)) {\n      continue;\n    }\n\n    var ret = callback(interactable, interactable.target, interactable._context, i, this);\n\n    if (ret !== undefined) {\n      return ret;\n    }\n  }\n};\n\n// all interact.js eventTypes\nInteractable.eventTypes = scope.eventTypes = [];\n\nInteractable.signals = signals;\n\nInteractable.settingsMethods = ['deltaSource', 'origin', 'preventDefault', 'rectChecker', 'cursorTarget'];\n\nmodule.exports = Interactable;\n\n},{\"./Eventable\":2,\"./actions\":9,\"./defaultOptions\":17,\"./scope\":28,\"./utils/Signals\":29,\"./utils/arr\":30,\"./utils/browser\":31,\"./utils/domUtils\":33,\"./utils/events\":34,\"./utils/extend\":35,\"./utils/isType\":40}],5:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar scope = require('./scope');\nvar utils = require('./utils');\nvar events = require('./utils/events');\nvar browser = require('./utils/browser');\nvar finder = require('./utils/interactionFinder');\nvar signals = require('./utils/Signals')['new']();\n\nvar listeners = {};\nvar methodNames = ['pointerDown', 'pointerMove', 'pointerUp', 'updatePointer', 'removePointer'];\n\n// for ignoring browser's simulated mouse events\nvar prevTouchTime = 0;\n\n// all active and idle interactions\nscope.interactions = [];\n\nvar Interaction = (function () {\n  function Interaction() {\n    _classCallCheck(this, Interaction);\n\n    this.target = null; // current interactable being interacted with\n    this.element = null; // the target element of the interactable\n\n    this.prepared = { // action that's ready to be fired on next move event\n      name: null,\n      axis: null,\n      edges: null\n    };\n\n    // keep track of added pointers\n    this.pointers = [];\n    this.pointerIds = [];\n    this.downTargets = [];\n    this.downTimes = [];\n    this.holdTimers = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page: { x: 0, y: 0 },\n      client: { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0\n    };\n\n    this.downEvent = null; // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null; // previous action event\n\n    this.pointerIsDown = false;\n    this.pointerWasMoved = false;\n    this._interacting = false;\n\n    this.mouse = false;\n\n    signals.fire('new', this);\n\n    scope.interactions.push(this);\n  }\n\n  Interaction.prototype.pointerDown = function pointerDown(pointer, event, eventTarget) {\n    var pointerIndex = this.updatePointer(pointer);\n\n    this.pointerIsDown = true;\n\n    if (!this.interacting()) {\n      utils.setCoords(this.startCoords, this.pointers);\n\n      utils.copyCoords(this.curCoords, this.startCoords);\n      utils.copyCoords(this.prevCoords, this.startCoords);\n\n      this.downEvent = event;\n\n      this.downTimes[pointerIndex] = this.curCoords.timeStamp;\n      this.downTargets[pointerIndex] = eventTarget;\n\n      this.pointerWasMoved = false;\n\n      utils.pointerExtend(this.downPointer, pointer);\n    }\n\n    signals.fire('down', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      pointerIndex: pointerIndex,\n      interaction: this\n    });\n  };\n\n  /*\\\r\n   * Interaction.start\r\n   [ method ]\r\n   *\r\n   * Start an action with the given Interactable and Element as tartgets. The\r\n   * action must be enabled for the target Interactable and an appropriate number\r\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\r\n   *\r\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\r\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\r\n   *\r\n   - action  (object)  The action to be performed - drag, resize, etc.\r\n   - target  (Interactable) The Interactable to target\r\n   - element (Element) The DOM Element to target\r\n   = (object) interact\r\n   **\r\n   | interact(target)\r\n   |   .draggable({\r\n   |     // disable the default drag start by down->move\r\n   |     manualStart: true\r\n   |   })\r\n   |   // start dragging after the user holds the pointer down\r\n   |   .on('hold', function (event) {\r\n   |     var interaction = event.interaction;\r\n   |\r\n   |     if (!interaction.interacting()) {\r\n   |       interaction.start({ name: 'drag' },\r\n   |                         event.interactable,\r\n   |                         event.currentTarget);\r\n   |     }\r\n   | });\r\n   \\*/\n\n  Interaction.prototype.start = function start(action, target, element) {\n    if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n      return;\n    }\n\n    // if this interaction had been removed after stopping\n    // add it back\n    if (utils.indexOf(scope.interactions, this) === -1) {\n      scope.interactions.push(this);\n    }\n\n    utils.copyAction(this.prepared, action);\n    this.target = target;\n    this.element = element;\n\n    signals.fire('action-start', {\n      interaction: this,\n      event: this.downEvent\n    });\n  };\n\n  Interaction.prototype.pointerMove = function pointerMove(pointer, event, eventTarget) {\n    if (!this.simulation) {\n      this.updatePointer(pointer);\n      utils.setCoords(this.curCoords, this.pointers);\n    }\n\n    var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n\n    var dx = undefined;\n    var dy = undefined;\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.curCoords.client.x - this.startCoords.client.x;\n      dy = this.curCoords.client.y - this.startCoords.client.y;\n\n      this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\n    }\n\n    var signalArg = {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      dx: dx,\n      dy: dy,\n      duplicate: duplicateMove,\n      interaction: this,\n      interactingBeforeMove: this.interacting()\n    };\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and speeds\n      utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n    }\n\n    signals.fire('move', signalArg);\n\n    if (!duplicateMove) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        this.doMove(signalArg);\n      }\n\n      if (this.pointerWasMoved) {\n        utils.copyCoords(this.prevCoords, this.curCoords);\n      }\n    }\n  };\n\n  /*\\\r\n   * Interaction.doMove\r\n   [ method ]\r\n   *\r\n   * Force a move of the current action at the same coordinates. Useful if\r\n   * snap/restrict has been changed and you want a movement with the new\r\n   * settings.\r\n   *\r\n   **\r\n   | interact(target)\r\n   |   .draggable(true)\r\n   |   .on('dragmove', function (event) {\r\n   |     if (someCondition) {\r\n   |       // change the snap settings\r\n   |       event.interactable.draggable({ snap: { targets: [] }});\r\n   |       // fire another move event with re-calculated snap\r\n   |       event.interaction.doMove();\r\n   |     }\r\n   |   });\r\n   \\*/\n\n  Interaction.prototype.doMove = function doMove(signalArg) {\n    signalArg = utils.extend({\n      pointer: this.pointers[0],\n      event: this.prevEvent,\n      eventTarget: this._eventTarget,\n      interaction: this\n    }, signalArg || {});\n\n    signals.fire('before-action-move', signalArg);\n\n    if (!this._dontFireMove) {\n      signals.fire('action-move', signalArg);\n    }\n\n    this._dontFireMove = false;\n  };\n\n  // End interact move events and stop auto-scroll unless simulation is running\n\n  Interaction.prototype.pointerUp = function pointerUp(pointer, event, eventTarget, curEventTarget) {\n    var pointerIndex = this.mouse ? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\n\n    clearTimeout(this.holdTimers[pointerIndex]);\n\n    signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {\n      pointer: pointer,\n      event: event,\n      eventTarget: eventTarget,\n      curEventTarget: curEventTarget,\n      interaction: this\n    });\n\n    if (!this.simulation) {\n      this.end(event);\n    }\n\n    this.removePointer(pointer);\n  };\n\n  /*\\\r\n   * Interaction.end\r\n   [ method ]\r\n   *\r\n   * Stop the current action and fire an end event. Inertial movement does\r\n   * not happen.\r\n   *\r\n   - event (PointerEvent) #optional\r\n   **\r\n   | interact(target)\r\n   |   .draggable(true)\r\n   |   .on('move', function (event) {\r\n   |     if (event.pageX > 1000) {\r\n   |       // end the current action\r\n   |       event.interaction.end();\r\n   |       // stop all further listeners from being called\r\n   |       event.stopImmediatePropagation();\r\n   |     }\r\n   |   });\r\n   \\*/\n\n  Interaction.prototype.end = function end(event) {\n    event = event || this.prevEvent;\n\n    if (this.interacting()) {\n      signals.fire('action-end', {\n        event: event,\n        interaction: this\n      });\n    }\n\n    this.stop();\n  };\n\n  Interaction.prototype.currentAction = function currentAction() {\n    return this._interacting ? this.prepared.name : null;\n  };\n\n  Interaction.prototype.interacting = function interacting() {\n    return this._interacting;\n  };\n\n  Interaction.prototype.stop = function stop() {\n    signals.fire('stop', { interaction: this });\n\n    if (this._interacting) {\n      signals.fire('stop-active', { interaction: this });\n      signals.fire('stop-' + this.prepared.name, { interaction: this });\n    }\n\n    this.target = this.element = null;\n\n    this.pointerIsDown = this._interacting = false;\n    this.prepared.name = this.prevEvent = null;\n  };\n\n  Interaction.prototype.updatePointer = function updatePointer(pointer) {\n    var id = utils.getPointerId(pointer);\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      index = this.pointerIds.length;\n    }\n\n    this.pointerIds[index] = id;\n    this.pointers[index] = pointer;\n\n    return index;\n  };\n\n  Interaction.prototype.removePointer = function removePointer(pointer) {\n    var id = utils.getPointerId(pointer);\n    var index = this.mouse ? 0 : utils.indexOf(this.pointerIds, id);\n\n    if (index === -1) {\n      return;\n    }\n\n    this.pointers.splice(index, 1);\n    this.pointerIds.splice(index, 1);\n    this.downTargets.splice(index, 1);\n    this.downTimes.splice(index, 1);\n    this.holdTimers.splice(index, 1);\n  };\n\n  Interaction.prototype._updateEventTargets = function _updateEventTargets(target, currentTarget) {\n    this._eventTarget = target;\n    this._curEventTarget = currentTarget;\n  };\n\n  return Interaction;\n})();\n\nfor (var i = 0, len = methodNames.length; i < len; i++) {\n  var method = methodNames[i];\n\n  listeners[method] = doOnInteractions(method);\n}\n\nfunction doOnInteractions(method) {\n  return function (event) {\n    var eventTarget = utils.getActualElement(event.path ? event.path[0] : event.target);\n    var curEventTarget = utils.getActualElement(event.currentTarget);\n    var matches = []; // [ [pointer, interaction], ...]\n\n    if (browser.supportsTouch && /touch/.test(event.type)) {\n      prevTouchTime = new Date().getTime();\n\n      for (var i = 0; i < event.changedTouches.length; i++) {\n        var pointer = event.changedTouches[i];\n        var interaction = finder.search(pointer, event.type, eventTarget);\n\n        matches.push([pointer, interaction || new Interaction()]);\n      }\n    } else {\n      var invalidPointer = false;\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (var i = 0; i < scope.interactions.length && !invalidPointer; i++) {\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer = invalidPointer || new Date().getTime() - prevTouchTime < 500;\n      }\n\n      if (!invalidPointer) {\n        var interaction = finder.search(event, event.type, eventTarget);\n\n        if (!interaction) {\n\n          interaction = new Interaction();\n          interaction.mouse = /mouse/i.test(event.pointerType || event.type)\n          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n           || event.pointerType === 4;\n        }\n\n        matches.push([event, interaction]);\n      }\n    }\n\n    for (var _iterator = matches, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pointer = _ref[0];\n      var interaction = _ref[1];\n\n      interaction._updateEventTargets(eventTarget, curEventTarget);\n      interaction[method](pointer, event, eventTarget, curEventTarget);\n    }\n  };\n}\n\nfunction endAll(event) {\n  for (var i = 0; i < scope.interactions.length; i++) {\n    scope.interactions[i].end(event);\n  }\n}\n\nvar docEvents = {/* 'eventType': listenerFunc */};\nvar pEventTypes = browser.pEventTypes;\n\nif (scope.PointerEvent) {\n  docEvents[pEventTypes.down] = listeners.pointerDown;\n  docEvents[pEventTypes.move] = listeners.pointerMove;\n  docEvents[pEventTypes.up] = listeners.pointerUp;\n  docEvents[pEventTypes.cancel] = listeners.pointerUp;\n} else {\n  docEvents.mousedown = listeners.pointerDown;\n  docEvents.mousemove = listeners.pointerMove;\n  docEvents.mouseup = listeners.pointerUp;\n\n  docEvents.touchstart = listeners.pointerDown;\n  docEvents.touchmove = listeners.pointerMove;\n  docEvents.touchend = listeners.pointerUp;\n  docEvents.touchcancel = listeners.pointerUp;\n}\n\ndocEvents.blur = endAll;\n\nfunction onDocSignal(_ref2, signalName) {\n  var doc = _ref2.doc;\n\n  var eventMethod = signalName.indexOf('add') === 0 ? events.add : events.remove;\n\n  // delegate event listener\n  for (var eventType in scope.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener);\n    eventMethod(doc, eventType, events.delegateUseCapture, true);\n  }\n\n  for (var eventType in docEvents) {\n    eventMethod(doc, eventType, docEvents[eventType]);\n  }\n}\n\nscope.signals.on('add-document', onDocSignal);\nscope.signals.on('remove-document', onDocSignal);\n\nInteraction.pointerMoveTolerance = 1;\nInteraction.doOnInteractions = doOnInteractions;\nInteraction.endAll = endAll;\nInteraction.signals = signals;\nInteraction.docEvents = docEvents;\n\nscope.endAllInteractions = endAll;\n\nmodule.exports = Interaction;\n\n},{\"./scope\":28,\"./utils\":38,\"./utils/Signals\":29,\"./utils/browser\":31,\"./utils/events\":34,\"./utils/interactionFinder\":39}],6:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar drag = {\n  defaults: {\n    enabled: false,\n\n    snap: null,\n    restrict: null,\n    inertia: null,\n    autoScroll: null,\n\n    startAxis: 'xy',\n    lockAxis: 'xy'\n  },\n\n  checker: function (pointer, event, interactable) {\n    var dragOptions = interactable.options.drag;\n\n    return dragOptions.enabled ? { name: 'drag', axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis } : null;\n  },\n\n  getCursor: function () {\n    return 'move';\n  }\n};\n\nInteraction.signals.on('action-start', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  var dragEvent = new InteractEvent(interaction, event, 'drag', 'start', interaction.element);\n\n  interaction._interacting = true;\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n});\n\nInteraction.signals.on('before-action-move', function (_ref2) {\n  var interaction = _ref2.interaction;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  var axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    interaction.curCoords.page.y = interaction.startCoords.page.y;\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\n\n    interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vx);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\n    interaction.pointerDelta.client.vy = 0;\n    interaction.pointerDelta.page.vy = 0;\n  } else if (axis === 'y') {\n    interaction.curCoords.page.x = interaction.startCoords.page.x;\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\n\n    interaction.pointerDelta.page.speed = Math.abs(interaction.pointerDelta.page.vy);\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\n    interaction.pointerDelta.client.vx = 0;\n    interaction.pointerDelta.page.vx = 0;\n  }\n});\n\nInteraction.signals.on('action-move', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var event = _ref3.event;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  var dragEvent = new InteractEvent(interaction, event, 'drag', 'move', interaction.element);\n\n  var axis = interaction.prepared.axis;\n\n  if (axis === 'x') {\n    dragEvent.pageY = interaction.startCoords.page.y;\n    dragEvent.clientY = interaction.startCoords.client.y;\n    dragEvent.dy = 0;\n  } else if (axis === 'y') {\n    dragEvent.pageX = interaction.startCoords.page.x;\n    dragEvent.clientX = interaction.startCoords.client.x;\n    dragEvent.dx = 0;\n  }\n\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n\n  // if the action was ended in a dragmove listener\n  if (!interaction.interacting()) {\n    return false;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var event = _ref4.event;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  var dragEvent = new InteractEvent(interaction, event, 'drag', 'end', interaction.element);\n\n  interaction.target.fire(dragEvent);\n  interaction.prevEvent = dragEvent;\n});\n\n/*\\\r\n * Interactable.draggable\r\n [ method ]\r\n *\r\n * Gets or sets whether drag actions can be performed on the\r\n * Interactable\r\n *\r\n = (boolean) Indicates if this can be the target of drag events\r\n | var isDraggable = interact('ul li').draggable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\r\n = (object) This Interactable\r\n | interact(element).draggable({\r\n |     onstart: function (event) {},\r\n |     onmove : function (event) {},\r\n |     onend  : function (event) {},\r\n |\r\n |     // the axis in which the first movement must be\r\n |     // for the drag sequence to start\r\n |     // 'xy' by default - any direction\r\n |     startAxis: 'x' || 'y' || 'xy',\r\n |\r\n |     // 'xy' by default - don't restrict to one axis (move in any direction)\r\n |     // 'x' or 'y' to restrict movement to either axis\r\n |     // 'start' to restrict movement to the axis the drag started in\r\n |     lockAxis: 'x' || 'y' || 'xy' || 'start',\r\n |\r\n |     // max number of drags that can happen concurrently\r\n |     // with elements of this Interactable. Infinity by default\r\n |     max: Infinity,\r\n |\r\n |     // max number of drags that can target the same element+Interactable\r\n |     // 1 by default\r\n |     maxPerElement: 2\r\n | });\r\n\\*/\nInteractable.prototype.draggable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drag.enabled = options.enabled === false ? false : true;\n    this.setPerAction('drag', options);\n    this.setOnEvents('drag', options);\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis;\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drag.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drag;\n};\n\nactions.drag = drag;\nactions.names.push('drag');\nutils.merge(Interactable.eventTypes, ['dragstart', 'dragmove', 'draginertiastart', 'draginertiaresume', 'dragend']);\nactions.methodDict.drag = 'draggable';\n\ndefaultOptions.drag = drag.defaults;\n\nmodule.exports = drag;\n\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":17,\"../utils\":38,\"./index\":9}],7:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar scope = require('../scope');\nvar interact = require('../interact');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar drop = {\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer'\n  }\n};\n\nvar dynamicDrop = false;\n\nInteraction.signals.on('action-start', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  // reset active dropzones\n  interaction.activeDrops.dropzones = [];\n  interaction.activeDrops.elements = [];\n  interaction.activeDrops.rects = [];\n\n  interaction.dropEvents = null;\n\n  if (!interaction.dynamicDrop) {\n    setActiveDrops(interaction, interaction.element);\n  }\n\n  var dragEvent = interaction.prevEvent;\n  var dropEvents = getDropEvents(interaction, event, dragEvent);\n\n  if (dropEvents.activate) {\n    fireActiveDrops(interaction, dropEvents.activate);\n  }\n});\n\nInteractEvent.signals.on('new', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var iEvent = _ref3.iEvent;\n  var event = _ref3.event;\n\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n    return;\n  }\n\n  var draggableElement = interaction.element;\n  var dragEvent = iEvent;\n  var dropResult = getDrop(dragEvent, event, draggableElement);\n\n  interaction.dropTarget = dropResult.dropzone;\n  interaction.dropElement = dropResult.element;\n\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\n});\n\nInteraction.signals.on('action-move', function (_ref4) {\n  var interaction = _ref4.interaction;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  fireDropEvents(interaction, interaction.dropEvents);\n});\n\nInteraction.signals.on('action-end', function (_ref5) {\n  var interaction = _ref5.interaction;\n\n  if (interaction.prepared.name === 'drag') {\n    fireDropEvents(interaction, interaction.dropEvents);\n  }\n});\n\nInteraction.signals.on('stop-drag', function (_ref6) {\n  var interaction = _ref6.interaction;\n\n  interaction.activeDrops.dropzones = interaction.activeDrops.elements = interaction.activeDrops.rects = interaction.dropEvents = null;\n});\n\nfunction collectDrops(interaction, element) {\n  var drops = [];\n  var elements = [];\n\n  element = element || interaction.element;\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (var _iterator = scope.interactables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var current = _ref;\n\n    if (!current.options.drop.enabled) {\n      continue;\n    }\n\n    var accept = current.options.drop.accept;\n\n    // test the draggable element against the dropzone's accept setting\n    if (utils.isElement(accept) && accept !== element || utils.isString(accept) && !utils.matchesSelector(element, accept)) {\n\n      continue;\n    }\n\n    // query for new elements if necessary\n    var dropElements = utils.isString(current.target) ? current._context.querySelectorAll(current.target) : [current.target];\n\n    for (var i = 0; i < dropElements.length; i++) {\n      var currentElement = dropElements[i];\n\n      if (currentElement !== element) {\n        drops.push(current);\n        elements.push(currentElement);\n      }\n    }\n  }\n\n  return {\n    elements: elements,\n    dropzones: drops\n  };\n}\n\nfunction fireActiveDrops(interaction, event) {\n  var prevElement = undefined;\n\n  // loop through all active dropzones and trigger event\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    var current = interaction.activeDrops.dropzones[i];\n    var currentElement = interaction.activeDrops.elements[i];\n\n    // prevent trigger of duplicate events on same element\n    if (currentElement !== prevElement) {\n      // set current element as event target\n      event.target = currentElement;\n      current.fire(event);\n    }\n    prevElement = currentElement;\n  }\n}\n\n// Collect a new set of possible drops and save them in activeDrops.\n// setActiveDrops should always be called when a drag has just started or a\n// drag event happens while dynamicDrop is true\nfunction setActiveDrops(interaction, dragElement) {\n  // get dropzones and their elements that could receive the draggable\n  var possibleDrops = collectDrops(interaction, dragElement, true);\n\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\n  interaction.activeDrops.elements = possibleDrops.elements;\n  interaction.activeDrops.rects = [];\n\n  for (var i = 0; i < interaction.activeDrops.dropzones.length; i++) {\n    interaction.activeDrops.rects[i] = interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\n  }\n}\n\nfunction getDrop(dragEvent, event, dragElement) {\n  var interaction = dragEvent.interaction;\n  var validDrops = [];\n\n  if (dynamicDrop) {\n    setActiveDrops(interaction, dragElement);\n  }\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (var j = 0; j < interaction.activeDrops.dropzones.length; j++) {\n    var current = interaction.activeDrops.dropzones[j];\n    var currentElement = interaction.activeDrops.elements[j];\n    var rect = interaction.activeDrops.rects[j];\n\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect) ? currentElement : null);\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  var dropIndex = utils.indexOfDeepestElement(validDrops);\n\n  return {\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\n    element: interaction.activeDrops.elements[dropIndex] || null\n  };\n}\n\nfunction getDropEvents(interaction, pointerEvent, dragEvent) {\n  var dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null\n  };\n\n  var tmpl = {\n    dragEvent: dragEvent,\n    interaction: interaction,\n    target: interaction.dropElement,\n    dropzone: interaction.dropTarget,\n    relatedTarget: dragEvent.target,\n    draggable: dragEvent.interactable,\n    timeStamp: dragEvent.timeStamp\n  };\n\n  if (interaction.dropElement !== interaction.prevDropElement) {\n    // if there was a prevDropTarget, create a dragleave event\n    if (interaction.prevDropTarget) {\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\n\n      dragEvent.dragLeave = dropEvents.leave.target = interaction.prevDropElement;\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\n    }\n    // if the dropTarget is not null, create a dragenter event\n    if (interaction.dropTarget) {\n      dropEvents.enter = {\n        dragEvent: dragEvent,\n        interaction: interaction,\n        target: interaction.dropElement,\n        dropzone: interaction.dropTarget,\n        relatedTarget: dragEvent.target,\n        draggable: dragEvent.interactable,\n        timeStamp: dragEvent.timeStamp,\n        type: 'dragenter'\n      };\n\n      dragEvent.dragEnter = interaction.dropElement;\n      dragEvent.dropzone = interaction.dropTarget;\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n    dragEvent.relatedTarget = interaction.dropElement;\n  }\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\n\n    dropEvents.activate.target = null;\n    dropEvents.activate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\n\n    dropEvents.deactivate.target = null;\n    dropEvents.deactivate.dropzone = null;\n  }\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\n    dropEvents.move = utils.extend({\n      dragmove: dragEvent,\n      type: 'dropmove'\n    }, tmpl);\n\n    dragEvent.dropzone = interaction.dropTarget;\n  }\n\n  return dropEvents;\n}\n\nfunction fireDropEvents(interaction, dropEvents) {\n  if (dropEvents.leave) {\n    interaction.prevDropTarget.fire(dropEvents.leave);\n  }\n  if (dropEvents.enter) {\n    interaction.dropTarget.fire(dropEvents.enter);\n  }\n  if (dropEvents.drop) {\n    interaction.dropTarget.fire(dropEvents.drop);\n  }\n  if (dropEvents.deactivate) {\n    fireActiveDrops(interaction, dropEvents.deactivate);\n  }\n\n  interaction.prevDropTarget = interaction.dropTarget;\n  interaction.prevDropElement = interaction.dropElement;\n}\n\n/*\\\r\n * Interactable.dropzone\r\n [ method ]\r\n *\r\n * Returns or sets whether elements can be dropped onto this\r\n * Interactable to trigger drop events\r\n *\r\n * Dropzones can receive the following events:\r\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\r\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\r\n *  - `dragmove` when a draggable that has entered the dropzone is moved\r\n *  - `drop` when a draggable is dropped into this dropzone\r\n *\r\n * Use the `accept` option to allow only elements that match the given CSS\r\n * selector or element. The value can be:\r\n *\r\n *  - **an Element** - only that element can be dropped into this dropzone.\r\n *  - **a string**, - the element being dragged must match it as a CSS selector.\r\n *  - **`null`** - accept options is cleared - it accepts any element.\r\n *\r\n * Use the `overlap` option to set how drops are checked for. The allowed\r\n * values are:\r\n *\r\n *   - `'pointer'`, the pointer must be over the dropzone (default)\r\n *   - `'center'`, the draggable element's center must be over the dropzone\r\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\r\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\r\n *   over the dropzone\r\n *\r\n * Use the `checker` option to specify a function to check if a dragged\r\n * element is over this Interactable.\r\n *\r\n | interact(target)\r\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\r\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\r\n |                       dropped,           // bool result of the default checker\r\n |                       dropzone,          // dropzone Interactable\r\n |                       dropElement,       // dropzone elemnt\r\n |                       draggable,         // draggable Interactable\r\n |                       draggableElement) {// draggable element\r\n |\r\n |   return dropped && event.target.hasAttribute('allow-drop');\r\n | }\r\n *\r\n *\r\n - options (boolean | object | null) #optional The new value to be set.\r\n | interact('.drop').dropzone({\r\n |   accept: '.can-drop' || document.getElementById('single-drop'),\r\n |   overlap: 'pointer' || 'center' || zeroToOne\r\n | }\r\n = (boolean | object) The current setting or this Interactable\r\n\\*/\nInteractable.prototype.dropzone = function (options) {\n  if (utils.isObject(options)) {\n    this.options.drop.enabled = options.enabled === false ? false : true;\n\n    if (utils.isFunction(options.ondrop)) {\n      this._iEvents.ondrop = options.ondrop;\n    }\n    if (utils.isFunction(options.ondropactivate)) {\n      this._iEvents.ondropactivate = options.ondropactivate;\n    }\n    if (utils.isFunction(options.ondropdeactivate)) {\n      this._iEvents.ondropdeactivate = options.ondropdeactivate;\n    }\n    if (utils.isFunction(options.ondragenter)) {\n      this._iEvents.ondragenter = options.ondragenter;\n    }\n    if (utils.isFunction(options.ondragleave)) {\n      this._iEvents.ondragleave = options.ondragleave;\n    }\n    if (utils.isFunction(options.ondropmove)) {\n      this._iEvents.ondropmove = options.ondropmove;\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap)) {\n      this.options.drop.overlap = options.overlap;\n    } else if (utils.isNumber(options.overlap)) {\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n    }\n    if ('accept' in options) {\n      this.options.drop.accept = options.accept;\n    }\n    if ('checker' in options) {\n      this.options.drop.checker = options.checker;\n    }\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.drop.enabled = options;\n\n    return this;\n  }\n\n  return this.options.drop;\n};\n\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n  var dropped = false;\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || this.getRect(dropElement))) {\n    return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n  }\n\n  var dropOverlap = this.options.drop.overlap;\n\n  if (dropOverlap === 'pointer') {\n    var origin = utils.getOriginXY(draggable, draggableElement);\n    var page = utils.getPageXY(dragEvent);\n    var horizontal = undefined;\n    var vertical = undefined;\n\n    page.x += origin.x;\n    page.y += origin.y;\n\n    horizontal = page.x > rect.left && page.x < rect.right;\n    vertical = page.y > rect.top && page.y < rect.bottom;\n\n    dropped = horizontal && vertical;\n  }\n\n  var dragRect = draggable.getRect(draggableElement);\n\n  if (dropOverlap === 'center') {\n    var cx = dragRect.left + dragRect.width / 2;\n    var cy = dragRect.top + dragRect.height / 2;\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n  }\n\n  if (utils.isNumber(dropOverlap)) {\n    var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));\n\n    var overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n    dropped = overlapRatio >= dropOverlap;\n  }\n\n  if (this.options.drop.checker) {\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n  }\n\n  return dropped;\n};\n\nInteractable.signals.on('unset', function (_ref7) {\n  var interactable = _ref7.interactable;\n\n  interactable.dropzone(false);\n});\n\nInteractable.settingsMethods.push('dropChecker');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.dropTarget = null; // the dropzone a drag target might be dropped into\n  interaction.dropElement = null; // the element at the time of checking\n  interaction.prevDropTarget = null; // the dropzone that was recently dragged away from\n  interaction.prevDropElement = null; // the element at the time of checking\n  interaction.dropEvents = null; // the dropEvents related to the current drag event\n\n  interaction.activeDrops = {\n    dropzones: [], // the dropzones that are mentioned below\n    elements: [], // elements of dropzones that accept the target draggable\n    rects: [] };\n});\n\n// the rects of the elements mentioned above\nInteraction.signals.on('stop', function (_ref8) {\n  var interaction = _ref8.interaction;\n\n  interaction.dropTarget = interaction.dropElement = interaction.prevDropTarget = interaction.prevDropElement = null;\n});\n\n/*\\\r\n * interact.dynamicDrop\r\n [ method ]\r\n *\r\n * Returns or sets whether the dimensions of dropzone elements are\r\n * calculated on every dragmove or only on dragstart for the default\r\n * dropChecker\r\n *\r\n - newValue (boolean) #optional True to check on each move. False to check only before start\r\n = (boolean | interact) The current setting or interact\r\n\\*/\ninteract.dynamicDrop = function (newValue) {\n  if (utils.isBool(newValue)) {\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\n    //calcRects(dropzones);\n    //}\n\n    dynamicDrop = newValue;\n\n    return interact;\n  }\n  return dynamicDrop;\n};\n\nutils.merge(Interactable.eventTypes, ['dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop']);\nactions.methodDict.drop = 'dropzone';\n\ndefaultOptions.drop = drop.defaults;\n\nmodule.exports = drop;\n\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":17,\"../interact\":20,\"../scope\":28,\"../utils\":38,\"./index\":9}],8:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\nvar gesture = {\n  defaults: {\n    enabled: false,\n    restrict: null\n  },\n\n  checker: function (pointer, event, interactable, element, interaction) {\n    if (interaction.pointerIds.length >= 2) {\n      return { name: 'gesture' };\n    }\n\n    return null;\n  },\n\n  getCursor: function () {\n    return '';\n  }\n};\n\nInteraction.signals.on('action-start', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n\n  if (interaction.prepared.name !== 'gesture') {\n    return;\n  }\n\n  var gestureEvent = new InteractEvent(interaction, event, 'gesture', 'start', interaction.element);\n\n  gestureEvent.ds = 0;\n\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = gestureEvent.distance;\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = gestureEvent.angle;\n  interaction.gesture.scale = 1;\n\n  interaction._interacting = true;\n\n  interaction.target.fire(gestureEvent);\n  interaction.prevEvent = gestureEvent;\n});\n\nInteraction.signals.on('action-move', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  if (interaction.prepared.name !== 'gesture') {\n    return;\n  }\n\n  var gestureEvent = undefined;\n\n  gestureEvent = new InteractEvent(interaction, event, 'gesture', 'move', interaction.element);\n  gestureEvent.ds = gestureEvent.scale - interaction.gesture.scale;\n\n  interaction.target.fire(gestureEvent);\n\n  interaction.gesture.prevAngle = gestureEvent.angle;\n  interaction.gesture.prevDistance = gestureEvent.distance;\n\n  if (gestureEvent.scale !== Infinity && gestureEvent.scale !== null && gestureEvent.scale !== undefined && !isNaN(gestureEvent.scale)) {\n\n    interaction.gesture.scale = gestureEvent.scale;\n  }\n\n  interaction.prevEvent = gestureEvent;\n\n  // if the action was ended in a gesturemove listener\n  if (!interaction.interacting()) {\n    return false;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var event = _ref3.event;\n\n  if (interaction.prepared.name !== 'gesture') {\n    return;\n  }\n\n  var gestureEvent = new InteractEvent(interaction, event, 'gesture', 'end', interaction.element);\n\n  interaction.target.fire(gestureEvent);\n  interaction.prevEvent = gestureEvent;\n});\n\n/*\\\r\n * Interactable.gesturable\r\n [ method ]\r\n *\r\n * Gets or sets whether multitouch gestures can be performed on the\r\n * Interactable's element\r\n *\r\n = (boolean) Indicates if this can be the target of gesture events\r\n   | var isGestureable = interact(element).gesturable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\r\n = (object) this Interactable\r\n | interact(element).gesturable({\r\n |     onstart: function (event) {},\r\n |     onmove : function (event) {},\r\n |     onend  : function (event) {},\r\n |\r\n |     // limit multiple gestures.\r\n |     // See the explanation in @Interactable.draggable example\r\n |     max: Infinity,\r\n |     maxPerElement: 1,\r\n | });\r\n\\*/\nInteractable.prototype.gesturable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.gesture.enabled = options.enabled === false ? false : true;\n    this.setPerAction('gesture', options);\n    this.setOnEvents('gesture', options);\n\n    return this;\n  }\n\n  if (utils.isBool(options)) {\n    this.options.gesture.enabled = options;\n\n    return this;\n  }\n\n  return this.options.gesture;\n};\n\nInteractEvent.signals.on('set-delta', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var iEvent = _ref4.iEvent;\n  var action = _ref4.action;\n  var event = _ref4.event;\n  var starting = _ref4.starting;\n  var ending = _ref4.ending;\n  var deltaSource = _ref4.deltaSource;\n\n  if (action !== 'gesture') {\n    return;\n  }\n\n  var pointers = interaction.pointers;\n\n  iEvent.touches = [pointers[0], pointers[1]];\n\n  if (starting) {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box = utils.touchBBox(pointers);\n    iEvent.scale = 1;\n    iEvent.ds = 0;\n    iEvent.angle = utils.touchAngle(pointers, undefined, deltaSource);\n    iEvent.da = 0;\n  } else if (ending || event instanceof InteractEvent) {\n    iEvent.distance = interaction.prevEvent.distance;\n    iEvent.box = interaction.prevEvent.box;\n    iEvent.scale = interaction.prevEvent.scale;\n    iEvent.ds = iEvent.scale - 1;\n    iEvent.angle = interaction.prevEvent.angle;\n    iEvent.da = iEvent.angle - interaction.gesture.startAngle;\n  } else {\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\n    iEvent.box = utils.touchBBox(pointers);\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance;\n    iEvent.angle = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\n  }\n});\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.gesture = {\n    start: { x: 0, y: 0 },\n\n    startDistance: 0, // distance between two touches of touchStart\n    prevDistance: 0,\n    distance: 0,\n\n    scale: 1, // gesture.distance / gesture.startDistance\n\n    startAngle: 0, // angle of line joining two touches\n    prevAngle: 0 };\n});\n\n// angle of the previous gesture event\nactions.gesture = gesture;\nactions.names.push('gesture');\nutils.merge(Interactable.eventTypes, ['gesturestart', 'gesturemove', 'gestureend']);\nactions.methodDict.gesture = 'gesturable';\n\ndefaultOptions.gesture = gesture.defaults;\n\nmodule.exports = gesture;\n\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":17,\"../utils\":38,\"./index\":9}],9:[function(require,module,exports){\nvar actions = {\n  names: [],\n  methodDict: {}\n};\n\nmodule.exports = actions;\n\n},{}],10:[function(require,module,exports){\nvar actions = require('./index');\nvar utils = require('../utils');\nvar browser = require('../utils/browser');\nvar InteractEvent = require('../InteractEvent');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar defaultOptions = require('../defaultOptions');\n\n// Less Precision with touch input\nvar defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;\n\nvar resize = {\n  defaults: {\n    enabled: false,\n\n    snap: null,\n    restrict: null,\n    inertia: null,\n    autoScroll: null,\n\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none'\n  },\n\n  checker: function (pointer, event, interactable, element, interaction, rect) {\n    if (!rect) {\n      return null;\n    }\n\n    var page = utils.extend({}, interaction.curCoords.page);\n    var options = interactable.options;\n\n    if (options.resize.enabled) {\n      var resizeOptions = options.resize;\n      var resizeEdges = { left: false, right: false, top: false, bottom: false };\n\n      // if using resize.edges\n      if (utils.isObject(resizeOptions.edges)) {\n        for (var edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || defaultMargin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: 'resize',\n            edges: resizeEdges\n          };\n        }\n      } else {\n        var right = options.resize.axis !== 'y' && page.x > rect.right - defaultMargin;\n        var bottom = options.resize.axis !== 'x' && page.y > rect.bottom - defaultMargin;\n\n        if (right || bottom) {\n          return {\n            name: 'resize',\n            axes: (right ? 'x' : '') + (bottom ? 'y' : '')\n          };\n        }\n      }\n    }\n\n    return null;\n  },\n\n  cursors: browser.isIe9OrOlder ? {\n    x: 'e-resize',\n    y: 's-resize',\n    xy: 'se-resize',\n\n    top: 'n-resize',\n    left: 'w-resize',\n    bottom: 's-resize',\n    right: 'e-resize',\n    topleft: 'se-resize',\n    bottomright: 'se-resize',\n    topright: 'ne-resize',\n    bottomleft: 'ne-resize'\n  } : {\n    x: 'ew-resize',\n    y: 'ns-resize',\n    xy: 'nwse-resize',\n\n    top: 'ns-resize',\n    left: 'ew-resize',\n    bottom: 'ns-resize',\n    right: 'ew-resize',\n    topleft: 'nwse-resize',\n    bottomright: 'nwse-resize',\n    topright: 'nesw-resize',\n    bottomleft: 'nesw-resize'\n  },\n\n  getCursor: function (action) {\n    if (action.axis) {\n      return resize.cursors[action.name + action.axis];\n    } else if (action.edges) {\n      var cursorKey = '';\n      var edgeNames = ['top', 'bottom', 'left', 'right'];\n\n      for (var i = 0; i < 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i];\n        }\n      }\n\n      return resize.cursors[cursorKey];\n    }\n  }\n};\n\nInteraction.signals.on('action-start', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n\n  if (interaction.prepared.name !== 'resize') {\n    return;\n  }\n\n  var resizeEvent = new InteractEvent(interaction, event, 'resize', 'start', interaction.element);\n\n  if (interaction.prepared.edges) {\n    var startRect = interaction.target.getRect(interaction.element);\n    var resizeOptions = interaction.target.options.resize;\n\n    /*\r\n     * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\r\n     * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\r\n     * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\r\n     * on the active edges and the edge being interacted with.\r\n     */\n    if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n      var linkedEdges = utils.extend({}, interaction.prepared.edges);\n\n      linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n      linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n      linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n      linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n\n      interaction.prepared._linkedEdges = linkedEdges;\n    } else {\n      interaction.prepared._linkedEdges = null;\n    }\n\n    // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n    if (resizeOptions.preserveAspectRatio) {\n      interaction.resizeStartAspectRatio = startRect.width / startRect.height;\n    }\n\n    interaction.resizeRects = {\n      start: startRect,\n      current: utils.extend({}, startRect),\n      restricted: utils.extend({}, startRect),\n      previous: utils.extend({}, startRect),\n      delta: {\n        left: 0, right: 0, width: 0,\n        top: 0, bottom: 0, height: 0\n      }\n    };\n\n    resizeEvent.rect = interaction.resizeRects.restricted;\n    resizeEvent.deltaRect = interaction.resizeRects.delta;\n  }\n\n  interaction.target.fire(resizeEvent);\n\n  interaction._interacting = true;\n\n  interaction.prevEvent = resizeEvent;\n});\n\nInteraction.signals.on('action-move', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  if (interaction.prepared.name !== 'resize') {\n    return;\n  }\n\n  var resizeEvent = new InteractEvent(interaction, event, 'resize', 'move', interaction.element);\n  var resizeOptions = interaction.target.options.resize;\n  var invert = resizeOptions.invert;\n  var invertible = invert === 'reposition' || invert === 'negate';\n\n  var edges = interaction.prepared.edges;\n\n  if (edges) {\n    var start = interaction.resizeRects.start;\n    var current = interaction.resizeRects.current;\n    var restricted = interaction.resizeRects.restricted;\n    var delta = interaction.resizeRects.delta;\n    var previous = utils.extend(interaction.resizeRects.previous, restricted);\n    var originalEdges = edges;\n\n    var dx = resizeEvent.dx;\n    var dy = resizeEvent.dy;\n\n    if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n      // `resize.preserveAspectRatio` takes precedence over `resize.square`\n      var startAspectRatio = resizeOptions.preserveAspectRatio ? interaction.resizeStartAspectRatio : 1;\n\n      edges = interaction.prepared._linkedEdges;\n\n      if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n        dy = -dx / startAspectRatio;\n      } else if (originalEdges.left || originalEdges.right) {\n        dy = dx / startAspectRatio;\n      } else if (originalEdges.top || originalEdges.bottom) {\n        dx = dy * startAspectRatio;\n      }\n    }\n\n    // update the 'current' rect without modifications\n    if (edges.top) {\n      current.top += dy;\n    }\n    if (edges.bottom) {\n      current.bottom += dy;\n    }\n    if (edges.left) {\n      current.left += dx;\n    }\n    if (edges.right) {\n      current.right += dx;\n    }\n\n    if (invertible) {\n      // if invertible, copy the current rect\n      utils.extend(restricted, current);\n\n      if (invert === 'reposition') {\n        // swap edge values if necessary to keep width/height positive\n        var swap = undefined;\n\n        if (restricted.top > restricted.bottom) {\n          swap = restricted.top;\n\n          restricted.top = restricted.bottom;\n          restricted.bottom = swap;\n        }\n        if (restricted.left > restricted.right) {\n          swap = restricted.left;\n\n          restricted.left = restricted.right;\n          restricted.right = swap;\n        }\n      }\n    } else {\n      // if not invertible, restrict to minimum of 0x0 rect\n      restricted.top = Math.min(current.top, start.bottom);\n      restricted.bottom = Math.max(current.bottom, start.top);\n      restricted.left = Math.min(current.left, start.right);\n      restricted.right = Math.max(current.right, start.left);\n    }\n\n    restricted.width = restricted.right - restricted.left;\n    restricted.height = restricted.bottom - restricted.top;\n\n    for (var edge in restricted) {\n      delta[edge] = restricted[edge] - previous[edge];\n    }\n\n    resizeEvent.edges = interaction.prepared.edges;\n    resizeEvent.rect = restricted;\n    resizeEvent.deltaRect = delta;\n  }\n\n  interaction.target.fire(resizeEvent);\n\n  interaction.prevEvent = resizeEvent;\n\n  // if the action was ended in a resizemove listener\n  if (!interaction.interacting()) {\n    return false;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var event = _ref3.event;\n\n  if (interaction.prepared.name !== 'resize') {\n    return;\n  }\n\n  var resizeEvent = new InteractEvent(interaction, event, 'resize', 'end', interaction.element);\n\n  interaction.target.fire(resizeEvent);\n  interaction.prevEvent = resizeEvent;\n});\n\n/*\\\r\n * Interactable.resizable\r\n [ method ]\r\n *\r\n * Gets or sets whether resize actions can be performed on the\r\n * Interactable\r\n *\r\n = (boolean) Indicates if this can be the target of resize elements\r\n   | var isResizeable = interact('input[type=text]').resizable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\r\n = (object) This Interactable\r\n   | interact(element).resizable({\r\n   |   onstart: function (event) {},\r\n   |   onmove : function (event) {},\r\n   |   onend  : function (event) {},\r\n   |\r\n   |   edges: {\r\n   |     top   : true,       // Use pointer coords to check for resize.\r\n   |     left  : false,      // Disable resizing from left edge.\r\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\r\n   |     right : handleEl    // Resize if pointer target is the given Element\r\n   |   },\r\n   |\r\n   |     // Width and height can be adjusted independently. When `true`, width and\r\n   |     // height are adjusted at a 1:1 ratio.\r\n   |     square: false,\r\n   |\r\n   |     // Width and height can be adjusted independently. When `true`, width and\r\n   |     // height maintain the aspect ratio they had when resizing started.\r\n   |     preserveAspectRatio: false,\r\n   |\r\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\r\n   |   // 'negate' will allow the rect to have negative width/height\r\n   |   // 'reposition' will keep the width/height positive by swapping\r\n   |   // the top and bottom edges and/or swapping the left and right edges\r\n   |   invert: 'none' || 'negate' || 'reposition'\r\n   |\r\n   |   // limit multiple resizes.\r\n   |   // See the explanation in the @Interactable.draggable example\r\n   |   max: Infinity,\r\n   |   maxPerElement: 1,\r\n   | });\r\n  \\*/\nInteractable.prototype.resizable = function (options) {\n  if (utils.isObject(options)) {\n    this.options.resize.enabled = options.enabled === false ? false : true;\n    this.setPerAction('resize', options);\n    this.setOnEvents('resize', options);\n\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\n      this.options.resize.axis = options.axis;\n    } else if (options.axis === null) {\n      this.options.resize.axis = defaultOptions.resize.axis;\n    }\n\n    if (utils.isBool(options.preserveAspectRatio)) {\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n    } else if (utils.isBool(options.square)) {\n      this.options.resize.square = options.square;\n    }\n\n    return this;\n  }\n  if (utils.isBool(options)) {\n    this.options.resize.enabled = options;\n\n    return this;\n  }\n  return this.options.resize;\n};\n\nfunction checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n  // false, '', undefined, null\n  if (!value) {\n    return false;\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    var width = utils.isNumber(rect.width) ? rect.width : rect.right - rect.left;\n    var height = utils.isNumber(rect.height) ? rect.height : rect.bottom - rect.top;\n\n    if (width < 0) {\n      if (name === 'left') {\n        name = 'right';\n      } else if (name === 'right') {\n        name = 'left';\n      }\n    }\n    if (height < 0) {\n      if (name === 'top') {\n        name = 'bottom';\n      } else if (name === 'bottom') {\n        name = 'top';\n      }\n    }\n\n    if (name === 'left') {\n      return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n    }\n    if (name === 'top') {\n      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n    }\n\n    if (name === 'right') {\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n    }\n    if (name === 'bottom') {\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n    }\n  }\n\n  // the remaining checks require an element\n  if (!utils.isElement(element)) {\n    return false;\n  }\n\n  return utils.isElement(value)\n  // the value is an element to use as a resize handle\n  ? value === element\n  // otherwise check if element matches value as selector\n  : utils.matchesUpTo(element, value, interactableElement);\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.resizeAxes = 'xy';\n});\n\nInteractEvent.signals.on('set-delta', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var iEvent = _ref4.iEvent;\n  var action = _ref4.action;\n\n  if (action !== 'resize' || !interaction.resizeAxes) {\n    return;\n  }\n\n  var options = interaction.target.options;\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      iEvent.dx = iEvent.dy;\n    } else {\n      iEvent.dy = iEvent.dx;\n    }\n    iEvent.axes = 'xy';\n  } else {\n    iEvent.axes = interaction.resizeAxes;\n\n    if (interaction.resizeAxes === 'x') {\n      iEvent.dy = 0;\n    } else if (interaction.resizeAxes === 'y') {\n      iEvent.dx = 0;\n    }\n  }\n});\n\nactions.resize = resize;\nactions.names.push('resize');\nutils.merge(Interactable.eventTypes, ['resizestart', 'resizemove', 'resizeinertiastart', 'resizeinertiaresume', 'resizeend']);\nactions.methodDict.resize = 'resizable';\n\ndefaultOptions.resize = resize.defaults;\n\nmodule.exports = resize;\n\n},{\"../InteractEvent\":3,\"../Interactable\":4,\"../Interaction\":5,\"../defaultOptions\":17,\"../utils\":38,\"../utils/browser\":31,\"./index\":9}],11:[function(require,module,exports){\nvar raf = require('./utils/raf');\nvar getWindow = require('./utils/window').getWindow;\nvar isWindow = require('./utils/isType').isWindow;\nvar domUtils = require('./utils/domUtils');\nvar Interaction = require('./Interaction');\nvar defaultOptions = require('./defaultOptions');\n\nvar autoScroll = {\n  defaults: {\n    enabled: false,\n    container: null, // the item that is scrolled (Window or HTMLElement)\n    margin: 60,\n    speed: 300 },\n\n  // the scroll speed in pixels per second\n  interaction: null,\n  i: null, // the handle returned by window.setInterval\n  x: 0, y: 0, // Direction each pulse is to scroll in\n\n  isScrolling: false,\n  prevTime: 0,\n\n  start: function (interaction) {\n    autoScroll.isScrolling = true;\n    raf.cancel(autoScroll.i);\n\n    autoScroll.interaction = interaction;\n    autoScroll.prevTime = new Date().getTime();\n    autoScroll.i = raf.request(autoScroll.scroll);\n  },\n\n  stop: function () {\n    autoScroll.isScrolling = false;\n    raf.cancel(autoScroll.i);\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll: function () {\n    var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\n    var container = options.container || getWindow(autoScroll.interaction.element);\n    var now = new Date().getTime();\n    // change in time in seconds\n    var dt = (now - autoScroll.prevTime) / 1000;\n    // displacement\n    var s = options.speed * dt;\n\n    if (s >= 1) {\n      if (isWindow(container)) {\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\n      } else if (container) {\n        container.scrollLeft += autoScroll.x * s;\n        container.scrollTop += autoScroll.y * s;\n      }\n\n      autoScroll.prevTime = now;\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i);\n      autoScroll.i = raf.request(autoScroll.scroll);\n    }\n  },\n  check: function (interactable, actionName) {\n    var options = interactable.options;\n\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\n  },\n  onInteractionMove: function (_ref) {\n    var interaction = _ref.interaction;\n    var pointer = _ref.pointer;\n\n    if (!(interaction.interacting() && autoScroll.check(interaction.target, interaction.prepared.name))) {\n      return;\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0;\n      return;\n    }\n\n    var top = undefined;\n    var right = undefined;\n    var bottom = undefined;\n    var left = undefined;\n\n    var options = interaction.target.options[interaction.prepared.name].autoScroll;\n    var container = options.container || getWindow(interaction.element);\n\n    if (isWindow(container)) {\n      left = pointer.clientX < autoScroll.margin;\n      top = pointer.clientY < autoScroll.margin;\n      right = pointer.clientX > container.innerWidth - autoScroll.margin;\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n    } else {\n      var rect = domUtils.getElementClientRect(container);\n\n      left = pointer.clientX < rect.left + autoScroll.margin;\n      top = pointer.clientY < rect.top + autoScroll.margin;\n      right = pointer.clientX > rect.right - autoScroll.margin;\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0;\n    autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin;\n      autoScroll.speed = options.speed;\n\n      autoScroll.start(interaction);\n    }\n  }\n};\n\nInteraction.signals.on('stop-active', function () {\n  autoScroll.stop();\n});\n\nInteraction.signals.on('action-move', autoScroll.onInteractionMove);\n\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\n\nmodule.exports = autoScroll;\n\n},{\"./Interaction\":5,\"./defaultOptions\":17,\"./utils/domUtils\":33,\"./utils/isType\":40,\"./utils/raf\":44,\"./utils/window\":45}],12:[function(require,module,exports){\nvar autoStart = require('./index');\nvar Interaction = require('../Interaction');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.delayTimer = null;\n});\n\nautoStart.signals.on('prepared', function (_ref) {\n  var interaction = _ref.interaction;\n\n  var actionName = interaction.prepared.name;\n\n  if (!actionName) {\n    return;\n  }\n\n  var delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.delayTimer = setTimeout(function () {\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\n    }, delay);\n  }\n});\n\nInteraction.signals.on('move', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var duplicate = _ref2.duplicate;\n\n  if (interaction.pointerWasMoved && !duplicate) {\n    clearTimeout(interaction.delayTimer);\n  }\n});\n\n// prevent regular down->move autoStart\nautoStart.signals.on('before-start', function (_ref3) {\n  var interaction = _ref3.interaction;\n\n  var actionName = interaction.prepared.name;\n\n  if (!actionName) {\n    return;\n  }\n\n  var delay = interaction.target.options[actionName].delay;\n\n  if (delay > 0) {\n    interaction.prepared.name = null;\n  }\n});\n\n},{\"../Interaction\":5,\"./index\":15}],13:[function(require,module,exports){\nvar autoStart = require('./index');\nvar scope = require('../scope');\nvar browser = require('../utils/browser');\n\nvar _require = require('../utils/isType');\n\nvar isElement = _require.isElement;\n\nvar _require2 = require('../utils/domUtils');\n\nvar matchesSelector = _require2.matchesSelector;\nvar parentNode = _require2.parentNode;\n\nrequire('./index').setActionDefaults(require('../actions/drag'));\n\nautoStart.signals.on('before-start', function (_ref) {\n  var interaction = _ref.interaction;\n  var eventTarget = _ref.eventTarget;\n  var dx = _ref.dx;\n  var dy = _ref.dy;\n\n  if (interaction.prepared.name !== 'drag') {\n    return;\n  }\n\n  // check if a drag is in the correct axis\n  var absX = Math.abs(dx);\n  var absY = Math.abs(dy);\n  var dragOptions = interaction.target.options.drag;\n  var startAxis = dragOptions.startAxis;\n  var currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n\n  interaction.prepared.axis = dragOptions.lockAxis === 'start' ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\n  : dragOptions.lockAxis;\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    interaction.prepared.name = null;\n\n    // then try to get a drag from another ineractable\n\n    if (!interaction.prepared.name) {\n      (function () {\n\n        var element = eventTarget;\n\n        var getDraggable = function (interactable, selector, context) {\n          var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n          if (interactable === interaction.target) {\n            return;\n          }\n\n          var action = null;\n\n          if (interactable.inContext(eventTarget) && !interactable.options.drag.manualStart && !autoStart.testIgnore(interactable, element, eventTarget) && autoStart.testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, elements)) {\n\n            action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n          }\n          if (action && action.name === 'drag' && checkStartAxis(currentAxis, interactable) && autoStart.withinInteractionLimit(interactable, element, { name: 'drag' })) {\n\n            return interactable;\n          }\n        };\n\n        var action = null;\n\n        // check all interactables\n        while (isElement(element)) {\n          var elementInteractable = scope.interactables.get(element);\n\n          if (elementInteractable && elementInteractable !== interaction.target && !elementInteractable.options.drag.manualStart) {\n\n            action = elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\n          }\n          if (action && action.name === 'drag' && checkStartAxis(currentAxis, elementInteractable)) {\n\n            interaction.prepared.name = 'drag';\n            interaction.target = elementInteractable;\n            interaction.element = element;\n            break;\n          }\n\n          var selectorInteractable = scope.interactables.forEachSelector(getDraggable);\n\n          if (selectorInteractable) {\n            interaction.prepared.name = 'drag';\n            interaction.target = selectorInteractable;\n            interaction.element = element;\n            break;\n          }\n\n          element = parentNode(element);\n        }\n      })();\n    }\n  }\n});\n\nfunction checkStartAxis(startAxis, interactable) {\n  if (!interactable) {\n    return false;\n  }\n\n  var thisAxis = interactable.options.drag.startAxis;\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis;\n}\n\n},{\"../actions/drag\":6,\"../scope\":28,\"../utils/browser\":31,\"../utils/domUtils\":33,\"../utils/isType\":40,\"./index\":15}],14:[function(require,module,exports){\nrequire('./index').setActionDefaults(require('../actions/gesture'));\n\n},{\"../actions/gesture\":8,\"./index\":15}],15:[function(require,module,exports){\nvar interact = require('../interact');\nvar Interactable = require('../Interactable');\nvar Interaction = require('../Interaction');\nvar actions = require('../actions');\nvar defaultOptions = require('../defaultOptions');\nvar browser = require('../utils/browser');\nvar scope = require('../scope');\nvar utils = require('../utils');\nvar signals = require('../utils/Signals')['new']();\n\nvar autoStart = {\n  signals: signals,\n  testIgnore: testIgnore,\n  testAllow: testAllow,\n  withinInteractionLimit: withinInteractionLimit,\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: Infinity,\n  perActionDefaults: {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1\n  },\n  setActionDefaults: function (action) {\n    utils.extend(action.defaults, autoStart.perActionDefaults);\n  }\n};\n\nfunction testIgnore(interactable, interactableElement, element) {\n  var ignoreFrom = interactable.options.ignoreFrom;\n\n  if (!ignoreFrom || !utils.isElement(element)) {\n    return false;\n  }\n\n  if (utils.isString(ignoreFrom)) {\n    return utils.matchesUpTo(element, ignoreFrom, interactableElement);\n  } else if (utils.isElement(ignoreFrom)) {\n    return utils.nodeContains(ignoreFrom, element);\n  }\n\n  return false;\n}\n\nfunction testAllow(interactable, interactableElement, element) {\n  var allowFrom = interactable.options.allowFrom;\n\n  if (!allowFrom) {\n    return true;\n  }\n\n  if (!utils.isElement(element)) {\n    return false;\n  }\n\n  if (utils.isString(allowFrom)) {\n    return utils.matchesUpTo(element, allowFrom, interactableElement);\n  } else if (utils.isElement(allowFrom)) {\n    return utils.nodeContains(allowFrom, element);\n  }\n\n  return false;\n}\n\n// set cursor style on mousedown\nInteraction.signals.on('down', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var pointer = _ref2.pointer;\n  var event = _ref2.event;\n  var eventTarget = _ref2.eventTarget;\n\n  if (interaction.interacting()) {\n    return;\n  }\n\n  var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\n// set cursor style on mousemove\nInteraction.signals.on('move', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var pointer = _ref3.pointer;\n  var event = _ref3.event;\n  var eventTarget = _ref3.eventTarget;\n\n  if (!interaction.mouse || interaction.pointerIsDown) {\n    return;\n  }\n\n  var actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\n  prepare(interaction, actionInfo);\n});\n\nInteraction.signals.on('move', function (arg) {\n  var interaction = arg.interaction;\n  var event = arg.event;\n\n  if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {\n    return;\n  }\n\n  signals.fire('before-start', arg);\n\n  var target = interaction.target;\n\n  if (interaction.prepared.name && target) {\n    // check manualStart and interaction limit\n    if (target.options[interaction.prepared.name].manualStart || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\n      interaction.stop(event);\n    } else {\n      interaction.start(interaction.prepared, target, interaction.element);\n    }\n  }\n});\n\n// Check if the current target supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction(action, interactable) {\n  if (utils.isObject(action) && interactable.options[action.name].enabled) {\n    return action;\n  }\n\n  return null;\n}\n\nfunction validateSelector(interaction, pointer, event, matches, matchElements) {\n  for (var i = 0, len = matches.length; i < len; i++) {\n    var match = matches[i];\n    var matchElement = matchElements[i];\n    var action = validateAction(match.getAction(pointer, event, interaction, matchElement), match);\n\n    if (action && withinInteractionLimit(match, matchElement, action)) {\n      return {\n        action: action,\n        target: match,\n        element: matchElement\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getActionInfo(interaction, pointer, event, eventTarget) {\n  var matches = [];\n  var matchElements = [];\n\n  var element = eventTarget;\n  var action = null;\n\n  function pushMatches(interactable, selector, context) {\n    var elements = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n    if (interactable.inContext(element) && !module.exports.testIgnore(interactable, element, eventTarget) && module.exports.testAllow(interactable, element, eventTarget) && utils.matchesSelector(element, selector, elements)) {\n\n      matches.push(interactable);\n      matchElements.push(element);\n    }\n  }\n\n  while (utils.isElement(element)) {\n    matches = [];\n    matchElements = [];\n\n    var elementInteractable = scope.interactables.get(element);\n\n    if (elementInteractable && (action = validateAction(elementInteractable.getAction(pointer, event, interaction, element), elementInteractable)) && !elementInteractable.options[action.name].manualStart) {\n      return {\n        element: element,\n        action: action,\n        target: elementInteractable\n      };\n    } else {\n      scope.interactables.forEachSelector(pushMatches);\n\n      var actionInfo = validateSelector(interaction, pointer, event, matches, matchElements);\n\n      if (actionInfo.action && !actionInfo.target.options[actionInfo.action.name].manualStart) {\n        return actionInfo;\n      }\n    }\n\n    element = utils.parentNode(element);\n  }\n\n  return {};\n}\n\nfunction prepare(interaction, _ref4) {\n  var action = _ref4.action;\n  var target = _ref4.target;\n  var element = _ref4.element;\n\n  action = action || {};\n\n  if (interaction.target && interaction.target.options.styleCursor) {\n    var cursorTarget = interaction.target.options.cursorTarget || interaction.target._doc.documentElement;\n    cursorTarget.style.cursor = '';\n  }\n\n  interaction.target = target;\n  interaction.element = element;\n  utils.copyAction(interaction.prepared, action);\n\n  if (target && target.options.styleCursor) {\n    var cursor = action ? actions[action.name].getCursor(action) : '';\n    var cursorTarget = interaction.target.options.cursorTarget || interaction.target._doc.documentElement;\n    cursorTarget.style.cursor = cursor;\n  }\n\n  signals.fire('prepared', { interaction: interaction });\n}\n\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\n  var action = this.defaultActionChecker(pointer, event, interaction, element);\n\n  if (this.options.actionChecker) {\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\n  }\n\n  return action;\n};\n\n/*\\\r\n * Interactable.actionChecker\r\n [ method ]\r\n *\r\n * Gets or sets the function used to check action to be performed on\r\n * pointerDown\r\n *\r\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\r\n = (Function | Interactable) The checker function or this Interactable\r\n *\r\n | interact('.resize-drag')\r\n |   .resizable(true)\r\n |   .draggable(true)\r\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\r\n |\r\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\r\n |     // force drag with handle target\r\n |     action.name = drag;\r\n |   }\r\n |   else {\r\n |     // resize from the top and right edges\r\n |     action.name  = 'resize';\r\n |     action.edges = { top: true, right: true };\r\n |   }\r\n |\r\n |   return action;\r\n | });\r\n\\*/\nInteractable.prototype.actionChecker = function (checker) {\n  if (utils.isFunction(checker)) {\n    this.options.actionChecker = checker;\n\n    return this;\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker;\n\n    return this;\n  }\n\n  return this.options.actionChecker;\n};\n\n/*\\\r\n * Interactable.styleCursor\r\n [ method ]\r\n *\r\n * Returns or sets whether the the cursor should be changed depending on the\r\n * action that would be performed if the mouse were pressed and dragged.\r\n *\r\n - newValue (boolean) #optional\r\n = (boolean | Interactable) The current setting or this Interactable\r\n\\*/\nInteractable.prototype.styleCursor = function (newValue) {\n  if (utils.isBool(newValue)) {\n    this.options.styleCursor = newValue;\n\n    return this;\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor;\n\n    return this;\n  }\n\n  return this.options.styleCursor;\n};\n\n/*\\\r\n * Interactable.ignoreFrom\r\n [ method ]\r\n *\r\n * If the target of the `mousedown`, `pointerdown` or `touchstart`\r\n * event or any of it's parents match the given CSS selector or\r\n * Element, no drag/resize/gesture is started.\r\n *\r\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\r\n = (string | Element | object) The current ignoreFrom value or this Interactable\r\n **\r\n | interact(element, { ignoreFrom: document.getElementById('no-action') });\r\n | // or\r\n | interact(element).ignoreFrom('input, textarea, a');\r\n\\*/\nInteractable.prototype.ignoreFrom = function (newValue) {\n  if (utils.trySelector(newValue)) {\n    // CSS selector to match event.target\n    this.options.ignoreFrom = newValue;\n    return this;\n  }\n\n  if (utils.isElement(newValue)) {\n    // specific element\n    this.options.ignoreFrom = newValue;\n    return this;\n  }\n\n  return this.options.ignoreFrom;\n};\n\n/*\\\r\n * Interactable.allowFrom\r\n [ method ]\r\n *\r\n * A drag/resize/gesture is started only If the target of the\r\n * `mousedown`, `pointerdown` or `touchstart` event or any of it's\r\n * parents match the given CSS selector or Element.\r\n *\r\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\r\n = (string | Element | object) The current allowFrom value or this Interactable\r\n **\r\n | interact(element, { allowFrom: document.getElementById('drag-handle') });\r\n | // or\r\n | interact(element).allowFrom('.handle');\r\n\\*/\nInteractable.prototype.allowFrom = function (newValue) {\n  if (utils.trySelector(newValue)) {\n    // CSS selector to match event.target\n    this.options.allowFrom = newValue;\n    return this;\n  }\n\n  if (utils.isElement(newValue)) {\n    // specific element\n    this.options.allowFrom = newValue;\n    return this;\n  }\n\n  return this.options.allowFrom;\n};\n\nInteraction.signals.on('stop', function (_ref5) {\n  var interaction = _ref5.interaction;\n\n  var target = interaction.target;\n\n  if (target && target.options.styleCursor) {\n    var cursorTarget = target.options.cursorTarget || target._doc.documentElement;\n    cursorTarget.style.cursor = '';\n  }\n});\n\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\n  var rect = this.getRect(element);\n  var action = null;\n\n  for (var _iterator = actions.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var actionName = _ref;\n\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\n\n    if (action) {\n      return action;\n    }\n  }\n};\n\nfunction withinInteractionLimit(interactable, element, action) {\n  var options = interactable.options;\n  var maxActions = options[action.name].max;\n  var maxPerElement = options[action.name].maxPerElement;\n  var activeInteractions = 0;\n  var targetCount = 0;\n  var targetElementCount = 0;\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStart.maxInteractions)) {\n    return;\n  }\n\n  for (var i = 0, len = scope.interactions.length; i < len; i++) {\n    var interaction = scope.interactions[i];\n    var otherAction = interaction.prepared.name;\n\n    if (!interaction.interacting()) {\n      continue;\n    }\n\n    activeInteractions++;\n\n    if (activeInteractions >= autoStart.maxInteractions) {\n      return false;\n    }\n\n    if (interaction.target !== interactable) {\n      continue;\n    }\n\n    targetCount += otherAction === action.name | 0;\n\n    if (targetCount >= maxActions) {\n      return false;\n    }\n\n    if (interaction.element === element) {\n      targetElementCount++;\n\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n        return false;\n      }\n    }\n  }\n\n  return autoStart.maxInteractions > 0;\n}\n\n/*\\\r\n * interact.maxInteractions\r\n [ method ]\r\n **\r\n * Returns or sets the maximum number of concurrent interactions allowed.\r\n * By default only 1 interaction is allowed at a time (for backwards\r\n * compatibility). To allow multiple interactions on the same Interactables\r\n * and elements, you need to enable it in the draggable, resizable and\r\n * gesturable `'max'` and `'maxPerElement'` options.\r\n **\r\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\r\n\\*/\ninteract.maxInteractions = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    autoStart.maxInteractions = newValue;\n\n    return this;\n  }\n\n  return autoStart.maxInteractions;\n};\n\nInteractable.settingsMethods.push('styleCursor');\nInteractable.settingsMethods.push('actionChecker');\nInteractable.settingsMethods.push('ignoreFrom');\nInteractable.settingsMethods.push('allowFrom');\n\ndefaultOptions.base.actionChecker = null;\ndefaultOptions.base.ignoreFrom = null;\ndefaultOptions.base.allowFrom = null;\ndefaultOptions.base.styleCursor = true;\n\nutils.extend(defaultOptions.perAction, autoStart.perActionDefaults);\n\nmodule.exports = autoStart;\n\n},{\"../Interactable\":4,\"../Interaction\":5,\"../actions\":9,\"../defaultOptions\":17,\"../interact\":20,\"../scope\":28,\"../utils\":38,\"../utils/Signals\":29,\"../utils/browser\":31}],16:[function(require,module,exports){\nrequire('./index').setActionDefaults(require('../actions/resize'));\n\n},{\"../actions/resize\":10,\"./index\":15}],17:[function(require,module,exports){\nmodule.exports = {\n  base: {\n    accept: null,\n    preventDefault: 'auto',\n    origin: { x: 0, y: 0 },\n    deltaSource: 'page',\n    allowFrom: null\n  },\n\n  perAction: {\n    inertia: {\n      enabled: false,\n      resistance: 10, // the lambda in exponential decay\n      minSpeed: 100, // target speed must be above this for inertia to start\n      endSpeed: 10, // the speed at which inertia is slow enough to stop\n      allowResume: true, // allow resuming an action in inertia phase\n      smoothEndDuration: 300 }\n  },\n\n  // animate to snap/restrict endOnly if there's no inertia\n  _holdDuration: 600\n};\n\n},{}],18:[function(require,module,exports){\n/* browser entry point */\n\n// Legacy browser support\nrequire('./legacyBrowsers');\n\n// pointerEvents\nrequire('./pointerEvents');\nrequire('./pointerEvents/interactableTargets');\n\n// inertia\nrequire('./inertia');\n\n// modifiers\nrequire('./modifiers/snap');\nrequire('./modifiers/restrict');\n\n// delay\nrequire('./autoStart/delay');\n\n// actions\nrequire('./autoStart/gesture');\nrequire('./autoStart/resize');\nrequire('./autoStart/drag');\n\nrequire('./actions/drop');\n\n// Interactable preventDefault setting\nrequire('./interactablePreventDefault.js');\n\n// autoScroll\nrequire('./autoScroll');\n\n// export interact\nmodule.exports = require('./interact');\n\n},{\"./actions/drop\":7,\"./autoScroll\":11,\"./autoStart/delay\":12,\"./autoStart/drag\":13,\"./autoStart/gesture\":14,\"./autoStart/resize\":16,\"./inertia\":19,\"./interact\":20,\"./interactablePreventDefault.js\":21,\"./legacyBrowsers\":22,\"./modifiers/restrict\":24,\"./modifiers/snap\":25,\"./pointerEvents\":26,\"./pointerEvents/interactableTargets\":27}],19:[function(require,module,exports){\nvar InteractEvent = require('./InteractEvent');\nvar Interaction = require('./Interaction');\nvar modifiers = require('./modifiers');\nvar utils = require('./utils');\nvar animationFrame = require('./utils/raf');\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.inertiaStatus = {\n    active: false,\n    smoothEnd: false,\n    allowResume: false,\n\n    startEvent: null,\n    upCoords: {},\n\n    xe: 0, ye: 0,\n    sx: 0, sy: 0,\n\n    t0: 0,\n    vx0: 0, vys: 0,\n    duration: 0,\n\n    lambda_v0: 0,\n    one_ve_v0: 0,\n    i: null\n  };\n\n  interaction.boundInertiaFrame = function () {\n    return inertiaFrame.apply(interaction);\n  };\n  interaction.boundSmoothEndFrame = function () {\n    return smoothEndFrame.apply(interaction);\n  };\n});\n\nInteraction.signals.on('down', function (_ref) {\n  var interaction = _ref.interaction;\n  var event = _ref.event;\n  var pointer = _ref.pointer;\n  var eventTarget = _ref.eventTarget;\n\n  var status = interaction.inertiaStatus;\n\n  // Check if the down event hits the current inertia target\n  if (status.active) {\n    var element = eventTarget;\n\n    // climb up the DOM tree from the event target\n    while (utils.isElement(element)) {\n\n      // if interaction element is the current inertia target element\n      if (element === interaction.element) {\n        // stop inertia\n        animationFrame.cancel(status.i);\n        status.active = false;\n        interaction.simulation = null;\n\n        // update pointers to the down event's coordinates\n        interaction.updatePointer(pointer);\n        utils.setCoords(interaction.curCoords, interaction.pointers);\n\n        // fire appropriate signals\n        var signalArg = { interaction: interaction };\n        Interaction.signals.fire('before-action-move', signalArg);\n        Interaction.signals.fire('action-resume', signalArg);\n\n        // fire a reume event\n        var resumeEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiaresume', interaction.element);\n\n        interaction.target.fire(resumeEvent);\n        interaction.prevEvent = resumeEvent;\n        modifiers.resetStatuses(interaction.modifierStatuses);\n\n        utils.copyCoords(interaction.prevCoords, interaction.curCoords);\n        break;\n      }\n\n      element = utils.parentNode(element);\n    }\n  }\n});\n\nInteraction.signals.on('up', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  var status = interaction.inertiaStatus;\n\n  if (!interaction.interacting() || status.active) {\n    return;\n  }\n\n  var target = interaction.target;\n  var options = target && target.options;\n  var inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\n\n  var now = new Date().getTime();\n  var statuses = {};\n  var page = utils.extend({}, interaction.curCoords.page);\n  var pointerSpeed = interaction.pointerDelta.client.speed;\n  var inertiaPossible = false;\n  var inertia = false;\n  var smoothEnd = false;\n  var modifierResult = undefined;\n\n  // check if inertia should be started\n  inertiaPossible = inertiaOptions && inertiaOptions.enabled && interaction.prepared.name !== 'gesture' && event !== status.startEvent;\n\n  inertia = inertiaPossible && now - interaction.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n\n  // smoothEnd\n  if (inertiaPossible && !inertia) {\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(interaction, page, statuses, true, true);\n\n    if (modifierResult.shouldMove && modifierResult.locked) {\n      smoothEnd = true;\n    }\n  }\n\n  if (!(inertia || smoothEnd)) {\n    return;\n  }\n\n  utils.copyCoords(status.upCoords, interaction.curCoords);\n\n  interaction.pointers[0] = status.startEvent = new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\n\n  status.t0 = now;\n\n  status.active = true;\n  status.allowResume = inertiaOptions.allowResume;\n  interaction.simulation = status;\n\n  target.fire(status.startEvent);\n\n  if (inertia) {\n    status.vx0 = interaction.pointerDelta.client.vx;\n    status.vy0 = interaction.pointerDelta.client.vy;\n    status.v0 = pointerSpeed;\n\n    calcInertia(interaction, status);\n\n    utils.extend(page, interaction.curCoords.page);\n\n    page.x += status.xe;\n    page.y += status.ye;\n\n    modifiers.resetStatuses(statuses);\n\n    modifierResult = modifiers.setAll(interaction, page, statuses, true, true);\n\n    status.modifiedXe += modifierResult.dx;\n    status.modifiedYe += modifierResult.dy;\n\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\n  } else {\n    status.smoothEnd = true;\n    status.xe = modifierResult.dx;\n    status.ye = modifierResult.dy;\n\n    status.sx = status.sy = 0;\n\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\n  }\n});\n\nInteraction.signals.on('stop-active', function (_ref3) {\n  var interaction = _ref3.interaction;\n\n  var status = interaction.inertiaStatus;\n\n  if (status.active) {\n    animationFrame.cancel(status.i);\n    status.active = false;\n    interaction.simulation = null;\n  }\n});\n\nfunction calcInertia(interaction, status) {\n  var inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\n  var lambda = inertiaOptions.resistance;\n  var inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n  status.x0 = interaction.prevEvent.pageX;\n  status.y0 = interaction.prevEvent.pageY;\n  status.t0 = status.startEvent.timeStamp / 1000;\n  status.sx = status.sy = 0;\n\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n  status.te = inertiaDur;\n\n  status.lambda_v0 = lambda / status.v0;\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n}\n\nfunction inertiaFrame() {\n  updateInertiaCoords(this);\n  utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n  var status = this.inertiaStatus;\n  var options = this.target.options[this.prepared.name].inertia;\n  var lambda = options.resistance;\n  var t = new Date().getTime() / 1000 - status.t0;\n\n  if (t < status.te) {\n\n    var progress = 1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\n\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\n      status.sx = status.xe * progress;\n      status.sy = status.ye * progress;\n    } else {\n      var quadPoint = utils.getQuadraticCurvePoint(0, 0, status.xe, status.ye, status.modifiedXe, status.modifiedYe, progress);\n\n      status.sx = quadPoint.x;\n      status.sy = quadPoint.y;\n    }\n\n    this.doMove();\n\n    status.i = animationFrame.request(this.boundInertiaFrame);\n  } else {\n    status.sx = status.modifiedXe;\n    status.sy = status.modifiedYe;\n\n    this.doMove();\n    this.end(status.startEvent);\n    status.active = false;\n    this.simulation = null;\n  }\n\n  utils.copyCoords(this.prevCoords, this.curCoords);\n}\n\nfunction smoothEndFrame() {\n  updateInertiaCoords(this);\n\n  var status = this.inertiaStatus;\n  var t = new Date().getTime() - status.t0;\n  var duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n  if (t < duration) {\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\n\n    this.pointerMove(status.startEvent, status.startEvent);\n\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\n  } else {\n    status.sx = status.xe;\n    status.sy = status.ye;\n\n    this.pointerMove(status.startEvent, status.startEvent);\n    this.end(status.startEvent);\n\n    status.smoothEnd = status.active = false;\n    this.simulation = null;\n  }\n}\n\nfunction updateInertiaCoords(interaction) {\n  var status = interaction.inertiaStatus;\n\n  // return if inertia isn't running\n  if (!status.active) {\n    return;\n  }\n\n  var pageUp = status.upCoords.page;\n  var clientUp = status.upCoords.client;\n\n  utils.setCoords(interaction.curCoords, [{\n    pageX: pageUp.x + status.sx,\n    pageY: pageUp.y + status.sy,\n    clientX: clientUp.x + status.sx,\n    clientY: clientUp.y + status.sy\n  }]);\n}\n\n},{\"./InteractEvent\":3,\"./Interaction\":5,\"./modifiers\":23,\"./utils\":38,\"./utils/raf\":44}],20:[function(require,module,exports){\nvar browser = require('./utils/browser');\nvar events = require('./utils/events');\nvar utils = require('./utils');\nvar scope = require('./scope');\nvar Interactable = require('./Interactable');\nvar Interaction = require('./Interaction');\n\nvar globalEvents = {};\n\n/*\\\r\n * interact\r\n [ method ]\r\n *\r\n * The methods of this variable can be used to set elements as\r\n * interactables and also to change various default settings.\r\n *\r\n * Calling it as a function and passing an element or a valid CSS selector\r\n * string returns an Interactable object which has various methods to\r\n * configure it.\r\n *\r\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\r\n = (object) An @Interactable\r\n *\r\n > Usage\r\n | interact('#draggable').draggable(true);\r\n |\r\n | var rectables = interact('rect');\r\n | rectables\r\n |     .gesturable(true)\r\n |     .on('gesturemove', function (event) {\r\n |         // ...\r\n |     });\r\n\\*/\nfunction interact(element, options) {\n  var interactable = scope.interactables.get(element, options);\n\n  if (!interactable) {\n    interactable = new Interactable(element, options);\n    interactable._iEvents.global = globalEvents;\n  }\n\n  return interactable;\n}\n\n/*\\\r\n * interact.isSet\r\n [ method ]\r\n *\r\n * Check if an element has been set\r\n - element (Element) The Element being searched for\r\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\r\n\\*/\ninteract.isSet = function (element, options) {\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\n};\n\n/*\\\r\n * interact.on\r\n [ method ]\r\n *\r\n * Adds a global listener for an InteractEvent or adds a DOM event to\r\n * `document`\r\n *\r\n - type       (string | array | object) The types of events to listen for\r\n - listener   (function) The function event (s)\r\n - useCapture (boolean) #optional useCapture flag for addEventListener\r\n = (object) interact\r\n\\*/\ninteract.on = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (var _iterator = type, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var eventType = _ref;\n\n      interact.on(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (var prop in type) {\n      interact.on(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.contains(Interactable.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!globalEvents[type]) {\n      globalEvents[type] = [listener];\n    } else {\n      globalEvents[type].push(listener);\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n      events.add(scope.document, type, listener, useCapture);\n    }\n\n  return interact;\n};\n\n/*\\\r\n * interact.off\r\n [ method ]\r\n *\r\n * Removes a global InteractEvent listener or DOM event from `document`\r\n *\r\n - type       (string | array | object) The types of events that were listened for\r\n - listener   (function) The listener function to be removed\r\n - useCapture (boolean) #optional useCapture flag for removeEventListener\r\n = (object) interact\r\n \\*/\ninteract.off = function (type, listener, useCapture) {\n  if (utils.isString(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/);\n  }\n\n  if (utils.isArray(type)) {\n    for (var _iterator2 = type, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var eventType = _ref2;\n\n      interact.off(eventType, listener, useCapture);\n    }\n\n    return interact;\n  }\n\n  if (utils.isObject(type)) {\n    for (var prop in type) {\n      interact.off(prop, type[prop], listener);\n    }\n\n    return interact;\n  }\n\n  if (!utils.contains(Interactable.eventTypes, type)) {\n    events.remove(scope.document, type, listener, useCapture);\n  } else {\n    var index = undefined;\n\n    if (type in globalEvents && (index = utils.indexOf(globalEvents[type], listener)) !== -1) {\n      globalEvents[type].splice(index, 1);\n    }\n  }\n\n  return interact;\n};\n\n/*\\\r\n * interact.debug\r\n [ method ]\r\n *\r\n * Returns an object which exposes internal data\r\n = (object) An object with properties that outline the current state and expose internal functions and variables\r\n\\*/\ninteract.debug = function () {\n  return scope;\n};\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage = utils.pointerAverage;\ninteract.getTouchBBox = utils.touchBBox;\ninteract.getTouchDistance = utils.touchDistance;\ninteract.getTouchAngle = utils.touchAngle;\n\ninteract.getElementRect = utils.getElementRect;\ninteract.getElementClientRect = utils.getElementClientRect;\ninteract.matchesSelector = utils.matchesSelector;\ninteract.closest = utils.closest;\n\n/*\\\r\n * interact.supportsTouch\r\n [ method ]\r\n *\r\n = (boolean) Whether or not the browser supports touch input\r\n\\*/\ninteract.supportsTouch = function () {\n  return browser.supportsTouch;\n};\n\n/*\\\r\n * interact.supportsPointerEvent\r\n [ method ]\r\n *\r\n = (boolean) Whether or not the browser supports PointerEvents\r\n\\*/\ninteract.supportsPointerEvent = function () {\n  return browser.supportsPointerEvent;\n};\n\n/*\\\r\n * interact.stop\r\n [ method ]\r\n *\r\n * Cancels all interactions (end events are not fired)\r\n *\r\n - event (Event) An event on which to call preventDefault()\r\n = (object) interact\r\n\\*/\ninteract.stop = function (event) {\n  for (var i = scope.interactions.length - 1; i >= 0; i--) {\n    scope.interactions[i].stop(event);\n  }\n\n  return interact;\n};\n\n/*\\\r\n * interact.pointerMoveTolerance\r\n [ method ]\r\n * Returns or sets the distance the pointer must be moved before an action\r\n * sequence occurs. This also affects tolerance for tap events.\r\n *\r\n - newValue (number) #optional The movement from the start position must be greater than this value\r\n = (number | Interactable) The current setting or interact\r\n\\*/\ninteract.pointerMoveTolerance = function (newValue) {\n  if (utils.isNumber(newValue)) {\n    Interaction.pointerMoveTolerance = newValue;\n\n    return this;\n  }\n\n  return Interaction.pointerMoveTolerance;\n};\n\ninteract.addDocument = scope.addDocument;\ninteract.removeDocument = scope.removeDocument;\n\nscope.interact = interact;\n\nmodule.exports = interact;\n\n},{\"./Interactable\":4,\"./Interaction\":5,\"./scope\":28,\"./utils\":38,\"./utils/browser\":31,\"./utils/events\":34}],21:[function(require,module,exports){\nvar Interactable = require('./Interactable');\nvar Interaction = require('./Interaction');\nvar scope = require('./scope');\nvar isType = require('./utils/isType');\n\nvar _require = require('./utils/domUtils');\n\nvar nodeContains = _require.nodeContains;\n\n/*\\\r\n * Interactable.preventDefault\r\n [ method ]\r\n *\r\n * Returns or sets whether to prevent the browser's default behaviour\r\n * in response to pointer events. Can be set to:\r\n *  - `'always'` to always prevent\r\n *  - `'never'` to never prevent\r\n *  - `'auto'` to let interact.js try to determine what would be best\r\n *\r\n - newValue (string) #optional `true`, `false` or `'auto'`\r\n = (string | Interactable) The current setting or this Interactable\r\n\\*/\nInteractable.prototype.preventDefault = function (newValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue;\n    return this;\n  }\n\n  if (isType.isBool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never';\n    return this;\n  }\n\n  return this.options.preventDefault;\n};\n\nInteractable.prototype.checkAndPreventDefault = function (event) {\n  var setting = this.options.preventDefault;\n\n  if (setting === 'never') {\n    return;\n  }\n\n  if (setting === 'always') {\n    event.preventDefault();\n    return;\n  }\n\n  // setting === 'auto'\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return;\n  }\n\n  // don't preventDefault on input elements\n  if (/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n    return;\n  }\n\n  event.preventDefault();\n};\n\nfunction onInteractionEvent(_ref2) {\n  var interaction = _ref2.interaction;\n  var event = _ref2.event;\n\n  if (interaction.target) {\n    interaction.target.checkAndPreventDefault(event);\n  }\n}\n\nvar _arr = ['down', 'move', 'up', 'cancel'];\nfor (var _i = 0; _i < _arr.length; _i++) {\n  var eventSignal = _arr[_i];\n  Interaction.signals.on(eventSignal, onInteractionEvent);\n}\n\n// prevent native HTML5 drag on interact.js target elements\nInteraction.docEvents.dragstart = function preventNativeDrag(event) {\n  for (var _iterator = scope.interactions, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i2 >= _iterator.length) break;\n      _ref = _iterator[_i2++];\n    } else {\n      _i2 = _iterator.next();\n      if (_i2.done) break;\n      _ref = _i2.value;\n    }\n\n    var interaction = _ref;\n\n    if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {\n\n      interaction.target.checkAndPreventDefault(event);\n      return;\n    }\n  }\n};\n\n},{\"./Interactable\":4,\"./Interaction\":5,\"./scope\":28,\"./utils/domUtils\":33,\"./utils/isType\":40}],22:[function(require,module,exports){\nvar scope = require('./scope');\nvar events = require('./utils/events');\nvar browser = require('./utils/browser');\nvar iFinder = require('./utils/interactionFinder');\n\nvar toString = Object.prototype.toString;\n\nif (!window.Array.isArray) {\n  window.Array.isArray = function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  };\n}\n\n// http://www.quirksmode.org/dom/events/click.html\n// >Events leading to dblclick\n//\n// IE8 doesn't fire down event before dblclick.\n// This workaround tries to fire a tap and doubletap after dblclick\nfunction onIE8Dblclick(event) {\n  var interaction = iFinder.search(event, event.type, event.target);\n\n  if (!interaction) {\n    return;\n  }\n\n  if (interaction.prevTap && event.clientX === interaction.prevTap.clientX && event.clientY === interaction.prevTap.clientY && event.target === interaction.prevTap.target) {\n\n    interaction.downTargets[0] = event.target;\n    interaction.downTimes[0] = new Date().getTime();\n\n    scope.pointerEvents.collectEventTargets(interaction, event, event, event.target, 'tap');\n  }\n}\n\nif (browser.isIE8) {\n  (function () {\n    var selectFix = function (event) {\n      for (var _iterator = scope.interactions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var interaction = _ref;\n\n        if (interaction.interacting()) {\n          interaction.target.checkAndPreventDefault(event);\n        }\n      }\n    };\n\n    var onDocIE8 = function onDocIE8(_ref2, signalName) {\n      var doc = _ref2.doc;\n      var win = _ref2.win;\n\n      var eventMethod = signalName.indexOf('listen') === 0 ? events.add : events.remove;\n\n      // For IE's lack of Event#preventDefault\n      eventMethod(doc, 'selectstart', selectFix);\n\n      if (scope.pointerEvents) {\n        eventMethod(doc, 'dblclick', onIE8Dblclick);\n      }\n    };\n\n    scope.signals.on('add-document', onDocIE8);\n    scope.signals.on('remove-document', onDocIE8);\n  })();\n}\n\nmodule.exports = null;\n\n},{\"./scope\":28,\"./utils/browser\":31,\"./utils/events\":34,\"./utils/interactionFinder\":39}],23:[function(require,module,exports){\nvar InteractEvent = require('../InteractEvent');\nvar Interaction = require('../Interaction');\nvar extend = require('../utils/extend');\n\nvar modifiers = {\n  names: [],\n\n  setOffsets: function (interaction, coords) {\n    var target = interaction.target;\n    var element = interaction.element;\n\n    var rect = target.getRect(element);\n\n    if (rect) {\n      interaction.startOffset.left = coords.page.x - rect.left;\n      interaction.startOffset.top = coords.page.y - rect.top;\n\n      interaction.startOffset.right = rect.right - coords.page.x;\n      interaction.startOffset.bottom = rect.bottom - coords.page.y;\n\n      if (!('width' in rect)) {\n        rect.width = rect.right - rect.left;\n      }\n      if (!('height' in rect)) {\n        rect.height = rect.bottom - rect.top;\n      }\n    } else {\n      interaction.startOffset.left = interaction.startOffset.top = interaction.startOffset.right = interaction.startOffset.bottom = 0;\n    }\n\n    modifiers.setModifierOffsets(interaction, target, element, rect, interaction.modifierOffsets);\n  },\n\n  setModifierOffsets: function (interaction, interactable, element, rect, offsets) {\n    for (var i = 0; i < modifiers.names.length; i++) {\n      var modifierName = modifiers.names[i];\n\n      offsets[modifierName] = modifiers[modifiers.names[i]].setOffset(interaction, interactable, element, rect, interaction.startOffset);\n    }\n  },\n\n  setAll: function (interaction, coordsArg, statuses, preEnd, requireEndOnly) {\n    var result = {\n      dx: 0,\n      dy: 0,\n      changed: false,\n      locked: false,\n      shouldMove: true\n    };\n    var target = interaction.target;\n    var coords = extend({}, coordsArg);\n\n    var currentStatus = undefined;\n\n    for (var _iterator = modifiers.names, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var modifierName = _ref;\n\n      var modifier = modifiers[modifierName];\n\n      if (!modifier.shouldDo(target, interaction.prepared.name, preEnd, requireEndOnly)) {\n        continue;\n      }\n\n      currentStatus = modifier.set(coords, interaction, statuses[modifierName]);\n\n      if (currentStatus.locked) {\n        coords.x += currentStatus.dx;\n        coords.y += currentStatus.dy;\n\n        result.dx += currentStatus.dx;\n        result.dy += currentStatus.dy;\n\n        result.locked = true;\n      }\n    }\n\n    // a move should be fired if the modified coords of\n    // the last modifier status that was calculated changes\n    result.shouldMove = !currentStatus || currentStatus.changed;\n\n    return result;\n  },\n\n  resetStatuses: function (statuses) {\n    for (var _iterator2 = modifiers.names, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var modifierName = _ref2;\n\n      statuses[modifierName] = modifiers[modifierName].reset(statuses[modifierName] || {});\n    }\n\n    return statuses;\n  },\n\n  start: function (_ref3, signalName) {\n    var interaction = _ref3.interaction;\n\n    modifiers.setOffsets(interaction, signalName === 'action-resume' ? interaction.curCoords : interaction.startCoords);\n\n    modifiers.resetStatuses(interaction.modifierStatuses);\n    modifiers.setAll(interaction, interaction.startCoords.page, interaction.modifierStatuses);\n  }\n};\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.startOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n  interaction.modifierOffsets = {};\n  interaction.modifierStatuses = modifiers.resetStatuses({});\n});\n\nInteraction.signals.on('action-start', modifiers.start);\nInteraction.signals.on('action-resume', modifiers.start);\n\nInteraction.signals.on('before-action-move', function (_ref4) {\n  var interaction = _ref4.interaction;\n  var preEnd = _ref4.preEnd;\n  var interactingBeforeMove = _ref4.interactingBeforeMove;\n\n  var modifierResult = modifiers.setAll(interaction, interaction.curCoords.page, interaction.modifierStatuses, preEnd);\n\n  // don't fire an action move if a modifier would keep the event in the same\n  // cordinates as before\n  if (!modifierResult.shouldMove && interactingBeforeMove) {\n    interaction._dontFireMove = true;\n  }\n});\n\nInteraction.signals.on('action-end', function (_ref5) {\n  var interaction = _ref5.interaction;\n  var event = _ref5.event;\n\n  for (var i = 0; i < modifiers.names.length; i++) {\n    // if the endOnly option is true for any modifier\n    if (modifiers[modifiers.names[i]].shouldDo(interaction.target, interaction.prepared.name, true, true)) {\n      // fire a move event at the modified coordinates\n      interaction.doMove({ event: event, preEnd: true });\n      break;\n    }\n  }\n});\n\nInteractEvent.signals.on('set-xy', function (_ref6) {\n  var iEvent = _ref6.iEvent;\n  var interaction = _ref6.interaction;\n  var page = _ref6.page;\n  var client = _ref6.client;\n  var phase = _ref6.phase;\n  var actionName = _ref6.action;\n\n  var target = interaction.target;\n\n  for (var i = 0; i < modifiers.names.length; i++) {\n    var modifierName = modifiers.names[i];\n    var modifier = modifiers[modifierName];\n\n    iEvent[modifierName] = modifier.modifyCoords(page, client, target, interaction.modifierStatuses[modifierName], actionName, phase);\n  }\n});\n\nmodule.exports = modifiers;\n\n},{\"../InteractEvent\":3,\"../Interaction\":5,\"../utils/extend\":35}],24:[function(require,module,exports){\nvar modifiers = require('./index');\nvar utils = require('../utils');\nvar defaultOptions = require('../defaultOptions');\n\nvar restrict = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    restriction: null,\n    elementRect: null\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    var restrictOptions = interactable.options[actionName].restrict;\n\n    return restrictOptions && restrictOptions.enabled && (preEnd || !restrictOptions.endOnly) && (!requireEndOnly || restrictOptions.endOnly);\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    var elementRect = interactable.options[interaction.prepared.name].restrict.elementRect;\n    var offset = {};\n\n    if (rect && elementRect) {\n      offset.left = startOffset.left - rect.width * elementRect.left;\n      offset.top = startOffset.top - rect.height * elementRect.top;\n\n      offset.right = startOffset.right - rect.width * (1 - elementRect.right);\n      offset.bottom = startOffset.bottom - rect.height * (1 - elementRect.bottom);\n    } else {\n      offset.left = offset.top = offset.right = offset.bottom = 0;\n    }\n\n    return offset;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    var target = interaction.target;\n    var restrictOptions = target && target.options[interaction.prepared.name].restrict;\n    var restriction = restrictOptions && restrictOptions.restriction;\n\n    if (!restriction) {\n      return status;\n    }\n\n    var page = status.useStatusXY ? { x: status.x, y: status.y } : utils.extend({}, pageCoords);\n\n    status.dx = 0;\n    status.dy = 0;\n    status.locked = false;\n\n    var rect = undefined;\n    var restrictedX = undefined;\n    var restrictedY = undefined;\n\n    if (utils.isString(restriction)) {\n      if (restriction === 'parent') {\n        restriction = utils.parentNode(interaction.element);\n      } else if (restriction === 'self') {\n        restriction = target.getRect(interaction.element);\n      } else {\n        restriction = utils.closest(interaction.element, restriction);\n      }\n\n      if (!restriction) {\n        return status;\n      }\n    }\n\n    if (utils.isFunction(restriction)) {\n      restriction = restriction(page.x, page.y, interaction.element);\n    }\n\n    if (utils.isElement(restriction)) {\n      restriction = utils.getElementRect(restriction);\n    }\n\n    rect = restriction;\n\n    var offset = interaction.modifierOffsets.restrict;\n\n    if (!restriction) {\n      restrictedX = page.x;\n      restrictedY = page.y;\n    }\n    // object is assumed to have\n    // x, y, width, height or\n    // left, top, right, bottom\n    else if ('x' in restriction && 'y' in restriction) {\n        restrictedX = Math.max(Math.min(rect.x + rect.width - offset.right, page.x), rect.x + offset.left);\n        restrictedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top);\n      } else {\n        restrictedX = Math.max(Math.min(rect.right - offset.right, page.x), rect.left + offset.left);\n        restrictedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top + offset.top);\n      }\n\n    status.dx = restrictedX - page.x;\n    status.dy = restrictedY - page.y;\n\n    status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n    status.locked = !!(status.dx || status.dy);\n\n    status.restrictedX = restrictedX;\n    status.restrictedY = restrictedY;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.modifiedX = status.modifiedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    var options = interactable.options[actionName].restrict;\n    var elementRect = options && options.elementRect;\n\n    if (options && options.enabled && !(phase === 'start' && elementRect && status.locked)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n\n        return {\n          dx: status.dx,\n          dy: status.dy\n        };\n      }\n    }\n  }\n};\n\nmodifiers.restrict = restrict;\nmodifiers.names.push('restrict');\n\ndefaultOptions.perAction.restrict = restrict.defaults;\n\nmodule.exports = restrict;\n\n},{\"../defaultOptions\":17,\"../utils\":38,\"./index\":23}],25:[function(require,module,exports){\nvar modifiers = require('./index');\nvar interact = require('../interact');\nvar utils = require('../utils');\nvar defaultOptions = require('../defaultOptions');\n\nvar snap = {\n  defaults: {\n    enabled: false,\n    endOnly: false,\n    range: Infinity,\n    targets: null,\n    offsets: null,\n\n    relativePoints: null\n  },\n\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\n    var snapOptions = interactable.options[actionName].snap;\n\n    return snapOptions && snapOptions.enabled && (preEnd || !snapOptions.endOnly) && (!requireEndOnly || snapOptions.endOnly);\n  },\n\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\n    var offsets = [];\n    var origin = utils.getOriginXY(interactable, element);\n    var snapOptions = interactable.options[interaction.prepared.name].snap || {};\n    var snapOffset = undefined;\n\n    if (snapOptions.offset === 'startCoords') {\n      snapOffset = {\n        x: interaction.startCoords.page.x - origin.x,\n        y: interaction.startCoords.page.y - origin.y\n      };\n    } else if (snapOptions.offset === 'self') {\n      snapOffset = {\n        x: rect.left - origin.x,\n        y: rect.top - origin.y\n      };\n    } else {\n      snapOffset = snapOptions.offset || { x: 0, y: 0 };\n    }\n\n    if (rect && snapOptions.relativePoints && snapOptions.relativePoints.length) {\n      for (var _iterator = snapOptions.relativePoints, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var relativeX = _ref.x;\n        var relativeY = _ref.y;\n\n        offsets.push({\n          x: startOffset.left - rect.width * relativeX + snapOffset.x,\n          y: startOffset.top - rect.height * relativeY + snapOffset.y\n        });\n      }\n    } else {\n      offsets.push(snapOffset);\n    }\n\n    return offsets;\n  },\n\n  set: function (pageCoords, interaction, status) {\n    var snapOptions = interaction.target.options[interaction.prepared.name].snap;\n    var targets = [];\n    var target = undefined;\n    var page = undefined;\n    var i = undefined;\n\n    if (status.useStatusXY) {\n      page = { x: status.x, y: status.y };\n    } else {\n      var origin = utils.getOriginXY(interaction.target, interaction.element);\n\n      page = utils.extend({}, pageCoords);\n\n      page.x -= origin.x;\n      page.y -= origin.y;\n    }\n\n    status.realX = page.x;\n    status.realY = page.y;\n\n    var offsets = interaction.modifierOffsets.snap;\n    var len = snapOptions.targets ? snapOptions.targets.length : 0;\n\n    for (var _iterator2 = offsets, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var offsetX = _ref2.x;\n      var offsetY = _ref2.y;\n\n      var relativeX = page.x - offsetX;\n      var relativeY = page.y - offsetY;\n\n      for (var _iterator3 = snapOptions.targets, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var snapTarget = _ref3;\n\n        if (utils.isFunction(snapTarget)) {\n          target = snapTarget(relativeX, relativeY, interaction);\n        } else {\n          target = snapTarget;\n        }\n\n        if (!target) {\n          continue;\n        }\n\n        targets.push({\n          x: utils.isNumber(target.x) ? target.x + offsetX : relativeX,\n          y: utils.isNumber(target.y) ? target.y + offsetY : relativeY,\n\n          range: utils.isNumber(target.range) ? target.range : snapOptions.range\n        });\n      }\n    }\n\n    var closest = {\n      target: null,\n      inRange: false,\n      distance: 0,\n      range: 0,\n      dx: 0,\n      dy: 0\n    };\n\n    for (i = 0, len = targets.length; i < len; i++) {\n      target = targets[i];\n\n      var range = target.range;\n      var dx = target.x - page.x;\n      var dy = target.y - page.y;\n      var distance = utils.hypot(dx, dy);\n      var inRange = distance <= range;\n\n      // Infinite targets count as being out of range\n      // compared to non infinite ones that are in range\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n        inRange = false;\n      }\n\n      if (!closest.target || (inRange\n      // is the closest target in range?\n      ? closest.inRange && range !== Infinity\n      // the pointer is relatively deeper in this target\n      ? distance / range < closest.distance / closest.range\n      // this target has Infinite range and the closest doesn't\n      : range === Infinity && closest.range !== Infinity ||\n      // OR this target is closer that the previous closest\n      distance < closest.distance :\n      // The other is not in range and the pointer is closer to this target\n      !closest.inRange && distance < closest.distance)) {\n\n        closest.target = target;\n        closest.distance = distance;\n        closest.range = range;\n        closest.inRange = inRange;\n        closest.dx = dx;\n        closest.dy = dy;\n\n        status.range = range;\n      }\n    }\n\n    var snapChanged = undefined;\n\n    if (closest.target) {\n      snapChanged = status.snappedX !== closest.target.x || status.snappedY !== closest.target.y;\n\n      status.snappedX = closest.target.x;\n      status.snappedY = closest.target.y;\n    } else {\n      snapChanged = true;\n\n      status.snappedX = NaN;\n      status.snappedY = NaN;\n    }\n\n    status.dx = closest.dx;\n    status.dy = closest.dy;\n\n    status.changed = snapChanged || closest.inRange && !status.locked;\n    status.locked = closest.inRange;\n\n    return status;\n  },\n\n  reset: function (status) {\n    status.dx = status.dy = 0;\n    status.snappedX = status.snappedY = NaN;\n    status.locked = false;\n    status.changed = true;\n\n    return status;\n  },\n\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\n    var snapOptions = interactable.options[actionName].snap;\n    var relativePoints = snapOptions && snapOptions.relativePoints;\n\n    if (snapOptions && snapOptions.enabled && !(phase === 'start' && relativePoints && relativePoints.length)) {\n\n      if (status.locked) {\n        page.x += status.dx;\n        page.y += status.dy;\n        client.x += status.dx;\n        client.y += status.dy;\n      }\n\n      return {\n        range: status.range,\n        locked: status.locked,\n        x: status.snappedX,\n        y: status.snappedY,\n        realX: status.realX,\n        realY: status.realY,\n        dx: status.dx,\n        dy: status.dy\n      };\n    }\n  }\n};\n\ninteract.createSnapGrid = function (grid) {\n  return function (x, y) {\n    var limits = grid.limits || {\n      left: -Infinity,\n      right: Infinity,\n      top: -Infinity,\n      bottom: Infinity\n    };\n    var offsetX = 0;\n    var offsetY = 0;\n\n    if (utils.isObject(grid.offset)) {\n      offsetX = grid.offset.x;\n      offsetY = grid.offset.y;\n    }\n\n    var gridx = Math.round((x - offsetX) / grid.x);\n    var gridy = Math.round((y - offsetY) / grid.y);\n\n    var newX = Math.max(limits.left, Math.min(limits.right, gridx * grid.x + offsetX));\n    var newY = Math.max(limits.top, Math.min(limits.bottom, gridy * grid.y + offsetY));\n\n    return {\n      x: newX,\n      y: newY,\n      range: grid.range\n    };\n  };\n};\n\nmodifiers.snap = snap;\nmodifiers.names.push('snap');\n\ndefaultOptions.perAction.snap = snap.defaults;\n\nmodule.exports = snap;\n\n},{\"../defaultOptions\":17,\"../interact\":20,\"../utils\":38,\"./index\":23}],26:[function(require,module,exports){\nvar scope = require('../scope');\nvar Interaction = require('../Interaction');\nvar utils = require('../utils');\nvar browser = require('../utils/browser');\nvar defaults = require('../defaultOptions');\nvar signals = require('../utils/Signals')['new']();\n\nvar simpleSignals = ['down', 'up', 'up', 'cancel'];\nvar simpleEvents = ['down', 'up', 'tap', 'cancel'];\n\nfunction preventOriginalDefault() {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopImmediatePropagation() {\n  this.immediatePropagationStopped = this.propagationStopped = true;\n}\n\nfunction stopPropagation() {\n  this.propagationStopped = true;\n}\n\nfunction firePointers(interaction, pointer, event, eventTarget, targets, eventType) {\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n  var pointerEvent = {};\n  var i = undefined;\n  // for tap events\n  var interval = undefined;\n  var createNewDoubleTap = undefined;\n\n  // if it's a doubletap then the event properties would have been\n  // copied from the tap event and provided as the pointer argument\n  if (eventType === 'doubletap') {\n    pointerEvent = pointer;\n  } else {\n    utils.pointerExtend(pointerEvent, event);\n    if (event !== pointer) {\n      utils.pointerExtend(pointerEvent, pointer);\n    }\n\n    pointerEvent.preventDefault = preventOriginalDefault;\n    pointerEvent.stopPropagation = stopPropagation;\n    pointerEvent.stopImmediatePropagation = stopImmediatePropagation;\n    pointerEvent.interaction = interaction;\n\n    pointerEvent.timeStamp = new Date().getTime();\n    pointerEvent.originalEvent = event;\n    pointerEvent.type = eventType;\n    pointerEvent.pointerId = utils.getPointerId(pointer);\n    pointerEvent.pointerType = interaction.mouse ? 'mouse' : !browser.supportsPointerEvent ? 'touch' : utils.isString(pointer.pointerType) ? pointer.pointerType : [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType];\n  }\n\n  if (eventType === 'tap') {\n    pointerEvent.dt = pointerEvent.timeStamp - interaction.downTimes[pointerIndex];\n\n    interval = pointerEvent.timeStamp - interaction.tapTime;\n    createNewDoubleTap = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap' && interaction.prevTap.target === pointerEvent.target && interval < 500);\n\n    pointerEvent.double = createNewDoubleTap;\n\n    interaction.tapTime = pointerEvent.timeStamp;\n  }\n\n  var signalArg = {\n    pointerEvent: pointerEvent,\n    pointer: pointer,\n    event: event,\n    targets: targets\n  };\n\n  signals.fire('new', signalArg);\n\n  for (i = 0; i < targets.length; i++) {\n    var target = targets[i];\n\n    pointerEvent.currentTarget = target.element;\n\n    for (var prop in target.props || {}) {\n      pointerEvent[prop] = target.props[prop];\n    }\n\n    target.eventable.fire(pointerEvent);\n\n    if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && i + 1 < targets.length && targets[i + 1].element !== pointerEvent.currentTarget) {\n      break;\n    }\n  }\n\n  signals.fire('fired', signalArg);\n\n  if (createNewDoubleTap) {\n    var doubleTap = {};\n\n    utils.extend(doubleTap, pointerEvent);\n\n    doubleTap.dt = interval;\n    doubleTap.type = 'doubletap';\n\n    collectEventTargets(interaction, doubleTap, event, eventTarget, 'doubletap');\n\n    interaction.prevTap = doubleTap;\n  } else if (eventType === 'tap') {\n    interaction.prevTap = pointerEvent;\n  }\n}\n\nfunction collectEventTargets(interaction, pointer, event, eventTarget, eventType) {\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (eventType === 'tap' && (interaction.pointerWasMoved\n  // or if the pointerup target is different to the pointerdown target\n   || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\n    return;\n  }\n\n  var targets = [];\n  var path = utils.getPath(eventTarget);\n  var signalArg = {\n    targets: targets,\n    interaction: interaction,\n    pointer: pointer,\n    event: event,\n    eventTarget: eventTarget,\n    eventType: eventType,\n    path: path,\n    element: null\n  };\n\n  for (var _iterator = path, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var element = _ref;\n\n    signalArg.element = element;\n\n    signals.fire('collect-targets', signalArg);\n  }\n\n  // create the tap event even if there are no listeners so that\n  // doubletap can still be created and fired\n  if (targets.length || eventType === 'tap') {\n    firePointers(interaction, pointer, event, eventTarget, targets, eventType);\n  }\n}\n\nInteraction.signals.on('move', function (_ref2) {\n  var interaction = _ref2.interaction;\n  var pointer = _ref2.pointer;\n  var event = _ref2.event;\n  var eventTarget = _ref2.eventTarget;\n  var duplicateMove = _ref2.duplicateMove;\n\n  var pointerIndex = interaction.mouse ? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\n\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.holdTimers[pointerIndex]);\n    }\n\n    collectEventTargets(interaction, pointer, event, eventTarget, 'move');\n  }\n});\n\nInteraction.signals.on('down', function (_ref3) {\n  var interaction = _ref3.interaction;\n  var pointer = _ref3.pointer;\n  var event = _ref3.event;\n  var eventTarget = _ref3.eventTarget;\n  var pointerIndex = _ref3.pointerIndex;\n\n  // copy event to be used in timeout for IE8\n  var eventCopy = browser.isIE8 ? utils.extend({}, event) : event;\n\n  interaction.holdTimers[pointerIndex] = setTimeout(function () {\n\n    collectEventTargets(interaction, browser.isIE8 ? eventCopy : pointer, eventCopy, eventTarget, 'hold');\n  }, defaults._holdDuration);\n});\n\nfunction createSignalListener(event) {\n  return function (arg) {\n    collectEventTargets(arg.interaction, arg.pointer, arg.event, arg.eventTarget, event);\n  };\n}\n\nfor (var i = 0; i < simpleSignals.length; i++) {\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\n}\n\nInteraction.signals.on('new', function (interaction) {\n  interaction.prevTap = null; // the most recent tap event on this interaction\n  interaction.tapTime = 0; // time of the most recent tap event\n});\n\nmodule.exports = scope.pointerEvents = {\n  firePointers: firePointers,\n  collectEventTargets: collectEventTargets,\n  preventOriginalDefault: preventOriginalDefault,\n  signals: signals,\n  types: ['down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold']\n};\n\n},{\"../Interaction\":5,\"../defaultOptions\":17,\"../scope\":28,\"../utils\":38,\"../utils/Signals\":29,\"../utils/browser\":31}],27:[function(require,module,exports){\nvar pointerEvents = require('./index');\nvar Interactable = require('../Interactable');\nvar browser = require('../utils/browser');\nvar isType = require('../utils/isType');\nvar domUtils = require('../utils/domUtils');\nvar scope = require('../scope');\n\nvar _require = require('../utils/arr');\n\nvar merge = _require.merge;\n\npointerEvents.signals.on('collect-targets', function (_ref) {\n  var targets = _ref.targets;\n  var element = _ref.element;\n  var eventType = _ref.eventType;\n\n  function collectSelectors(interactable, selector, context) {\n    var els = browser.useMatchesSelectorPolyfill ? context.querySelectorAll(selector) : undefined;\n\n    var eventable = interactable._iEvents;\n\n    if (eventable[eventType] && isType.isElement(element) && interactable.inContext(element) && domUtils.matchesSelector(element, selector, els)) {\n\n      targets.push({\n        element: element,\n        eventable: eventable,\n        props: { interactable: interactable }\n      });\n    }\n  }\n\n  var interactable = scope.interactables.get(element);\n\n  if (interactable) {\n    var eventable = interactable._iEvents;\n\n    if (eventable[eventType]) {\n      targets.push({\n        element: element,\n        eventable: eventable,\n        props: { interactable: interactable }\n      });\n    }\n  }\n\n  scope.interactables.forEachSelector(collectSelectors);\n});\n\nmerge(Interactable.eventTypes, pointerEvents.types);\n\n},{\"../Interactable\":4,\"../scope\":28,\"../utils/arr\":30,\"../utils/browser\":31,\"../utils/domUtils\":33,\"../utils/isType\":40,\"./index\":26}],28:[function(require,module,exports){\nvar utils = require('./utils');\nvar extend = require('./utils/extend');\nvar events = require('./utils/events');\nvar signals = require('./utils/Signals')['new']();\n\nvar scope = {\n  signals: signals,\n  events: events,\n  utils: utils,\n\n  documents: [], // all documents being listened to\n\n  addDocument: function (doc, win) {\n    // do nothing if document is already known\n    if (utils.contains(scope.documents, doc)) {\n      return false;\n    }\n\n    win = win || scope.getWindow(doc);\n\n    scope.documents.push(doc);\n    events.documents.push(doc);\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== scope.document) {\n      events.add(win, 'unload', scope.onWindowUnload);\n    }\n\n    signals.fire('add-document', { doc: doc, win: win });\n  },\n\n  removeDocument: function (doc, win) {\n    var index = utils.indexOf(scope.documents, doc);\n\n    win = win || scope.getWindow(doc);\n\n    events.remove(win, 'unload', scope.onWindowUnload);\n\n    scope.documents.splice(index, 1);\n    events.documents.splice(index, 1);\n\n    signals.fire('remove-document', { win: win, doc: doc });\n  },\n\n  onWindowUnload: function () {\n    scope.removeDocument(this.document, this);\n  }\n};\n\nextend(scope, require('./utils/window'));\nextend(scope, require('./utils/domObjects'));\n\nmodule.exports = scope;\n\n},{\"./utils\":38,\"./utils/Signals\":29,\"./utils/domObjects\":32,\"./utils/events\":34,\"./utils/extend\":35,\"./utils/window\":45}],29:[function(require,module,exports){\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _require = require('./arr');\n\nvar indexOf = _require.indexOf;\n\nvar Signals = (function () {\n  function Signals() {\n    _classCallCheck(this, Signals);\n\n    this.listeners = {\n      // signalName: [listeners],\n    };\n  }\n\n  Signals.prototype.on = function on(name, listener) {\n    if (!this.listeners[name]) {\n      this.listeners[name] = [listener];\n      return;\n    }\n\n    this.listeners[name].push(listener);\n  };\n\n  Signals.prototype.off = function off(name, listener) {\n    if (!this.listeners[name]) {\n      return;\n    }\n\n    var index = indexOf(this.listeners[name], listener);\n\n    if (index !== -1) {\n      this.listeners[name].splice(index, 1);\n    }\n  };\n\n  Signals.prototype.fire = function fire(name, arg) {\n    var targetListeners = this.listeners[name];\n\n    if (!targetListeners) {\n      return;\n    }\n\n    for (var i = 0; i < targetListeners.length; i++) {\n      if (targetListeners[i](arg, name) === false) {\n        return;\n      }\n    }\n  };\n\n  return Signals;\n})();\n\nSignals['new'] = function () {\n  return new Signals();\n};\n\nmodule.exports = Signals;\n\n},{\"./arr\":30}],30:[function(require,module,exports){\nfunction indexOf(array, target) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction contains(array, target) {\n  return indexOf(array, target) !== -1;\n}\n\nfunction merge(target, source) {\n  for (var i = 0; i < source.length; i++) {\n    target.push(source[i]);\n  }\n\n  return target;\n}\n\nmodule.exports = {\n  indexOf: indexOf,\n  contains: contains,\n  merge: merge\n};\n\n},{}],31:[function(require,module,exports){\nvar win = require('./window');\nvar isType = require('./isType');\nvar domObjects = require('./domObjects');\n\nvar browser = {\n  // Does the browser support touch input?\n  supportsTouch: !!('ontouchstart' in win.window || isType.isFunction(win.window.DocumentTouch) && domObjects.document instanceof win.DocumentTouch),\n\n  // Does the browser support PointerEvents\n  supportsPointerEvent: !!domObjects.PointerEvent,\n\n  isIE8: 'attachEvent' in win.window && !('addEventListener' in win.window),\n\n  // Opera Mobile must be handled differently\n  isOperaMobile: navigator.appName === 'Opera' && browser.supportsTouch && navigator.userAgent.match('Presto'),\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  isIOS7: /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n\n  isIe9OrOlder: domObjects.document.all && !win.window.atob,\n\n  // prefix matchesSelector\n  prefixedMatchesSelector: 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n\n  useMatchesSelectorPolyfill: false,\n\n  pEventTypes: domObjects.PointerEvent ? domObjects.PointerEvent === win.window.MSPointerEvent ? { up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' } : { up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' } : null,\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  wheelEvent: 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n\n};\n\nbrowser.useMatchesSelectorPolyfill = !isType.isFunction(Element.prototype[browser.prefixedMatchesSelector]);\n\nmodule.exports = browser;\n\n},{\"./domObjects\":32,\"./isType\":40,\"./window\":45}],32:[function(require,module,exports){\nvar domObjects = {};\nvar win = require('./window').window;\n\nfunction blank() {}\n\ndomObjects.document = win.document;\ndomObjects.DocumentFragment = win.DocumentFragment || blank;\ndomObjects.SVGElement = win.SVGElement || blank;\ndomObjects.SVGSVGElement = win.SVGSVGElement || blank;\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\ndomObjects.HTMLElement = win.HTMLElement || win.Element;\n\ndomObjects.Event = win.Event;\ndomObjects.Touch = win.Touch || blank;\ndomObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;\n\nmodule.exports = domObjects;\n\n},{\"./window\":45}],33:[function(require,module,exports){\nvar win = require('./window');\nvar browser = require('./browser');\nvar isType = require('./isType');\nvar domObjects = require('./domObjects');\n\nvar domUtils = {\n  nodeContains: function (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  },\n\n  closest: function (element, selector) {\n    while (isType.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return element;\n      }\n\n      element = domUtils.parentNode(element);\n    }\n\n    return null;\n  },\n\n  parentNode: function (node) {\n    var parent = node.parentNode;\n\n    if (isType.isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isType.isDocFrag(parent)) {\n        continue;\n      }\n\n      return parent;\n    }\n\n    return parent;\n  },\n\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill ? function (element, selector, elems) {\n    elems = elems || element.parentNode.querySelectorAll(selector);\n\n    for (var i = 0, len = elems.length; i < len; i++) {\n      if (elems[i] === element) {\n        return true;\n      }\n    }\n\n    return false;\n  } : null,\n\n  matchesSelector: function (element, selector, nodeList) {\n    if (browser.useMatchesSelectorPolyfill) {\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (win.window !== win.realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[browser.prefixedMatchesSelector](selector);\n  },\n\n  // Test for the element that's \"above\" all other qualifiers\n  indexOfDeepestElement: function (elements) {\n    var deepestZoneParents = [];\n    var dropzoneParents = [];\n    var dropzone = undefined;\n    var deepestZone = elements[0];\n    var index = deepestZone ? 0 : -1;\n    var parent = undefined;\n    var child = undefined;\n    var i = undefined;\n    var n = undefined;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n          deepestZone = dropzone;\n          index = i;\n          continue;\n        }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof domObjects.HTMLElement && dropzone instanceof domObjects.SVGElement && !(dropzone instanceof domObjects.SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      } else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        } else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  },\n\n  matchesUpTo: function (element, selector, limit) {\n    while (isType.isElement(element)) {\n      if (domUtils.matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = domUtils.parentNode(element);\n\n      if (element === limit) {\n        return domUtils.matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  },\n\n  getActualElement: function (element) {\n    return element instanceof domObjects.SVGElementInstance ? element.correspondingUseElement : element;\n  },\n\n  getScrollXY: function (relevantWindow) {\n    relevantWindow = relevantWindow || win.window;\n    return {\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop\n    };\n  },\n\n  getElementClientRect: function (element) {\n    var clientRect = element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n\n    return clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top\n    };\n  },\n\n  getElementRect: function (element) {\n    var clientRect = domUtils.getElementClientRect(element);\n\n    if (!browser.isIOS7 && clientRect) {\n      var _scroll = domUtils.getScrollXY(win.getWindow(element));\n\n      clientRect.left += _scroll.x;\n      clientRect.right += _scroll.x;\n      clientRect.top += _scroll.y;\n      clientRect.bottom += _scroll.y;\n    }\n\n    return clientRect;\n  },\n\n  getPath: function (element) {\n    var path = [];\n\n    while (element) {\n      path.push(element);\n      element = domUtils.parentNode(element);\n    }\n\n    return path;\n  }\n};\n\nmodule.exports = domUtils;\n\n},{\"./browser\":31,\"./domObjects\":32,\"./isType\":40,\"./window\":45}],34:[function(require,module,exports){\nvar arr = require('./arr');\nvar isType = require('./isType');\nvar domUtils = require('./domUtils');\nvar indexOf = arr.indexOf;\nvar contains = arr.contains;\nvar getWindow = require('./window').getWindow;\nvar pExtend = require('./pointerExtend');\n\nvar useAttachEvent = 'attachEvent' in window && !('addEventListener' in window);\nvar addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener';\nvar removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener';\nvar on = useAttachEvent ? 'on' : '';\n\nvar elements = [];\nvar targets = [];\nvar attachedListeners = [];\n\n// {\n//   type: {\n//     selectors: ['selector', ...],\n//     contexts : [document, ...],\n//     listeners: [[listener, useCapture], ...]\n//   }\n//  }\nvar delegatedEvents = {};\n\nvar documents = [];\n\nfunction add(element, type, listener, useCapture) {\n  var elementIndex = indexOf(elements, element);\n  var target = targets[elementIndex];\n\n  if (!target) {\n    target = {\n      events: {},\n      typeCount: 0\n    };\n\n    elementIndex = elements.push(element) - 1;\n    targets.push(target);\n\n    attachedListeners.push(useAttachEvent ? {\n      supplied: [],\n      wrapped: [],\n      useCount: []\n    } : null);\n  }\n\n  if (!target.events[type]) {\n    target.events[type] = [];\n    target.typeCount++;\n  }\n\n  if (!contains(target.events[type], listener)) {\n    var ret = undefined;\n\n    if (useAttachEvent) {\n      var _attachedListeners$elementIndex = attachedListeners[elementIndex];\n      var supplied = _attachedListeners$elementIndex.supplied;\n      var wrapped = _attachedListeners$elementIndex.wrapped;\n      var useCount = _attachedListeners$elementIndex.useCount;\n\n      var listenerIndex = indexOf(supplied, listener);\n\n      var wrappedListener = wrapped[listenerIndex] || function (event) {\n        if (!event.immediatePropagationStopped) {\n          event.target = event.srcElement;\n          event.currentTarget = element;\n\n          event.preventDefault = event.preventDefault || preventDef;\n          event.stopPropagation = event.stopPropagation || stopProp;\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n          if (/mouse|click/.test(event.type)) {\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n          }\n\n          listener(event);\n        }\n      };\n\n      ret = element[addEvent](on + type, wrappedListener, !!useCapture);\n\n      if (listenerIndex === -1) {\n        supplied.push(listener);\n        wrapped.push(wrappedListener);\n        useCount.push(1);\n      } else {\n        useCount[listenerIndex]++;\n      }\n    } else {\n      ret = element[addEvent](type, listener, !!useCapture);\n    }\n    target.events[type].push(listener);\n\n    return ret;\n  }\n}\n\nfunction remove(element, type, listener, useCapture) {\n  var elementIndex = indexOf(elements, element);\n  var target = targets[elementIndex];\n\n  if (!target || !target.events) {\n    return;\n  }\n\n  var wrappedListener = listener;\n  var listeners = undefined;\n  var listenerIndex = undefined;\n\n  if (useAttachEvent) {\n    listeners = attachedListeners[elementIndex];\n    listenerIndex = indexOf(listeners.supplied, listener);\n    wrappedListener = listeners.wrapped[listenerIndex];\n  }\n\n  if (type === 'all') {\n    for (type in target.events) {\n      if (target.events.hasOwnProperty(type)) {\n        remove(element, type, 'all');\n      }\n    }\n    return;\n  }\n\n  if (target.events[type]) {\n    var len = target.events[type].length;\n\n    if (listener === 'all') {\n      for (var i = 0; i < len; i++) {\n        remove(element, type, target.events[type][i], !!useCapture);\n      }\n      return;\n    } else {\n      for (var i = 0; i < len; i++) {\n        if (target.events[type][i] === listener) {\n          element[removeEvent](on + type, wrappedListener, !!useCapture);\n          target.events[type].splice(i, 1);\n\n          if (useAttachEvent && listeners) {\n            listeners.useCount[listenerIndex]--;\n            if (listeners.useCount[listenerIndex] === 0) {\n              listeners.supplied.splice(listenerIndex, 1);\n              listeners.wrapped.splice(listenerIndex, 1);\n              listeners.useCount.splice(listenerIndex, 1);\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (target.events[type] && target.events[type].length === 0) {\n      target.events[type] = null;\n      target.typeCount--;\n    }\n  }\n\n  if (!target.typeCount) {\n    targets.splice(elementIndex, 1);\n    elements.splice(elementIndex, 1);\n    attachedListeners.splice(elementIndex, 1);\n  }\n}\n\nfunction addDelegate(selector, context, type, listener, useCapture) {\n  if (!delegatedEvents[type]) {\n    delegatedEvents[type] = {\n      selectors: [],\n      contexts: [],\n      listeners: []\n    };\n\n    // add delegate listener functions\n    for (var i = 0; i < documents.length; i++) {\n      add(documents[i], type, delegateListener);\n      add(documents[i], type, delegateUseCapture, true);\n    }\n  }\n\n  var delegated = delegatedEvents[type];\n  var index = undefined;\n\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n      break;\n    }\n  }\n\n  if (index === -1) {\n    index = delegated.selectors.length;\n\n    delegated.selectors.push(selector);\n    delegated.contexts.push(context);\n    delegated.listeners.push([]);\n  }\n\n  // keep listener and useCapture flag\n  delegated.listeners[index].push([listener, useCapture]);\n}\n\nfunction removeDelegate(selector, context, type, listener, useCapture) {\n  var delegated = delegatedEvents[type];\n  var matchFound = false;\n  var index = undefined;\n\n  if (!delegated) {\n    return;\n  }\n\n  // count from last index of delegated to 0\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\n    // look for matching selector and context Node\n    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {\n\n      var listeners = delegated.listeners[index];\n\n      // each item of the listeners array is an array: [function, useCaptureFlag]\n      for (var i = listeners.length - 1; i >= 0; i--) {\n        var fn = listeners[i][0];\n        var useCap = listeners[i][1];\n\n        // check if the listener functions and useCapture flags match\n        if (fn === listener && useCap === useCapture) {\n          // remove the listener from the array of listeners\n          listeners.splice(i, 1);\n\n          // if all listeners for this interactable have been removed\n          // remove the interactable from the delegated arrays\n          if (!listeners.length) {\n            delegated.selectors.splice(index, 1);\n            delegated.contexts.splice(index, 1);\n            delegated.listeners.splice(index, 1);\n\n            // remove delegate function from context\n            remove(context, type, delegateListener);\n            remove(context, type, delegateUseCapture, true);\n\n            // remove the arrays if they are empty\n            if (!delegated.selectors.length) {\n              delegatedEvents[type] = null;\n            }\n          }\n\n          // only remove one listener\n          matchFound = true;\n          break;\n        }\n      }\n\n      if (matchFound) {\n        break;\n      }\n    }\n  }\n}\n\n// bound to the interactable context when a DOM event\n// listener is added to a selector interactable\nfunction delegateListener(event, useCapture) {\n  var fakeEvent = {};\n  var delegated = delegatedEvents[event.type];\n  var eventTarget = domUtils.getActualElement(event.path ? event.path[0] : event.target);\n  var element = eventTarget;\n\n  useCapture = useCapture ? true : false;\n\n  // duplicate the event so that currentTarget can be changed\n  pExtend(fakeEvent, event);\n\n  fakeEvent.originalEvent = event;\n  fakeEvent.preventDefault = preventOriginalDefault;\n\n  // climb up document tree looking for selector matches\n  while (isType.isElement(element)) {\n    for (var i = 0; i < delegated.selectors.length; i++) {\n      var selector = delegated.selectors[i];\n      var context = delegated.contexts[i];\n\n      if (domUtils.matchesSelector(element, selector) && domUtils.nodeContains(context, eventTarget) && domUtils.nodeContains(context, element)) {\n\n        var listeners = delegated.listeners[i];\n\n        fakeEvent.currentTarget = element;\n\n        for (var j = 0; j < listeners.length; j++) {\n          if (listeners[j][1] === useCapture) {\n            listeners[j][0](fakeEvent);\n          }\n        }\n      }\n    }\n\n    element = domUtils.parentNode(element);\n  }\n}\n\nfunction delegateUseCapture(event) {\n  return delegateListener.call(this, event, true);\n}\n\nfunction preventDef() {\n  this.returnValue = false;\n}\n\nfunction preventOriginalDefault() {\n  this.originalEvent.preventDefault();\n}\n\nfunction stopProp() {\n  this.cancelBubble = true;\n}\n\nfunction stopImmProp() {\n  this.cancelBubble = true;\n  this.immediatePropagationStopped = true;\n}\n\nmodule.exports = {\n  add: add,\n  remove: remove,\n\n  addDelegate: addDelegate,\n  removeDelegate: removeDelegate,\n\n  delegateListener: delegateListener,\n  delegateUseCapture: delegateUseCapture,\n  delegatedEvents: delegatedEvents,\n  documents: documents,\n\n  useAttachEvent: useAttachEvent,\n\n  _elements: elements,\n  _targets: targets,\n  _attachedListeners: attachedListeners\n};\n\n},{\"./arr\":30,\"./domUtils\":33,\"./isType\":40,\"./pointerExtend\":42,\"./window\":45}],35:[function(require,module,exports){\nmodule.exports = function extend(dest, source) {\n  for (var prop in source) {\n    dest[prop] = source[prop];\n  }\n  return dest;\n};\n\n},{}],36:[function(require,module,exports){\nvar _require = require('./domUtils');\n\nvar closest = _require.closest;\nvar parentNode = _require.parentNode;\nvar getElementRect = _require.getElementRect;\n\nvar _require2 = require('./isType');\n\nvar isElement = _require2.isElement;\nvar isFunction = _require2.isFunction;\nvar trySelector = _require2.trySelector;\n\nmodule.exports = function (interactable, element) {\n  var origin = interactable.options.origin;\n\n  if (origin === 'parent') {\n    origin = parentNode(element);\n  } else if (origin === 'self') {\n    origin = interactable.getRect(element);\n  } else if (trySelector(origin)) {\n    origin = closest(element, origin) || { x: 0, y: 0 };\n  }\n\n  if (isFunction(origin)) {\n    origin = origin(interactable && element);\n  }\n\n  if (isElement(origin)) {\n    origin = getElementRect(origin);\n  }\n\n  origin.x = 'x' in origin ? origin.x : origin.left;\n  origin.y = 'y' in origin ? origin.y : origin.top;\n\n  return origin;\n};\n\n},{\"./domUtils\":33,\"./isType\":40}],37:[function(require,module,exports){\nmodule.exports = function (x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n\n},{}],38:[function(require,module,exports){\nvar extend = require('./extend');\nvar win = require('./window');\n\nvar utils = {\n  warnOnce: function (method, message) {\n    var warned = false;\n\n    return function () {\n      if (!warned) {\n        win.window.console.warn(message);\n        warned = true;\n      }\n\n      return method.apply(this, arguments);\n    };\n  },\n\n  // http://stackoverflow.com/a/5634528/2280888\n  _getQBezierValue: function (t, p1, p2, p3) {\n    var iT = 1 - t;\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n  },\n\n  getQuadraticCurvePoint: function (startX, startY, cpX, cpY, endX, endY, position) {\n    return {\n      x: utils._getQBezierValue(position, startX, cpX, endX),\n      y: utils._getQBezierValue(position, startY, cpY, endY)\n    };\n  },\n\n  // http://gizma.com/easing/\n  easeOutQuad: function (t, b, c, d) {\n    t /= d;\n    return -c * t * (t - 2) + b;\n  },\n\n  copyAction: function (dest, src) {\n    dest.name = src.name;\n    dest.axis = src.axis;\n    dest.edges = src.edges;\n\n    return dest;\n  },\n\n  extend: extend,\n  hypot: require('./hypot'),\n  getOriginXY: require('./getOriginXY')\n};\n\nextend(utils, require('./arr'));\nextend(utils, require('./isType'));\nextend(utils, require('./domUtils'));\nextend(utils, require('./pointerUtils'));\n\nmodule.exports = utils;\n\n},{\"./arr\":30,\"./domUtils\":33,\"./extend\":35,\"./getOriginXY\":36,\"./hypot\":37,\"./isType\":40,\"./pointerUtils\":43,\"./window\":45}],39:[function(require,module,exports){\nvar scope = require('../scope');\nvar utils = require('./index');\nvar browser = require('./browser');\n\nvar finder = {\n  methodOrder: ['simulationResume', 'mouse', 'hasPointer', 'idle'],\n\n  search: function (pointer, eventType, eventTarget) {\n    var mouseEvent = /mouse/i.test(pointer.pointerType || eventType)\n    // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n     || pointer.pointerType === 4;\n    var pointerId = utils.getPointerId(pointer);\n    var details = { pointer: pointer, pointerId: pointerId, mouseEvent: mouseEvent, eventType: eventType, eventTarget: eventTarget };\n\n    for (var _iterator = finder.methodOrder, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var method = _ref;\n\n      var interaction = finder[method](details);\n\n      if (interaction) {\n        return interaction;\n      }\n    }\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume: function (_ref7) {\n    var mouseEvent = _ref7.mouseEvent;\n    var eventType = _ref7.eventType;\n    var eventTarget = _ref7.eventTarget;\n\n    if (!/down|start/i.test(eventType)) {\n      return null;\n    }\n\n    for (var _iterator2 = scope.interactions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var interaction = _ref2;\n\n      var element = eventTarget;\n\n      if (interaction.simulation && interaction.simulation.allowResume && interaction.mouse === mouseEvent) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction;\n          }\n          element = utils.parentNode(element);\n        }\n      }\n    }\n\n    return null;\n  },\n\n  // if it's a mouse interaction\n  mouse: function (_ref8) {\n    var pointerId = _ref8.pointerId;\n    var mouseEvent = _ref8.mouseEvent;\n    var eventType = _ref8.eventType;\n\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\n      return null;\n    }\n\n    var firstNonActive = undefined;\n\n    for (var _iterator3 = scope.interactions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var interaction = _ref3;\n\n      if (interaction.mouse) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) {\n          continue;\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction;\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n            firstNonActive = interaction;\n          }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive;\n    }\n\n    // Find any interaction specifically for mouse.\n    // ignore the interaction if the eventType is a mousedown, and a simulation\n    // is active\n    for (var _iterator4 = scope.interactions, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var interaction = _ref4;\n\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.simulation)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  },\n\n  // get interaction that has this pointer\n  hasPointer: function (_ref9) {\n    var pointerId = _ref9.pointerId;\n\n    for (var _iterator5 = scope.interactions, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray5) {\n        if (_i5 >= _iterator5.length) break;\n        _ref5 = _iterator5[_i5++];\n      } else {\n        _i5 = _iterator5.next();\n        if (_i5.done) break;\n        _ref5 = _i5.value;\n      }\n\n      var interaction = _ref5;\n\n      if (utils.contains(interaction.pointerIds, pointerId)) {\n        return interaction;\n      }\n    }\n  },\n\n  // get first idle interaction\n  idle: function (_ref10) {\n    var mouseEvent = _ref10.mouseEvent;\n\n    for (var _iterator6 = scope.interactions, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i6 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i6++];\n      } else {\n        _i6 = _iterator6.next();\n        if (_i6.done) break;\n        _ref6 = _i6.value;\n      }\n\n      var interaction = _ref6;\n\n      // if there's already a pointer held down\n      if (interaction.pointerIds.length === 1) {\n        var target = interaction.target;\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !target.options.gesture.enabled) {\n          continue;\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointerIds.length >= 2) {\n          continue;\n        }\n\n      if (!interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n        return interaction;\n      }\n    }\n\n    return null;\n  }\n};\n\nmodule.exports = finder;\n\n},{\"../scope\":28,\"./browser\":31,\"./index\":38}],40:[function(require,module,exports){\nvar win = require('./window');\nvar isWindow = require('./isWindow');\nvar domObjects = require('./domObjects');\n\nvar isType = {\n  isElement: function (o) {\n    if (!o || typeof o !== 'object') {\n      return false;\n    }\n\n    var _window = win.getWindow(o) || win.window;\n\n    return (/object|function/.test(typeof _window.Element) ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  },\n\n  isArray: null,\n\n  isWindow: function (thing) {\n    return thing === win.window || isWindow(thing);\n  },\n\n  isDocFrag: function (thing) {\n    return isType.isObject(thing) && thing.nodeType === 11;\n  },\n\n  isObject: function (thing) {\n    return !!thing && typeof thing === 'object';\n  },\n\n  isFunction: function (thing) {\n    return typeof thing === 'function';\n  },\n\n  isNumber: function (thing) {\n    return typeof thing === 'number';\n  },\n\n  isBool: function (thing) {\n    return typeof thing === 'boolean';\n  },\n\n  isString: function (thing) {\n    return typeof thing === 'string';\n  },\n\n  trySelector: function (value) {\n    if (!isType.isString(value)) {\n      return false;\n    }\n\n    // an exception will be raised if it is invalid\n    domObjects.document.querySelector(value);\n    return true;\n  }\n};\n\nisType.isArray = function (thing) {\n  return isType.isObject(thing) && typeof thing.length !== 'undefined' && isType.isFunction(thing.splice);\n};\n\nmodule.exports = isType;\n\n},{\"./domObjects\":32,\"./isWindow\":41,\"./window\":45}],41:[function(require,module,exports){\nmodule.exports = function (thing) {\n  return !!(thing && thing.Window) && thing instanceof thing.Window;\n};\n\n},{}],42:[function(require,module,exports){\nfunction pointerExtend(dest, source) {\n  for (var prop in source) {\n    var prefixedPropREs = module.exports.prefixedPropREs;\n    var deprecated = false;\n\n    // skip deprecated prefixed properties\n    for (var vendor in prefixedPropREs) {\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n        deprecated = true;\n        break;\n      }\n    }\n\n    if (!deprecated) {\n      dest[prop] = source[prop];\n    }\n  }\n  return dest;\n}\n\npointerExtend.prefixedPropREs = {\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n};\n\nmodule.exports = pointerExtend;\n\n},{}],43:[function(require,module,exports){\nvar hypot = require('./hypot');\nvar browser = require('./browser');\nvar dom = require('./domObjects');\nvar isType = require('./isType');\nvar pointerExtend = require('./pointerExtend');\n\nvar pointerUtils = {\n  copyCoords: function (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  },\n\n  setCoordDeltas: function (targetObj, prev, cur) {\n    targetObj.page.x = cur.page.x - prev.page.x;\n    targetObj.page.y = cur.page.y - prev.page.y;\n    targetObj.client.x = cur.client.x - prev.client.x;\n    targetObj.client.y = cur.client.y - prev.client.y;\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\n\n    // set pointer velocity\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\n    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx = targetObj.page.x / dt;\n    targetObj.page.vy = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx = targetObj.client.x / dt;\n    targetObj.client.vy = targetObj.client.y / dt;\n  },\n\n  isNativePointer: function (pointer) {\n    return pointer instanceof dom.Event || pointer instanceof dom.Touch;\n  },\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  getXY: function (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  },\n\n  getPageXY: function (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      pointerUtils.getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    } else {\n      pointerUtils.getXY('page', pointer, page);\n    }\n\n    return page;\n  },\n\n  getClientXY: function (pointer, client) {\n    client = client || {};\n\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      pointerUtils.getXY('screen', pointer, client);\n    } else {\n      pointerUtils.getXY('client', pointer, client);\n    }\n\n    return client;\n  },\n\n  getPointerId: function (pointer) {\n    return isType.isNumber(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n  },\n\n  setCoords: function (targetObj, pointers, timeStamp) {\n    var pointer = pointers.length > 1 ? pointerUtils.pointerAverage(pointers) : pointers[0];\n\n    var tmpXY = {};\n\n    pointerUtils.getPageXY(pointer, tmpXY);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    pointerUtils.getClientXY(pointer, tmpXY);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = isType.isNumber(timeStamp) ? timeStamp : new Date().getTime();\n  },\n\n  pointerExtend: pointerExtend,\n\n  getTouchPair: function (event) {\n    var touches = [];\n\n    // array of touches is supplied\n    if (isType.isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n        if (event.type === 'touchend') {\n          if (event.touches.length === 1) {\n            touches[0] = event.touches[0];\n            touches[1] = event.changedTouches[0];\n          } else if (event.touches.length === 0) {\n            touches[0] = event.changedTouches[0];\n            touches[1] = event.changedTouches[1];\n          }\n        } else {\n          touches[0] = event.touches[0];\n          touches[1] = event.touches[1];\n        }\n      }\n\n    return touches;\n  },\n\n  pointerAverage: function (pointers) {\n    var average = {\n      pageX: 0,\n      pageY: 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0\n    };\n\n    for (var _iterator = pointers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pointer = _ref;\n\n      for (var prop in average) {\n        average[prop] += pointer[prop];\n      }\n    }\n    for (var prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  },\n\n  touchBBox: function (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    var touches = pointerUtils.getTouchPair(event);\n    var minX = Math.min(touches[0].pageX, touches[1].pageX);\n    var minY = Math.min(touches[0].pageY, touches[1].pageY);\n    var maxX = Math.max(touches[0].pageX, touches[1].pageX);\n    var maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  },\n\n  touchDistance: function (event, deltaSource) {\n    deltaSource = deltaSource;\n\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var touches = pointerUtils.getTouchPair(event);\n\n    var dx = touches[0][sourceX] - touches[1][sourceX];\n    var dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  },\n\n  touchAngle: function (event, prevAngle, deltaSource) {\n    deltaSource = deltaSource;\n\n    var sourceX = deltaSource + 'X';\n    var sourceY = deltaSource + 'Y';\n    var touches = pointerUtils.getTouchPair(event);\n    var dx = touches[1][sourceX] - touches[0][sourceX];\n    var dy = touches[1][sourceY] - touches[0][sourceY];\n    var angle = 180 * Math.atan2(dy, dx) / Math.PI;\n\n    return angle;\n  }\n};\n\nmodule.exports = pointerUtils;\n\n},{\"./browser\":31,\"./domObjects\":32,\"./hypot\":37,\"./isType\":40,\"./pointerExtend\":42}],44:[function(require,module,exports){\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nvar lastTime = 0;\nvar request = undefined;\nvar cancel = undefined;\n\nfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\n  request = window[vendors[x] + 'RequestAnimationFrame'];\n  cancel = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!request) {\n  request = function (callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\nif (!cancel) {\n  cancel = function (id) {\n    clearTimeout(id);\n  };\n}\n\nmodule.exports = {\n  request: request,\n  cancel: cancel\n};\n\n},{}],45:[function(require,module,exports){\nvar win = module.exports;\nvar isWindow = require('./isWindow');\n\nfunction init(window) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  win.realWindow = window;\n\n  // create a TextNode\n  var el = window.document.createTextNode('');\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // return wrapped window\n    win.window = window.wrap(window);\n  }\n\n  // no Shadow DOM polyfil or native implementation\n  win.window = window;\n}\n\nif (typeof window === 'undefined') {\n  win.window = undefined;\n  win.realWindow = undefined;\n} else {\n  init(window);\n}\n\nwin.getWindow = function getWindow(node) {\n  if (isWindow(node)) {\n    return node;\n  }\n\n  var rootNode = node.ownerDocument || node;\n\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\n};\n\nwin.init = init;\n\n},{\"./isWindow\":41}]},{},[1])(1)\n});\n\n","const { indexOf } = require('./utils/arr');\r\n\r\nfunction fireUntilImmediateStopped (event, listeners) {\r\n  for (let i = 0, len = listeners.length; i < len && !event.immediatePropagationStopped; i++) {\r\n    listeners[i](event);\r\n  }\r\n}\r\n\r\nclass Eventable {\r\n  fire (event) {\r\n    let listeners;\r\n    const onEvent = 'on' + event.type;\r\n    const global = this.global;\r\n\r\n    // Interactable#on() listeners\r\n    if ((listeners = this[event.type])) {\r\n      fireUntilImmediateStopped(event, listeners);\r\n    }\r\n\r\n    // interactable.onevent listener\r\n    if (this[onEvent]) {\r\n      this[onEvent](event);\r\n    }\r\n\r\n    // interact.on() listeners\r\n    if (!event.propagationStopped && global && (listeners = global[event.type]))  {\r\n      fireUntilImmediateStopped(event, listeners);\r\n    }\r\n  }\r\n\r\n  on (eventType, listener) {\r\n    // if this type of event was never bound\r\n    if (!(eventType in this)) {\r\n      this[eventType] = [listener];\r\n    }\r\n    else {\r\n      this[eventType].push(listener);\r\n    }\r\n  }\r\n\r\n  off (eventType, listener) {\r\n    // if it is an action event type\r\n    const eventList = this[eventType];\r\n    const index     = eventList? indexOf(eventList, listener) : -1;\r\n\r\n    if (index !== -1) {\r\n      this[eventType].splice(index, 1);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Eventable;\r\n","const extend      = require('./utils/extend');\r\nconst getOriginXY = require('./utils/getOriginXY');\r\nconst defaults    = require('./defaultOptions');\r\nconst signals     = require('./utils/Signals').new();\r\n\r\nclass InteractEvent {\r\n  constructor (interaction, event, action, phase, element, related) {\r\n    const target      = interaction.target;\r\n    const deltaSource = (target && target.options || defaults).deltaSource;\r\n    const origin      = getOriginXY(target, element);\r\n    const starting    = phase === 'start';\r\n    const ending      = phase === 'end';\r\n    const coords      = starting? interaction.startCoords : interaction.curCoords;\r\n\r\n    element = element || interaction.element;\r\n\r\n    const page   = extend({}, coords.page);\r\n    const client = extend({}, coords.client);\r\n\r\n    page.x -= origin.x;\r\n    page.y -= origin.y;\r\n\r\n    client.x -= origin.x;\r\n    client.y -= origin.y;\r\n\r\n    this.ctrlKey       = event.ctrlKey;\r\n    this.altKey        = event.altKey;\r\n    this.shiftKey      = event.shiftKey;\r\n    this.metaKey       = event.metaKey;\r\n    this.button        = event.button;\r\n    this.buttons       = event.buttons;\r\n    this.target        = element;\r\n    this.currentTarget = element;\r\n    this.relatedTarget = related || null;\r\n    this.t0            = interaction.downTimes[interaction.downTimes.length - 1];\r\n    this.type          = action + (phase || '');\r\n    this.interaction   = interaction;\r\n    this.interactable  = target;\r\n\r\n    const signalArg = {\r\n      interaction,\r\n      event,\r\n      action,\r\n      phase,\r\n      element,\r\n      related,\r\n      page,\r\n      client,\r\n      coords,\r\n      starting,\r\n      ending,\r\n      deltaSource,\r\n      iEvent: this,\r\n    };\r\n\r\n    signals.fire('set-xy', signalArg);\r\n\r\n    if (ending) {\r\n      const prevEvent = interaction.prevEvent;\r\n\r\n      // use previous coords when ending\r\n      this.pageX = prevEvent.pageX;\r\n      this.pageY = prevEvent.pageY;\r\n      this.clientX = prevEvent.clientX;\r\n      this.clientY = prevEvent.clientY;\r\n    }\r\n    else {\r\n      this.pageX     = page.x;\r\n      this.pageY     = page.y;\r\n      this.clientX   = client.x;\r\n      this.clientY   = client.y;\r\n    }\r\n\r\n    this.x0        = interaction.startCoords.page.x - origin.x;\r\n    this.y0        = interaction.startCoords.page.y - origin.y;\r\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\r\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\r\n\r\n    signals.fire('set-delta', signalArg);\r\n\r\n    this.timeStamp = coords.timeStamp;\r\n    this.dt        = interaction.pointerDelta.timeStamp;\r\n    this.duration  = this.timeStamp - interaction.downTimes[0];\r\n\r\n    // speed and velocity in pixels per second\r\n    this.speed = interaction.pointerDelta[deltaSource].speed;\r\n    this.velocityX = interaction.pointerDelta[deltaSource].vx;\r\n    this.velocityY = interaction.pointerDelta[deltaSource].vy;\r\n\r\n    this.swipe = (ending || phase === 'inertiastart')? this.getSwipe() : null;\r\n\r\n    signals.fire('new', signalArg);\r\n  }\r\n\r\n  getSwipe () {\r\n    const interaction = this.interaction;\r\n\r\n    if (interaction.prevEvent.speed < 600\r\n        || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\r\n      return null;\r\n    }\r\n\r\n    let angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;\r\n    const overlap = 22.5;\r\n\r\n    if (angle < 0) {\r\n      angle += 360;\r\n    }\r\n\r\n    const left = 135 - overlap <= angle && angle < 225 + overlap;\r\n    const up   = 225 - overlap <= angle && angle < 315 + overlap;\r\n\r\n    const right = !left && (315 - overlap <= angle || angle <  45 + overlap);\r\n    const down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\r\n\r\n    return {\r\n      up,\r\n      down,\r\n      left,\r\n      right,\r\n      angle,\r\n      speed: interaction.prevEvent.speed,\r\n      velocity: {\r\n        x: interaction.prevEvent.velocityX,\r\n        y: interaction.prevEvent.velocityY,\r\n      },\r\n    };\r\n  }\r\n\r\n  preventDefault () {}\r\n\r\n  stopImmediatePropagation () {\r\n    this.immediatePropagationStopped = this.propagationStopped = true;\r\n  }\r\n\r\n  stopPropagation () {\r\n    this.propagationStopped = true;\r\n  }\r\n}\r\n\r\nsignals.on('set-delta', function ({ iEvent, interaction, starting, deltaSource }) {\r\n  const prevEvent = starting? iEvent : interaction.prevEvent;\r\n\r\n  if (deltaSource === 'client') {\r\n    iEvent.dx = iEvent.clientX - prevEvent.clientX;\r\n    iEvent.dy = iEvent.clientY - prevEvent.clientY;\r\n  }\r\n  else {\r\n    iEvent.dx = iEvent.pageX - prevEvent.pageX;\r\n    iEvent.dy = iEvent.pageY - prevEvent.pageY;\r\n  }\r\n});\r\n\r\nInteractEvent.signals = signals;\r\n\r\nmodule.exports = InteractEvent;\r\n","const isType    = require('./utils/isType');\r\nconst events    = require('./utils/events');\r\nconst extend    = require('./utils/extend');\r\nconst actions   = require('./actions');\r\nconst scope     = require('./scope');\r\nconst Eventable = require('./Eventable');\r\nconst defaults  = require('./defaultOptions');\r\nconst signals   = require('./utils/Signals').new();\r\n\r\nconst { getElementRect, nodeContains } = require('./utils/domUtils');\r\nconst { indexOf, contains }            = require('./utils/arr');\r\nconst { wheelEvent }                   = require('./utils/browser');\r\n\r\n// all set interactables\r\nscope.interactables = [];\r\n\r\n/*\\\r\n * Interactable\r\n [ property ]\r\n **\r\n * Object type returned by @interact\r\n\\*/\r\nclass Interactable {\r\n  constructor (target, options) {\r\n    this.target   = target;\r\n    this._context = scope.document;\r\n    this._iEvents = new Eventable();\r\n\r\n    let _window;\r\n\r\n    if (isType.trySelector(target)) {\r\n      this.target = target;\r\n\r\n      const context = options && options.context;\r\n\r\n      _window = context? scope.getWindow(context) : scope.window;\r\n\r\n      if (context && (_window.Node\r\n        ? context instanceof _window.Node\r\n        : (isType.isElement(context) || context === _window.document))) {\r\n\r\n        this._context = context;\r\n      }\r\n    }\r\n    else {\r\n      _window = scope.getWindow(target);\r\n    }\r\n\r\n    this._doc = _window.document;\r\n\r\n    signals.fire('new', {\r\n      target,\r\n      options,\r\n      interactable: this,\r\n      win: _window,\r\n    });\r\n\r\n    scope.addDocument( this._doc, _window );\r\n\r\n    scope.interactables.push(this);\r\n\r\n    this.set(options);\r\n  }\r\n\r\n  setOnEvents (action, phases) {\r\n    const onAction = 'on' + action;\r\n\r\n    if (isType.isFunction(phases.onstart)       ) { this._iEvents[onAction + 'start'        ] = phases.onstart         ; }\r\n    if (isType.isFunction(phases.onmove)        ) { this._iEvents[onAction + 'move'         ] = phases.onmove          ; }\r\n    if (isType.isFunction(phases.onend)         ) { this._iEvents[onAction + 'end'          ] = phases.onend           ; }\r\n    if (isType.isFunction(phases.oninertiastart)) { this._iEvents[onAction + 'inertiastart' ] = phases.oninertiastart  ; }\r\n\r\n    return this;\r\n  }\r\n\r\n  setPerAction (action, options) {\r\n    // for all the default per-action options\r\n    for (const option in options) {\r\n      // if this option exists for this action\r\n      if (option in defaults[action]) {\r\n        // if the option in the options arg is an object value\r\n        if (isType.isObject(options[option])) {\r\n          // duplicate the object\r\n          this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\r\n\r\n          if (isType.isObject(defaults.perAction[option]) && 'enabled' in defaults.perAction[option]) {\r\n            this.options[action][option].enabled = options[option].enabled === false? false : true;\r\n          }\r\n        }\r\n        else if (isType.isBool(options[option]) && isType.isObject(defaults.perAction[option])) {\r\n          this.options[action][option].enabled = options[option];\r\n        }\r\n        else if (options[option] !== undefined) {\r\n          // or if it's not undefined, do a plain assignment\r\n          this.options[action][option] = options[option];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.getRect\r\n   [ method ]\r\n   *\r\n   * The default function to get an Interactables bounding rect. Can be\r\n   * overridden using @Interactable.rectChecker.\r\n   *\r\n   - element (Element) #optional The element to measure.\r\n   = (object) The object's bounding rectangle.\r\n   o {\r\n   o     top   : 0,\r\n   o     left  : 0,\r\n   o     bottom: 0,\r\n   o     right : 0,\r\n   o     width : 0,\r\n   o     height: 0\r\n   o }\r\n  \\*/\r\n  getRect (element) {\r\n    element = element || this.target;\r\n\r\n    if (isType.isString(this.target) && !(isType.isElement(element))) {\r\n      element = this._context.querySelector(this.target);\r\n    }\r\n\r\n    return getElementRect(element);\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.rectChecker\r\n   [ method ]\r\n   *\r\n   * Returns or sets the function used to calculate the interactable's\r\n   * element's rectangle\r\n   *\r\n   - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\r\n   = (function | object) The checker function or this Interactable\r\n  \\*/\r\n  rectChecker (checker) {\r\n    if (isType.isFunction(checker)) {\r\n      this.getRect = checker;\r\n\r\n      return this;\r\n    }\r\n\r\n    if (checker === null) {\r\n      delete this.options.getRect;\r\n\r\n      return this;\r\n    }\r\n\r\n    return this.getRect;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.origin\r\n   [ method ]\r\n   *\r\n   * Gets or sets the origin of the Interactable's element.  The x and y\r\n   * of the origin will be subtracted from action event coordinates.\r\n   *\r\n   - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\r\n   * OR\r\n   - origin (Element) #optional An HTML or SVG Element whose rect will be used\r\n   **\r\n   = (object) The current origin or this Interactable\r\n  \\*/\r\n  origin (newValue) {\r\n    if (isType.trySelector(newValue)) {\r\n      this.options.origin = newValue;\r\n      return this;\r\n    }\r\n    else if (isType.isObject(newValue)) {\r\n      this.options.origin = newValue;\r\n      return this;\r\n    }\r\n\r\n    return this.options.origin;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.deltaSource\r\n   [ method ]\r\n   *\r\n   * Returns or sets the mouse coordinate types used to calculate the\r\n   * movement of the pointer.\r\n   *\r\n   - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\r\n   = (string | object) The current deltaSource or this Interactable\r\n  \\*/\r\n  deltaSource (newValue) {\r\n    if (newValue === 'page' || newValue === 'client') {\r\n      this.options.deltaSource = newValue;\r\n\r\n      return this;\r\n    }\r\n\r\n    return this.options.deltaSource;\r\n  }\r\n\r\n  cursorTarget (newValue){\r\n    this.options.cursorTarget = newValue;\r\n    return this;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.context\r\n   [ method ]\r\n   *\r\n   * Gets the selector context Node of the Interactable. The default is `window.document`.\r\n   *\r\n   = (Node) The context Node of this Interactable\r\n   **\r\n  \\*/\r\n  context () {\r\n    return this._context;\r\n  }\r\n\r\n  inContext (element) {\r\n    return (this._context === element.ownerDocument\r\n            || nodeContains(this._context, element));\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.fire\r\n   [ method ]\r\n   *\r\n   * Calls listeners for the given InteractEvent type bound globally\r\n   * and directly to this Interactable\r\n   *\r\n   - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\r\n   = (Interactable) this Interactable\r\n  \\*/\r\n  fire (iEvent) {\r\n    this._iEvents.fire(iEvent);\r\n\r\n    return this;\r\n  }\r\n\r\n  _onOffMultiple (method, eventType, listener, useCapture) {\r\n    if (isType.isString(eventType) && eventType.search(' ') !== -1) {\r\n      eventType = eventType.trim().split(/ +/);\r\n    }\r\n\r\n    if (isType.isArray(eventType)) {\r\n      for (let i = 0; i < eventType.length; i++) {\r\n        this[method](eventType[i], listener, useCapture);\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    if (isType.isObject(eventType)) {\r\n      for (const prop in eventType) {\r\n        this[method](prop, eventType[prop], listener);\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.on\r\n   [ method ]\r\n   *\r\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\r\n   *\r\n   - eventType  (string | array | object) The types of events to listen for\r\n   - listener   (function) The function event (s)\r\n   - useCapture (boolean) #optional useCapture flag for addEventListener\r\n   = (object) This Interactable\r\n  \\*/\r\n  on (eventType, listener, useCapture) {\r\n    // convert to boolean\r\n    useCapture = !!useCapture;\r\n\r\n    if (this._onOffMultiple('on', eventType, listener, useCapture)) {\r\n      return this;\r\n    }\r\n\r\n    if (eventType === 'wheel') { eventType = wheelEvent; }\r\n\r\n    if (contains(Interactable.eventTypes, eventType)) {\r\n      this._iEvents.on(eventType, listener);\r\n    }\r\n    // delegated event for selector\r\n    else if (isType.isString(this.target)) {\r\n      events.addDelegate(this.target, this._context, eventType, listener, useCapture);\r\n    }\r\n    else {\r\n      events.add(this.target, eventType, listener, useCapture);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.off\r\n   [ method ]\r\n   *\r\n   * Removes an InteractEvent, pointerEvent or DOM event listener\r\n   *\r\n   - eventType  (string | array | object) The types of events that were listened for\r\n   - listener   (function) The listener function to be removed\r\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\r\n   = (object) This Interactable\r\n  \\*/\r\n  off (eventType, listener, useCapture) {\r\n    // convert to boolean\r\n    useCapture = !!useCapture;\r\n\r\n    if (this._onOffMultiple('off', eventType, listener, useCapture)) {\r\n      return this;\r\n    }\r\n\r\n    if (eventType === 'wheel') { eventType = wheelEvent; }\r\n\r\n    // if it is an action event type\r\n    if (contains(Interactable.eventTypes, eventType)) {\r\n      this._iEvents.on(eventType, listener);\r\n    }\r\n    // delegated event\r\n    else if (isType.isString(this.target)) {\r\n      events.removeDelegate(this.target, this._context, eventType, listener, useCapture);\r\n    }\r\n    // remove listener from this Interatable's element\r\n    else {\r\n      events.remove(this.target, eventType, listener, useCapture);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.set\r\n   [ method ]\r\n   *\r\n   * Reset the options of this Interactable\r\n   - options (object) The new settings to apply\r\n   = (object) This Interactable\r\n  \\*/\r\n  set (options) {\r\n    if (!isType.isObject(options)) {\r\n      options = {};\r\n    }\r\n\r\n    this.options = extend({}, defaults.base);\r\n\r\n    const perActions = extend({}, defaults.perAction);\r\n\r\n    for (const actionName in actions.methodDict) {\r\n      const methodName = actions.methodDict[actionName];\r\n\r\n      this.options[actionName] = extend({}, defaults[actionName]);\r\n\r\n      this.setPerAction(actionName, perActions);\r\n\r\n      this[methodName](options[actionName]);\r\n    }\r\n\r\n    for (const setting of Interactable.settingsMethods) {\r\n      this.options[setting] = defaults.base[setting];\r\n\r\n      if (setting in options) {\r\n        this[setting](options[setting]);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /*\\\r\n   * Interactable.unset\r\n   [ method ]\r\n   *\r\n   * Remove this interactable from the list of interactables and remove\r\n   * it's action capabilities and event listeners\r\n   *\r\n   = (object) @interact\r\n  \\*/\r\n  unset () {\r\n    events.remove(this.target, 'all');\r\n\r\n    if (isType.isString(this.target)) {\r\n      // remove delegated events\r\n      for (const type in events.delegatedEvents) {\r\n        const delegated = events.delegatedEvents[type];\r\n\r\n        for (let i = 0; i < delegated.selectors.length; i++) {\r\n          if (delegated.selectors[i] === this.target\r\n              && delegated.contexts[i] === this._context) {\r\n\r\n            delegated.selectors.splice(i, 1);\r\n            delegated.contexts .splice(i, 1);\r\n            delegated.listeners.splice(i, 1);\r\n\r\n            // remove the arrays if they are empty\r\n            if (!delegated.selectors.length) {\r\n              delegated[type] = null;\r\n            }\r\n          }\r\n\r\n          events.remove(this._context, type, events.delegateListener);\r\n          events.remove(this._context, type, events.delegateUseCapture, true);\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      events.remove(this, 'all');\r\n    }\r\n\r\n    signals.fire('unset', { interactable: this });\r\n\r\n    scope.interactables.splice(indexOf(scope.interactables, this), 1);\r\n\r\n    // Stop related interactions when an Interactable is unset\r\n    for (const interaction of scope.interactions || []) {\r\n      if (interaction.target === this && interaction.interacting()) {\r\n        interaction.stop();\r\n      }\r\n    }\r\n\r\n    return scope.interact;\r\n  }\r\n}\r\n\r\nscope.interactables.indexOfElement = function indexOfElement (target, context) {\r\n  context = context || scope.document;\r\n\r\n  for (let i = 0; i < this.length; i++) {\r\n    const interactable = this[i];\r\n\r\n    if (interactable.target === target\r\n        && (!isType.isString(target) || (interactable._context === context))) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n};\r\n\r\nscope.interactables.get = function interactableGet (element, options) {\r\n  return this[this.indexOfElement(element, options && options.context)];\r\n};\r\n\r\nscope.interactables.forEachSelector = function (callback) {\r\n  for (let i = 0; i < this.length; i++) {\r\n    const interactable = this[i];\r\n\r\n    // skip non CSS selector targets\r\n    if (!isType.isString(interactable.target)) {\r\n      continue;\r\n    }\r\n\r\n    const ret = callback(interactable, interactable.target, interactable._context, i, this);\r\n\r\n    if (ret !== undefined) {\r\n      return ret;\r\n    }\r\n  }\r\n};\r\n\r\n// all interact.js eventTypes\r\nInteractable.eventTypes = scope.eventTypes = [];\r\n\r\nInteractable.signals = signals;\r\n\r\nInteractable.settingsMethods = [ 'deltaSource', 'origin', 'preventDefault', 'rectChecker',  'cursorTarget'];\r\n\r\nmodule.exports = Interactable;\r\n","const scope   = require('./scope');\r\nconst utils   = require('./utils');\r\nconst events  = require('./utils/events');\r\nconst browser = require('./utils/browser');\r\nconst finder  = require('./utils/interactionFinder');\r\nconst signals = require('./utils/Signals').new();\r\n\r\nconst listeners   = {};\r\nconst methodNames = [\r\n  'pointerDown', 'pointerMove', 'pointerUp',\r\n  'updatePointer', 'removePointer',\r\n];\r\n\r\n// for ignoring browser's simulated mouse events\r\nlet prevTouchTime = 0;\r\n\r\n// all active and idle interactions\r\nscope.interactions = [];\r\n\r\nclass Interaction {\r\n  constructor () {\r\n    this.target        = null; // current interactable being interacted with\r\n    this.element       = null; // the target element of the interactable\r\n\r\n    this.prepared      = {     // action that's ready to be fired on next move event\r\n      name : null,\r\n      axis : null,\r\n      edges: null,\r\n    };\r\n\r\n    // keep track of added pointers\r\n    this.pointers    = [];\r\n    this.pointerIds  = [];\r\n    this.downTargets = [];\r\n    this.downTimes   = [];\r\n    this.holdTimers  = [];\r\n\r\n    // Previous native pointer move event coordinates\r\n    this.prevCoords = {\r\n      page     : { x: 0, y: 0 },\r\n      client   : { x: 0, y: 0 },\r\n      timeStamp: 0,\r\n    };\r\n    // current native pointer move event coordinates\r\n    this.curCoords = {\r\n      page     : { x: 0, y: 0 },\r\n      client   : { x: 0, y: 0 },\r\n      timeStamp: 0,\r\n    };\r\n\r\n    // Starting InteractEvent pointer coordinates\r\n    this.startCoords = {\r\n      page     : { x: 0, y: 0 },\r\n      client   : { x: 0, y: 0 },\r\n      timeStamp: 0,\r\n    };\r\n\r\n    // Change in coordinates and time of the pointer\r\n    this.pointerDelta = {\r\n      page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\r\n      client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\r\n      timeStamp: 0,\r\n    };\r\n\r\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\r\n    this.downPointer = {};\r\n\r\n    this._eventTarget    = null;\r\n    this._curEventTarget = null;\r\n\r\n    this.prevEvent = null;      // previous action event\r\n\r\n    this.pointerIsDown   = false;\r\n    this.pointerWasMoved = false;\r\n    this._interacting    = false;\r\n\r\n    this.mouse = false;\r\n\r\n    signals.fire('new', this);\r\n\r\n    scope.interactions.push(this);\r\n  }\r\n\r\n  pointerDown (pointer, event, eventTarget) {\r\n    const pointerIndex = this.updatePointer(pointer);\r\n\r\n    this.pointerIsDown = true;\r\n\r\n    if (!this.interacting()) {\r\n      utils.setCoords(this.startCoords, this.pointers);\r\n\r\n      utils.copyCoords(this.curCoords , this.startCoords);\r\n      utils.copyCoords(this.prevCoords, this.startCoords);\r\n\r\n      this.downEvent = event;\r\n\r\n      this.downTimes[pointerIndex] = this.curCoords.timeStamp;\r\n      this.downTargets[pointerIndex] = eventTarget;\r\n\r\n      this.pointerWasMoved = false;\r\n\r\n      utils.pointerExtend(this.downPointer, pointer);\r\n    }\r\n\r\n    signals.fire('down', {\r\n      pointer,\r\n      event,\r\n      eventTarget,\r\n      pointerIndex,\r\n      interaction: this,\r\n    });\r\n  }\r\n\r\n  /*\\\r\n   * Interaction.start\r\n   [ method ]\r\n   *\r\n   * Start an action with the given Interactable and Element as tartgets. The\r\n   * action must be enabled for the target Interactable and an appropriate number\r\n   * of pointers must be held down - 1 for drag/resize, 2 for gesture.\r\n   *\r\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\r\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\r\n   *\r\n   - action  (object)  The action to be performed - drag, resize, etc.\r\n   - target  (Interactable) The Interactable to target\r\n   - element (Element) The DOM Element to target\r\n   = (object) interact\r\n   **\r\n   | interact(target)\r\n   |   .draggable({\r\n   |     // disable the default drag start by down->move\r\n   |     manualStart: true\r\n   |   })\r\n   |   // start dragging after the user holds the pointer down\r\n   |   .on('hold', function (event) {\r\n   |     var interaction = event.interaction;\r\n   |\r\n   |     if (!interaction.interacting()) {\r\n   |       interaction.start({ name: 'drag' },\r\n   |                         event.interactable,\r\n   |                         event.currentTarget);\r\n   |     }\r\n   | });\r\n   \\*/\r\n  start (action, target, element) {\r\n    if (this.interacting()\r\n        || !this.pointerIsDown\r\n        || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\r\n      return;\r\n    }\r\n\r\n    // if this interaction had been removed after stopping\r\n    // add it back\r\n    if (utils.indexOf(scope.interactions, this) === -1) {\r\n      scope.interactions.push(this);\r\n    }\r\n\r\n    utils.copyAction(this.prepared, action);\r\n    this.target         = target;\r\n    this.element        = element;\r\n\r\n    signals.fire('action-start', {\r\n      interaction: this,\r\n      event: this.downEvent,\r\n    });\r\n  }\r\n\r\n  pointerMove (pointer, event, eventTarget) {\r\n    if (!this.simulation) {\r\n      this.updatePointer(pointer);\r\n      utils.setCoords(this.curCoords, this.pointers);\r\n    }\r\n\r\n    const duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\r\n                           && this.curCoords.page.y === this.prevCoords.page.y\r\n                           && this.curCoords.client.x === this.prevCoords.client.x\r\n                           && this.curCoords.client.y === this.prevCoords.client.y);\r\n\r\n    let dx;\r\n    let dy;\r\n\r\n    // register movement greater than pointerMoveTolerance\r\n    if (this.pointerIsDown && !this.pointerWasMoved) {\r\n      dx = this.curCoords.client.x - this.startCoords.client.x;\r\n      dy = this.curCoords.client.y - this.startCoords.client.y;\r\n\r\n      this.pointerWasMoved = utils.hypot(dx, dy) > Interaction.pointerMoveTolerance;\r\n    }\r\n\r\n    const signalArg = {\r\n      pointer,\r\n      event,\r\n      eventTarget,\r\n      dx,\r\n      dy,\r\n      duplicate: duplicateMove,\r\n      interaction: this,\r\n      interactingBeforeMove: this.interacting(),\r\n    };\r\n\r\n    if (!duplicateMove) {\r\n      // set pointer coordinate, time changes and speeds\r\n      utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\r\n    }\r\n\r\n    signals.fire('move', signalArg);\r\n\r\n    if (!duplicateMove) {\r\n      // if interacting, fire an 'action-move' signal etc\r\n      if (this.interacting()) {\r\n        this.doMove(signalArg);\r\n      }\r\n\r\n      if (this.pointerWasMoved) {\r\n        utils.copyCoords(this.prevCoords, this.curCoords);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\\\r\n   * Interaction.doMove\r\n   [ method ]\r\n   *\r\n   * Force a move of the current action at the same coordinates. Useful if\r\n   * snap/restrict has been changed and you want a movement with the new\r\n   * settings.\r\n   *\r\n   **\r\n   | interact(target)\r\n   |   .draggable(true)\r\n   |   .on('dragmove', function (event) {\r\n   |     if (someCondition) {\r\n   |       // change the snap settings\r\n   |       event.interactable.draggable({ snap: { targets: [] }});\r\n   |       // fire another move event with re-calculated snap\r\n   |       event.interaction.doMove();\r\n   |     }\r\n   |   });\r\n   \\*/\r\n  doMove (signalArg) {\r\n    signalArg = utils.extend({\r\n      pointer: this.pointers[0],\r\n      event: this.prevEvent,\r\n      eventTarget: this._eventTarget,\r\n      interaction: this,\r\n    }, signalArg || {});\r\n\r\n    signals.fire('before-action-move', signalArg);\r\n\r\n    if (!this._dontFireMove) {\r\n      signals.fire('action-move', signalArg);\r\n    }\r\n\r\n    this._dontFireMove = false;\r\n  }\r\n\r\n  // End interact move events and stop auto-scroll unless simulation is running\r\n  pointerUp (pointer, event, eventTarget, curEventTarget) {\r\n    const pointerIndex = this.mouse? 0 : utils.indexOf(this.pointerIds, utils.getPointerId(pointer));\r\n\r\n    clearTimeout(this.holdTimers[pointerIndex]);\r\n\r\n    signals.fire(/cancel$/i.test(event.type)? 'cancel' : 'up', {\r\n      pointer,\r\n      event,\r\n      eventTarget,\r\n      curEventTarget,\r\n      interaction: this,\r\n    });\r\n\r\n    if (!this.simulation) {\r\n      this.end(event);\r\n    }\r\n\r\n    this.removePointer(pointer);\r\n  }\r\n\r\n  /*\\\r\n   * Interaction.end\r\n   [ method ]\r\n   *\r\n   * Stop the current action and fire an end event. Inertial movement does\r\n   * not happen.\r\n   *\r\n   - event (PointerEvent) #optional\r\n   **\r\n   | interact(target)\r\n   |   .draggable(true)\r\n   |   .on('move', function (event) {\r\n   |     if (event.pageX > 1000) {\r\n   |       // end the current action\r\n   |       event.interaction.end();\r\n   |       // stop all further listeners from being called\r\n   |       event.stopImmediatePropagation();\r\n   |     }\r\n   |   });\r\n   \\*/\r\n  end (event) {\r\n    event = event || this.prevEvent;\r\n\r\n    if (this.interacting()) {\r\n      signals.fire('action-end', {\r\n        event,\r\n        interaction: this,\r\n      });\r\n    }\r\n\r\n    this.stop();\r\n  }\r\n\r\n  currentAction () {\r\n    return this._interacting? this.prepared.name: null;\r\n  }\r\n\r\n  interacting () {\r\n    return this._interacting;\r\n  }\r\n\r\n  stop () {\r\n    signals.fire('stop', { interaction: this });\r\n\r\n    if (this._interacting) {\r\n      signals.fire('stop-active', { interaction: this });\r\n      signals.fire('stop-' + this.prepared.name, { interaction: this });\r\n    }\r\n\r\n    this.target = this.element = null;\r\n\r\n    this.pointerIsDown = this._interacting = false;\r\n    this.prepared.name = this.prevEvent = null;\r\n  }\r\n\r\n  updatePointer (pointer) {\r\n    const id = utils.getPointerId(pointer);\r\n    let index = this.mouse? 0 : utils.indexOf(this.pointerIds, id);\r\n\r\n    if (index === -1) {\r\n      index = this.pointerIds.length;\r\n    }\r\n\r\n    this.pointerIds[index] = id;\r\n    this.pointers[index] = pointer;\r\n\r\n    return index;\r\n  }\r\n\r\n  removePointer (pointer) {\r\n    const id = utils.getPointerId(pointer);\r\n    const index = this.mouse? 0 : utils.indexOf(this.pointerIds, id);\r\n\r\n    if (index === -1) { return; }\r\n\r\n    this.pointers   .splice(index, 1);\r\n    this.pointerIds .splice(index, 1);\r\n    this.downTargets.splice(index, 1);\r\n    this.downTimes  .splice(index, 1);\r\n    this.holdTimers .splice(index, 1);\r\n  }\r\n\r\n  _updateEventTargets (target, currentTarget) {\r\n    this._eventTarget    = target;\r\n    this._curEventTarget = currentTarget;\r\n  }\r\n}\r\n\r\nfor (let i = 0, len = methodNames.length; i < len; i++) {\r\n  const method = methodNames[i];\r\n\r\n  listeners[method] = doOnInteractions(method);\r\n}\r\n\r\nfunction doOnInteractions (method) {\r\n  return (function (event) {\r\n    const eventTarget = utils.getActualElement(event.path ? event.path[0] : event.target);\r\n    const curEventTarget = utils.getActualElement(event.currentTarget);\r\n    const matches = []; // [ [pointer, interaction], ...]\r\n\r\n    if (browser.supportsTouch && /touch/.test(event.type)) {\r\n      prevTouchTime = new Date().getTime();\r\n\r\n      for (let i = 0; i < event.changedTouches.length; i++) {\r\n        const pointer = event.changedTouches[i];\r\n        const interaction = finder.search(pointer, event.type, eventTarget);\r\n\r\n        matches.push([pointer, interaction || new Interaction()]);\r\n      }\r\n    }\r\n    else {\r\n      let invalidPointer = false;\r\n\r\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\r\n        // ignore mouse events while touch interactions are active\r\n        for (let i = 0; i < scope.interactions.length && !invalidPointer; i++) {\r\n          invalidPointer = !scope.interactions[i].mouse && scope.interactions[i].pointerIsDown;\r\n        }\r\n\r\n        // try to ignore mouse events that are simulated by the browser\r\n        // after a touch event\r\n        invalidPointer = invalidPointer || (new Date().getTime() - prevTouchTime < 500);\r\n      }\r\n\r\n      if (!invalidPointer) {\r\n        let interaction = finder.search(event, event.type, eventTarget);\r\n\r\n        if (!interaction) {\r\n\r\n          interaction = new Interaction();\r\n          interaction.mouse = (/mouse/i.test(event.pointerType || event.type)\r\n                               // MSPointerEvent.MSPOINTER_TYPE_MOUSE\r\n                               || event.pointerType === 4);\r\n        }\r\n\r\n        matches.push([event, interaction]);\r\n      }\r\n    }\r\n\r\n    for (const [pointer, interaction] of matches) {\r\n      interaction._updateEventTargets(eventTarget, curEventTarget);\r\n      interaction[method](pointer, event, eventTarget, curEventTarget);\r\n    }\r\n  });\r\n}\r\n\r\nfunction endAll (event) {\r\n  for (let i = 0; i < scope.interactions.length; i++) {\r\n    scope.interactions[i].end(event);\r\n  }\r\n}\r\n\r\nconst docEvents = { /* 'eventType': listenerFunc */ };\r\nconst pEventTypes = browser.pEventTypes;\r\n\r\nif (scope.PointerEvent) {\r\n  docEvents[pEventTypes.down  ] = listeners.pointerDown;\r\n  docEvents[pEventTypes.move  ] = listeners.pointerMove;\r\n  docEvents[pEventTypes.up    ] = listeners.pointerUp;\r\n  docEvents[pEventTypes.cancel] = listeners.pointerUp;\r\n}\r\nelse {\r\n  docEvents.mousedown   = listeners.pointerDown;\r\n  docEvents.mousemove   = listeners.pointerMove;\r\n  docEvents.mouseup     = listeners.pointerUp;\r\n\r\n  docEvents.touchstart  = listeners.pointerDown;\r\n  docEvents.touchmove   = listeners.pointerMove;\r\n  docEvents.touchend    = listeners.pointerUp;\r\n  docEvents.touchcancel = listeners.pointerUp;\r\n}\r\n\r\ndocEvents.blur = endAll;\r\n\r\nfunction onDocSignal ({ doc }, signalName) {\r\n  const eventMethod = signalName.indexOf('add') === 0\r\n    ? events.add : events.remove;\r\n\r\n  // delegate event listener\r\n  for (const eventType in scope.delegatedEvents) {\r\n    eventMethod(doc, eventType, events.delegateListener);\r\n    eventMethod(doc, eventType, events.delegateUseCapture, true);\r\n  }\r\n\r\n  for (const eventType in docEvents) {\r\n    eventMethod(doc, eventType, docEvents[eventType]);\r\n  }\r\n}\r\n\r\nscope.signals.on('add-document'   , onDocSignal);\r\nscope.signals.on('remove-document', onDocSignal);\r\n\r\nInteraction.pointerMoveTolerance = 1;\r\nInteraction.doOnInteractions = doOnInteractions;\r\nInteraction.endAll = endAll;\r\nInteraction.signals = signals;\r\nInteraction.docEvents = docEvents;\r\n\r\nscope.endAllInteractions = endAll;\r\n\r\nmodule.exports = Interaction;\r\n","const actions        = require('./index');\r\nconst utils          = require('../utils');\r\nconst InteractEvent  = require('../InteractEvent');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst drag = {\r\n  defaults: {\r\n    enabled   : false,\r\n\r\n    snap      : null,\r\n    restrict  : null,\r\n    inertia   : null,\r\n    autoScroll: null,\r\n\r\n    startAxis : 'xy',\r\n    lockAxis  : 'xy',\r\n  },\r\n\r\n  checker: function (pointer, event, interactable) {\r\n    const dragOptions = interactable.options.drag;\r\n\r\n    return dragOptions.enabled\r\n      ? { name: 'drag', axis: (dragOptions.lockAxis === 'start'\r\n                               ? dragOptions.startAxis\r\n                               : dragOptions.lockAxis)}\r\n      : null;\r\n  },\r\n\r\n  getCursor: function () {\r\n    return 'move';\r\n  },\r\n};\r\n\r\nInteraction.signals.on('action-start', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  const dragEvent = new InteractEvent(interaction, event, 'drag', 'start', interaction.element);\r\n\r\n  interaction._interacting = true;\r\n  interaction.target.fire(dragEvent);\r\n  interaction.prevEvent = dragEvent;\r\n});\r\n\r\nInteraction.signals.on('before-action-move', function ({ interaction }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  const axis = interaction.prepared.axis;\r\n\r\n  if (axis === 'x') {\r\n    interaction.curCoords.page.y   = interaction.startCoords.page.y;\r\n    interaction.curCoords.client.y = interaction.startCoords.client.y;\r\n\r\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vx);\r\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vx);\r\n    interaction.pointerDelta.client.vy = 0;\r\n    interaction.pointerDelta.page.vy   = 0;\r\n  }\r\n  else if (axis === 'y') {\r\n    interaction.curCoords.page.x   = interaction.startCoords.page.x;\r\n    interaction.curCoords.client.x = interaction.startCoords.client.x;\r\n\r\n    interaction.pointerDelta.page.speed   = Math.abs(interaction.pointerDelta.page.vy);\r\n    interaction.pointerDelta.client.speed = Math.abs(interaction.pointerDelta.client.vy);\r\n    interaction.pointerDelta.client.vx = 0;\r\n    interaction.pointerDelta.page.vx   = 0;\r\n  }\r\n});\r\n\r\nInteraction.signals.on('action-move', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  const dragEvent = new InteractEvent(interaction, event, 'drag', 'move', interaction.element);\r\n\r\n  const axis = interaction.prepared.axis;\r\n\r\n  if (axis === 'x') {\r\n    dragEvent.pageY   = interaction.startCoords.page.y;\r\n    dragEvent.clientY = interaction.startCoords.client.y;\r\n    dragEvent.dy = 0;\r\n  }\r\n  else if (axis === 'y') {\r\n    dragEvent.pageX   = interaction.startCoords.page.x;\r\n    dragEvent.clientX = interaction.startCoords.client.x;\r\n    dragEvent.dx = 0;\r\n  }\r\n\r\n  interaction.target.fire(dragEvent);\r\n  interaction.prevEvent = dragEvent;\r\n\r\n  // if the action was ended in a dragmove listener\r\n  if (!interaction.interacting()) { return false; }\r\n});\r\n\r\nInteraction.signals.on('action-end', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  const dragEvent = new InteractEvent(interaction, event, 'drag', 'end', interaction.element);\r\n\r\n  interaction.target.fire(dragEvent);\r\n  interaction.prevEvent = dragEvent;\r\n});\r\n\r\n/*\\\r\n * Interactable.draggable\r\n [ method ]\r\n *\r\n * Gets or sets whether drag actions can be performed on the\r\n * Interactable\r\n *\r\n = (boolean) Indicates if this can be the target of drag events\r\n | var isDraggable = interact('ul li').draggable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\r\n = (object) This Interactable\r\n | interact(element).draggable({\r\n |     onstart: function (event) {},\r\n |     onmove : function (event) {},\r\n |     onend  : function (event) {},\r\n |\r\n |     // the axis in which the first movement must be\r\n |     // for the drag sequence to start\r\n |     // 'xy' by default - any direction\r\n |     startAxis: 'x' || 'y' || 'xy',\r\n |\r\n |     // 'xy' by default - don't restrict to one axis (move in any direction)\r\n |     // 'x' or 'y' to restrict movement to either axis\r\n |     // 'start' to restrict movement to the axis the drag started in\r\n |     lockAxis: 'x' || 'y' || 'xy' || 'start',\r\n |\r\n |     // max number of drags that can happen concurrently\r\n |     // with elements of this Interactable. Infinity by default\r\n |     max: Infinity,\r\n |\r\n |     // max number of drags that can target the same element+Interactable\r\n |     // 1 by default\r\n |     maxPerElement: 2\r\n | });\r\n\\*/\r\nInteractable.prototype.draggable = function (options) {\r\n  if (utils.isObject(options)) {\r\n    this.options.drag.enabled = options.enabled === false? false: true;\r\n    this.setPerAction('drag', options);\r\n    this.setOnEvents('drag', options);\r\n\r\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\r\n      this.options.drag.lockAxis = options.lockAxis;\r\n    }\r\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\r\n      this.options.drag.startAxis = options.startAxis;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.isBool(options)) {\r\n    this.options.drag.enabled = options;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.drag;\r\n};\r\n\r\nactions.drag = drag;\r\nactions.names.push('drag');\r\nutils.merge(Interactable.eventTypes, [\r\n  'dragstart',\r\n  'dragmove',\r\n  'draginertiastart',\r\n  'draginertiaresume',\r\n  'dragend',\r\n]);\r\nactions.methodDict.drag = 'draggable';\r\n\r\ndefaultOptions.drag = drag.defaults;\r\n\r\nmodule.exports = drag;\r\n","const actions        = require('./index');\r\nconst utils          = require('../utils');\r\nconst scope          = require('../scope');\r\nconst interact       = require('../interact');\r\nconst InteractEvent  = require('../InteractEvent');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst drop = {\r\n  defaults: {\r\n    enabled: false,\r\n    accept : null,\r\n    overlap: 'pointer',\r\n  },\r\n};\r\n\r\nlet dynamicDrop = false;\r\n\r\nInteraction.signals.on('action-start', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  // reset active dropzones\r\n  interaction.activeDrops.dropzones = [];\r\n  interaction.activeDrops.elements  = [];\r\n  interaction.activeDrops.rects     = [];\r\n\r\n  interaction.dropEvents = null;\r\n\r\n  if (!interaction.dynamicDrop) {\r\n    setActiveDrops(interaction, interaction.element);\r\n  }\r\n\r\n  const dragEvent = interaction.prevEvent;\r\n  const dropEvents = getDropEvents(interaction, event, dragEvent);\r\n\r\n  if (dropEvents.activate) {\r\n    fireActiveDrops(interaction, dropEvents.activate);\r\n  }\r\n});\r\n\r\nInteractEvent.signals.on('new', function ({ interaction, iEvent, event }) {\r\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return; }\r\n\r\n  const draggableElement = interaction.element;\r\n  const dragEvent = iEvent;\r\n  const dropResult = getDrop(dragEvent, event, draggableElement);\r\n\r\n  interaction.dropTarget  = dropResult.dropzone;\r\n  interaction.dropElement = dropResult.element;\r\n\r\n  interaction.dropEvents = getDropEvents(interaction, event, dragEvent);\r\n});\r\n\r\nInteraction.signals.on('action-move', function ({ interaction }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  fireDropEvents(interaction, interaction.dropEvents);\r\n});\r\n\r\nInteraction.signals.on('action-end', function ({ interaction }) {\r\n  if (interaction.prepared.name === 'drag') {\r\n    fireDropEvents(interaction, interaction.dropEvents);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('stop-drag', function ({ interaction }) {\r\n  interaction.activeDrops.dropzones =\r\n    interaction.activeDrops.elements =\r\n    interaction.activeDrops.rects =\r\n    interaction.dropEvents = null;\r\n});\r\n\r\nfunction collectDrops (interaction, element) {\r\n  const drops = [];\r\n  const elements = [];\r\n\r\n  element = element || interaction.element;\r\n\r\n  // collect all dropzones and their elements which qualify for a drop\r\n  for (const current of scope.interactables) {\r\n    if (!current.options.drop.enabled) { continue; }\r\n\r\n    const accept = current.options.drop.accept;\r\n\r\n    // test the draggable element against the dropzone's accept setting\r\n    if ((utils.isElement(accept) && accept !== element)\r\n        || (utils.isString(accept)\r\n        && !utils.matchesSelector(element, accept))) {\r\n\r\n      continue;\r\n    }\r\n\r\n    // query for new elements if necessary\r\n    const dropElements = utils.isString(current.target)\r\n      ? current._context.querySelectorAll(current.target)\r\n      : [current.target];\r\n\r\n    for (let i = 0; i < dropElements.length; i++) {\r\n      const currentElement = dropElements[i];\r\n\r\n      if (currentElement !== element) {\r\n        drops.push(current);\r\n        elements.push(currentElement);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    elements,\r\n    dropzones: drops,\r\n  };\r\n}\r\n\r\nfunction fireActiveDrops (interaction, event) {\r\n  let prevElement;\r\n\r\n  // loop through all active dropzones and trigger event\r\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\r\n    const current = interaction.activeDrops.dropzones[i];\r\n    const currentElement = interaction.activeDrops.elements [i];\r\n\r\n    // prevent trigger of duplicate events on same element\r\n    if (currentElement !== prevElement) {\r\n      // set current element as event target\r\n      event.target = currentElement;\r\n      current.fire(event);\r\n    }\r\n    prevElement = currentElement;\r\n  }\r\n}\r\n\r\n// Collect a new set of possible drops and save them in activeDrops.\r\n// setActiveDrops should always be called when a drag has just started or a\r\n// drag event happens while dynamicDrop is true\r\nfunction setActiveDrops (interaction, dragElement) {\r\n  // get dropzones and their elements that could receive the draggable\r\n  const possibleDrops = collectDrops(interaction, dragElement, true);\r\n\r\n  interaction.activeDrops.dropzones = possibleDrops.dropzones;\r\n  interaction.activeDrops.elements  = possibleDrops.elements;\r\n  interaction.activeDrops.rects     = [];\r\n\r\n  for (let i = 0; i < interaction.activeDrops.dropzones.length; i++) {\r\n    interaction.activeDrops.rects[i] =\r\n      interaction.activeDrops.dropzones[i].getRect(interaction.activeDrops.elements[i]);\r\n  }\r\n}\r\n\r\nfunction getDrop (dragEvent, event, dragElement) {\r\n  const interaction = dragEvent.interaction;\r\n  const validDrops = [];\r\n\r\n  if (dynamicDrop) {\r\n    setActiveDrops(interaction, dragElement);\r\n  }\r\n\r\n  // collect all dropzones and their elements which qualify for a drop\r\n  for (let j = 0; j < interaction.activeDrops.dropzones.length; j++) {\r\n    const current        = interaction.activeDrops.dropzones[j];\r\n    const currentElement = interaction.activeDrops.elements [j];\r\n    const rect           = interaction.activeDrops.rects    [j];\r\n\r\n    validDrops.push(current.dropCheck(dragEvent, event, interaction.target, dragElement, currentElement, rect)\r\n      ? currentElement\r\n      : null);\r\n  }\r\n\r\n  // get the most appropriate dropzone based on DOM depth and order\r\n  const dropIndex = utils.indexOfDeepestElement(validDrops);\r\n\r\n  return {\r\n    dropzone: interaction.activeDrops.dropzones[dropIndex] || null,\r\n    element : interaction.activeDrops.elements [dropIndex] || null,\r\n  };\r\n}\r\n\r\nfunction getDropEvents (interaction, pointerEvent, dragEvent) {\r\n  const dropEvents = {\r\n    enter     : null,\r\n    leave     : null,\r\n    activate  : null,\r\n    deactivate: null,\r\n    move      : null,\r\n    drop      : null,\r\n  };\r\n\r\n  const tmpl = {\r\n    dragEvent,\r\n    interaction,\r\n    target       : interaction.dropElement,\r\n    dropzone     : interaction.dropTarget,\r\n    relatedTarget: dragEvent.target,\r\n    draggable    : dragEvent.interactable,\r\n    timeStamp    : dragEvent.timeStamp,\r\n  };\r\n\r\n  if (interaction.dropElement !== interaction.prevDropElement) {\r\n    // if there was a prevDropTarget, create a dragleave event\r\n    if (interaction.prevDropTarget) {\r\n      dropEvents.leave = utils.extend({ type: 'dragleave' }, tmpl);\r\n\r\n      dragEvent.dragLeave    = dropEvents.leave.target   = interaction.prevDropElement;\r\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = interaction.prevDropTarget;\r\n    }\r\n    // if the dropTarget is not null, create a dragenter event\r\n    if (interaction.dropTarget) {\r\n      dropEvents.enter = {\r\n        dragEvent,\r\n        interaction,\r\n        target       : interaction.dropElement,\r\n        dropzone     : interaction.dropTarget,\r\n        relatedTarget: dragEvent.target,\r\n        draggable    : dragEvent.interactable,\r\n        timeStamp    : dragEvent.timeStamp,\r\n        type         : 'dragenter',\r\n      };\r\n\r\n      dragEvent.dragEnter = interaction.dropElement;\r\n      dragEvent.dropzone = interaction.dropTarget;\r\n    }\r\n  }\r\n\r\n  if (dragEvent.type === 'dragend' && interaction.dropTarget) {\r\n    dropEvents.drop = utils.extend({ type: 'drop' }, tmpl);\r\n\r\n    dragEvent.dropzone = interaction.dropTarget;\r\n    dragEvent.relatedTarget = interaction.dropElement;\r\n  }\r\n  if (dragEvent.type === 'dragstart') {\r\n    dropEvents.activate = utils.extend({ type: 'dropactivate' }, tmpl);\r\n\r\n    dropEvents.activate.target   = null;\r\n    dropEvents.activate.dropzone = null;\r\n  }\r\n  if (dragEvent.type === 'dragend') {\r\n    dropEvents.deactivate = utils.extend({ type: 'dropdeactivate' }, tmpl);\r\n\r\n    dropEvents.deactivate.target   = null;\r\n    dropEvents.deactivate.dropzone = null;\r\n  }\r\n  if (dragEvent.type === 'dragmove' && interaction.dropTarget) {\r\n    dropEvents.move = utils.extend({\r\n      dragmove     : dragEvent,\r\n      type         : 'dropmove',\r\n    }, tmpl);\r\n\r\n    dragEvent.dropzone = interaction.dropTarget;\r\n  }\r\n\r\n  return dropEvents;\r\n}\r\n\r\nfunction fireDropEvents (interaction, dropEvents) {\r\n  if (dropEvents.leave) { interaction.prevDropTarget.fire(dropEvents.leave); }\r\n  if (dropEvents.enter) {     interaction.dropTarget.fire(dropEvents.enter); }\r\n  if (dropEvents.drop ) {     interaction.dropTarget.fire(dropEvents.drop ); }\r\n  if (dropEvents.deactivate) {\r\n    fireActiveDrops(interaction, dropEvents.deactivate);\r\n  }\r\n\r\n  interaction.prevDropTarget  = interaction.dropTarget;\r\n  interaction.prevDropElement = interaction.dropElement;\r\n}\r\n\r\n/*\\\r\n * Interactable.dropzone\r\n [ method ]\r\n *\r\n * Returns or sets whether elements can be dropped onto this\r\n * Interactable to trigger drop events\r\n *\r\n * Dropzones can receive the following events:\r\n *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\r\n *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\r\n *  - `dragmove` when a draggable that has entered the dropzone is moved\r\n *  - `drop` when a draggable is dropped into this dropzone\r\n *\r\n * Use the `accept` option to allow only elements that match the given CSS\r\n * selector or element. The value can be:\r\n *\r\n *  - **an Element** - only that element can be dropped into this dropzone.\r\n *  - **a string**, - the element being dragged must match it as a CSS selector.\r\n *  - **`null`** - accept options is cleared - it accepts any element.\r\n *\r\n * Use the `overlap` option to set how drops are checked for. The allowed\r\n * values are:\r\n *\r\n *   - `'pointer'`, the pointer must be over the dropzone (default)\r\n *   - `'center'`, the draggable element's center must be over the dropzone\r\n *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\r\n *   e.g. `0.5` for drop to happen when half of the area of the draggable is\r\n *   over the dropzone\r\n *\r\n * Use the `checker` option to specify a function to check if a dragged\r\n * element is over this Interactable.\r\n *\r\n | interact(target)\r\n | .dropChecker(function(dragEvent,         // related dragmove or dragend event\r\n |                       event,             // TouchEvent/PointerEvent/MouseEvent\r\n |                       dropped,           // bool result of the default checker\r\n |                       dropzone,          // dropzone Interactable\r\n |                       dropElement,       // dropzone elemnt\r\n |                       draggable,         // draggable Interactable\r\n |                       draggableElement) {// draggable element\r\n |\r\n |   return dropped && event.target.hasAttribute('allow-drop');\r\n | }\r\n *\r\n *\r\n - options (boolean | object | null) #optional The new value to be set.\r\n | interact('.drop').dropzone({\r\n |   accept: '.can-drop' || document.getElementById('single-drop'),\r\n |   overlap: 'pointer' || 'center' || zeroToOne\r\n | }\r\n = (boolean | object) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.dropzone = function (options) {\r\n  if (utils.isObject(options)) {\r\n    this.options.drop.enabled = options.enabled === false? false: true;\r\n\r\n    if (utils.isFunction(options.ondrop)          ) { this._iEvents.ondrop           = options.ondrop          ; }\r\n    if (utils.isFunction(options.ondropactivate)  ) { this._iEvents.ondropactivate   = options.ondropactivate  ; }\r\n    if (utils.isFunction(options.ondropdeactivate)) { this._iEvents.ondropdeactivate = options.ondropdeactivate; }\r\n    if (utils.isFunction(options.ondragenter)     ) { this._iEvents.ondragenter      = options.ondragenter     ; }\r\n    if (utils.isFunction(options.ondragleave)     ) { this._iEvents.ondragleave      = options.ondragleave     ; }\r\n    if (utils.isFunction(options.ondropmove)      ) { this._iEvents.ondropmove       = options.ondropmove      ; }\r\n\r\n    if (/^(pointer|center)$/.test(options.overlap)) {\r\n      this.options.drop.overlap = options.overlap;\r\n    }\r\n    else if (utils.isNumber(options.overlap)) {\r\n      this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\r\n    }\r\n    if ('accept' in options) {\r\n      this.options.drop.accept = options.accept;\r\n    }\r\n    if ('checker' in options) {\r\n      this.options.drop.checker = options.checker;\r\n    }\r\n\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.isBool(options)) {\r\n    this.options.drop.enabled = options;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.drop;\r\n};\r\n\r\nInteractable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\r\n  let dropped = false;\r\n\r\n  // if the dropzone has no rect (eg. display: none)\r\n  // call the custom dropChecker or just return false\r\n  if (!(rect = rect || this.getRect(dropElement))) {\r\n    return (this.options.drop.checker\r\n      ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\r\n      : false);\r\n  }\r\n\r\n  const dropOverlap = this.options.drop.overlap;\r\n\r\n  if (dropOverlap === 'pointer') {\r\n    const origin = utils.getOriginXY(draggable, draggableElement);\r\n    const page = utils.getPageXY(dragEvent);\r\n    let horizontal;\r\n    let vertical;\r\n\r\n    page.x += origin.x;\r\n    page.y += origin.y;\r\n\r\n    horizontal = (page.x > rect.left) && (page.x < rect.right);\r\n    vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\r\n\r\n    dropped = horizontal && vertical;\r\n  }\r\n\r\n  const dragRect = draggable.getRect(draggableElement);\r\n\r\n  if (dropOverlap === 'center') {\r\n    const cx = dragRect.left + dragRect.width  / 2;\r\n    const cy = dragRect.top  + dragRect.height / 2;\r\n\r\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\r\n  }\r\n\r\n  if (utils.isNumber(dropOverlap)) {\r\n    const overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\r\n                          * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top )));\r\n\r\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height);\r\n\r\n    dropped = overlapRatio >= dropOverlap;\r\n  }\r\n\r\n  if (this.options.drop.checker) {\r\n    dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\r\n  }\r\n\r\n  return dropped;\r\n};\r\n\r\nInteractable.signals.on('unset', function ({ interactable }) {\r\n  interactable.dropzone(false);\r\n});\r\n\r\nInteractable.settingsMethods.push('dropChecker');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.dropTarget      = null; // the dropzone a drag target might be dropped into\r\n  interaction.dropElement     = null; // the element at the time of checking\r\n  interaction.prevDropTarget  = null; // the dropzone that was recently dragged away from\r\n  interaction.prevDropElement = null; // the element at the time of checking\r\n  interaction.dropEvents      = null; // the dropEvents related to the current drag event\r\n\r\n  interaction.activeDrops = {\r\n    dropzones: [],      // the dropzones that are mentioned below\r\n    elements : [],      // elements of dropzones that accept the target draggable\r\n    rects    : [],      // the rects of the elements mentioned above\r\n  };\r\n\r\n});\r\n\r\nInteraction.signals.on('stop', function ({ interaction }) {\r\n  interaction.dropTarget = interaction.dropElement =\r\n    interaction.prevDropTarget = interaction.prevDropElement = null;\r\n});\r\n\r\n/*\\\r\n * interact.dynamicDrop\r\n [ method ]\r\n *\r\n * Returns or sets whether the dimensions of dropzone elements are\r\n * calculated on every dragmove or only on dragstart for the default\r\n * dropChecker\r\n *\r\n - newValue (boolean) #optional True to check on each move. False to check only before start\r\n = (boolean | interact) The current setting or interact\r\n\\*/\r\ninteract.dynamicDrop = function (newValue) {\r\n  if (utils.isBool(newValue)) {\r\n    //if (dragging && dynamicDrop !== newValue && !newValue) {\r\n      //calcRects(dropzones);\r\n    //}\r\n\r\n    dynamicDrop = newValue;\r\n\r\n    return interact;\r\n  }\r\n  return dynamicDrop;\r\n};\r\n\r\nutils.merge(Interactable.eventTypes, [\r\n  'dragenter',\r\n  'dragleave',\r\n  'dropactivate',\r\n  'dropdeactivate',\r\n  'dropmove',\r\n  'drop',\r\n]);\r\nactions.methodDict.drop = 'dropzone';\r\n\r\ndefaultOptions.drop = drop.defaults;\r\n\r\nmodule.exports = drop;\r\n","const actions        = require('./index');\r\nconst utils          = require('../utils');\r\nconst InteractEvent  = require('../InteractEvent');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst gesture = {\r\n  defaults: {\r\n    enabled : false,\r\n    restrict: null,\r\n  },\r\n\r\n  checker: function (pointer, event, interactable, element, interaction) {\r\n    if (interaction.pointerIds.length >= 2) {\r\n      return { name: 'gesture' };\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  getCursor: function () {\r\n    return '';\r\n  },\r\n};\r\n\r\nInteraction.signals.on('action-start', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'gesture') { return; }\r\n\r\n  const gestureEvent = new InteractEvent(interaction, event, 'gesture', 'start', interaction.element);\r\n\r\n  gestureEvent.ds = 0;\r\n\r\n  interaction.gesture.startDistance = interaction.gesture.prevDistance = gestureEvent.distance;\r\n  interaction.gesture.startAngle = interaction.gesture.prevAngle = gestureEvent.angle;\r\n  interaction.gesture.scale = 1;\r\n\r\n  interaction._interacting = true;\r\n\r\n  interaction.target.fire(gestureEvent);\r\n  interaction.prevEvent = gestureEvent;\r\n});\r\n\r\nInteraction.signals.on('action-move', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'gesture') { return; }\r\n\r\n  let gestureEvent;\r\n\r\n  gestureEvent = new InteractEvent(interaction, event, 'gesture', 'move', interaction.element);\r\n  gestureEvent.ds = gestureEvent.scale - interaction.gesture.scale;\r\n\r\n  interaction.target.fire(gestureEvent);\r\n\r\n  interaction.gesture.prevAngle = gestureEvent.angle;\r\n  interaction.gesture.prevDistance = gestureEvent.distance;\r\n\r\n  if (gestureEvent.scale !== Infinity\r\n      && gestureEvent.scale !== null\r\n      && gestureEvent.scale !== undefined\r\n      && !isNaN(gestureEvent.scale)) {\r\n\r\n    interaction.gesture.scale = gestureEvent.scale;\r\n  }\r\n\r\n  interaction.prevEvent = gestureEvent;\r\n\r\n  // if the action was ended in a gesturemove listener\r\n  if (!interaction.interacting()) { return false; }\r\n});\r\n\r\nInteraction.signals.on('action-end', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'gesture') { return; }\r\n\r\n  const gestureEvent = new InteractEvent(interaction, event, 'gesture', 'end', interaction.element);\r\n\r\n  interaction.target.fire(gestureEvent);\r\n  interaction.prevEvent = gestureEvent;\r\n});\r\n\r\n/*\\\r\n * Interactable.gesturable\r\n [ method ]\r\n *\r\n * Gets or sets whether multitouch gestures can be performed on the\r\n * Interactable's element\r\n *\r\n = (boolean) Indicates if this can be the target of gesture events\r\n   | var isGestureable = interact(element).gesturable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\r\n = (object) this Interactable\r\n | interact(element).gesturable({\r\n |     onstart: function (event) {},\r\n |     onmove : function (event) {},\r\n |     onend  : function (event) {},\r\n |\r\n |     // limit multiple gestures.\r\n |     // See the explanation in @Interactable.draggable example\r\n |     max: Infinity,\r\n |     maxPerElement: 1,\r\n | });\r\n\\*/\r\nInteractable.prototype.gesturable = function (options) {\r\n  if (utils.isObject(options)) {\r\n    this.options.gesture.enabled = options.enabled === false? false: true;\r\n    this.setPerAction('gesture', options);\r\n    this.setOnEvents('gesture', options);\r\n\r\n    return this;\r\n  }\r\n\r\n  if (utils.isBool(options)) {\r\n    this.options.gesture.enabled = options;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.gesture;\r\n};\r\n\r\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action, event, starting, ending, deltaSource }) {\r\n  if (action !== 'gesture') { return; }\r\n\r\n  const pointers = interaction.pointers;\r\n\r\n  iEvent.touches = [pointers[0], pointers[1]];\r\n\r\n  if (starting) {\r\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\r\n    iEvent.box      = utils.touchBBox(pointers);\r\n    iEvent.scale    = 1;\r\n    iEvent.ds       = 0;\r\n    iEvent.angle    = utils.touchAngle(pointers, undefined, deltaSource);\r\n    iEvent.da       = 0;\r\n  }\r\n  else if (ending || event instanceof InteractEvent) {\r\n    iEvent.distance = interaction.prevEvent.distance;\r\n    iEvent.box      = interaction.prevEvent.box;\r\n    iEvent.scale    = interaction.prevEvent.scale;\r\n    iEvent.ds       = iEvent.scale - 1;\r\n    iEvent.angle    = interaction.prevEvent.angle;\r\n    iEvent.da       = iEvent.angle - interaction.gesture.startAngle;\r\n  }\r\n  else {\r\n    iEvent.distance = utils.touchDistance(pointers, deltaSource);\r\n    iEvent.box      = utils.touchBBox(pointers);\r\n    iEvent.scale    = iEvent.distance / interaction.gesture.startDistance;\r\n    iEvent.angle    = utils.touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\r\n\r\n    iEvent.ds = iEvent.scale - interaction.gesture.prevScale;\r\n    iEvent.da = iEvent.angle - interaction.gesture.prevAngle;\r\n  }\r\n});\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.gesture = {\r\n    start: { x: 0, y: 0 },\r\n\r\n    startDistance: 0,   // distance between two touches of touchStart\r\n    prevDistance : 0,\r\n    distance     : 0,\r\n\r\n    scale: 1,           // gesture.distance / gesture.startDistance\r\n\r\n    startAngle: 0,      // angle of line joining two touches\r\n    prevAngle : 0,      // angle of the previous gesture event\r\n  };\r\n});\r\n\r\nactions.gesture = gesture;\r\nactions.names.push('gesture');\r\nutils.merge(Interactable.eventTypes, [\r\n  'gesturestart',\r\n  'gesturemove',\r\n  'gestureend',\r\n]);\r\nactions.methodDict.gesture = 'gesturable';\r\n\r\ndefaultOptions.gesture = gesture.defaults;\r\n\r\nmodule.exports = gesture;\r\n","const actions = {\r\n  names: [],\r\n  methodDict: {},\r\n};\r\n\r\nmodule.exports = actions;\r\n","const actions        = require('./index');\r\nconst utils          = require('../utils');\r\nconst browser        = require('../utils/browser');\r\nconst InteractEvent  = require('../InteractEvent');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\n// Less Precision with touch input\r\nconst defaultMargin = browser.supportsTouch || browser.supportsPointerEvent? 20: 10;\r\n\r\nconst resize = {\r\n  defaults: {\r\n    enabled   : false,\r\n\r\n    snap      : null,\r\n    restrict  : null,\r\n    inertia   : null,\r\n    autoScroll: null,\r\n\r\n    square: false,\r\n    preserveAspectRatio: false,\r\n    axis: 'xy',\r\n\r\n    // use default margin\r\n    margin: NaN,\r\n\r\n    // object with props left, right, top, bottom which are\r\n    // true/false values to resize when the pointer is over that edge,\r\n    // CSS selectors to match the handles for each direction\r\n    // or the Elements for each handle\r\n    edges: null,\r\n\r\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\r\n    // 'negate' will alow the rect to have negative width/height\r\n    // 'reposition' will keep the width/height positive by swapping\r\n    // the top and bottom edges and/or swapping the left and right edges\r\n    invert: 'none',\r\n  },\r\n\r\n  checker: function (pointer, event, interactable, element, interaction, rect) {\r\n    if (!rect) { return null; }\r\n\r\n    const page = utils.extend({}, interaction.curCoords.page);\r\n    const options = interactable.options;\r\n\r\n    if (options.resize.enabled) {\r\n      const resizeOptions = options.resize;\r\n      const resizeEdges = { left: false, right: false, top: false, bottom: false };\r\n\r\n      // if using resize.edges\r\n      if (utils.isObject(resizeOptions.edges)) {\r\n        for (const edge in resizeEdges) {\r\n          resizeEdges[edge] = checkResizeEdge(edge,\r\n                                              resizeOptions.edges[edge],\r\n                                              page,\r\n                                              interaction._eventTarget,\r\n                                              element,\r\n                                              rect,\r\n                                              resizeOptions.margin || defaultMargin);\r\n        }\r\n\r\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\r\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\r\n\r\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\r\n          return {\r\n            name: 'resize',\r\n            edges: resizeEdges,\r\n          };\r\n        }\r\n      }\r\n      else {\r\n        const right  = options.resize.axis !== 'y' && page.x > (rect.right  - defaultMargin);\r\n        const bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - defaultMargin);\r\n\r\n        if (right || bottom) {\r\n          return {\r\n            name: 'resize',\r\n            axes: (right? 'x' : '') + (bottom? 'y' : ''),\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  cursors: (browser.isIe9OrOlder ? {\r\n    x : 'e-resize',\r\n    y : 's-resize',\r\n    xy: 'se-resize',\r\n\r\n    top        : 'n-resize',\r\n    left       : 'w-resize',\r\n    bottom     : 's-resize',\r\n    right      : 'e-resize',\r\n    topleft    : 'se-resize',\r\n    bottomright: 'se-resize',\r\n    topright   : 'ne-resize',\r\n    bottomleft : 'ne-resize',\r\n  } : {\r\n    x : 'ew-resize',\r\n    y : 'ns-resize',\r\n    xy: 'nwse-resize',\r\n\r\n    top        : 'ns-resize',\r\n    left       : 'ew-resize',\r\n    bottom     : 'ns-resize',\r\n    right      : 'ew-resize',\r\n    topleft    : 'nwse-resize',\r\n    bottomright: 'nwse-resize',\r\n    topright   : 'nesw-resize',\r\n    bottomleft : 'nesw-resize',\r\n  }),\r\n\r\n  getCursor: function (action) {\r\n    if (action.axis) {\r\n      return resize.cursors[action.name + action.axis];\r\n    }\r\n    else if (action.edges) {\r\n      let cursorKey = '';\r\n      const edgeNames = ['top', 'bottom', 'left', 'right'];\r\n\r\n      for (let i = 0; i < 4; i++) {\r\n        if (action.edges[edgeNames[i]]) {\r\n          cursorKey += edgeNames[i];\r\n        }\r\n      }\r\n\r\n      return resize.cursors[cursorKey];\r\n    }\r\n  },\r\n};\r\n\r\nInteraction.signals.on('action-start', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'resize') { return; }\r\n\r\n  const resizeEvent = new InteractEvent(interaction, event, 'resize', 'start', interaction.element);\r\n\r\n  if (interaction.prepared.edges) {\r\n    const startRect = interaction.target.getRect(interaction.element);\r\n    const resizeOptions = interaction.target.options.resize;\r\n\r\n    /*\r\n     * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\r\n     * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\r\n     * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\r\n     * on the active edges and the edge being interacted with.\r\n     */\r\n    if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\r\n      const linkedEdges = utils.extend({}, interaction.prepared.edges);\r\n\r\n      linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\r\n      linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\r\n      linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\r\n      linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\r\n\r\n      interaction.prepared._linkedEdges = linkedEdges;\r\n    }\r\n    else {\r\n      interaction.prepared._linkedEdges = null;\r\n    }\r\n\r\n    // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\r\n    if (resizeOptions.preserveAspectRatio) {\r\n      interaction.resizeStartAspectRatio = startRect.width / startRect.height;\r\n    }\r\n\r\n    interaction.resizeRects = {\r\n      start     : startRect,\r\n      current   : utils.extend({}, startRect),\r\n      restricted: utils.extend({}, startRect),\r\n      previous  : utils.extend({}, startRect),\r\n      delta     : {\r\n        left: 0, right : 0, width : 0,\r\n        top : 0, bottom: 0, height: 0,\r\n      },\r\n    };\r\n\r\n    resizeEvent.rect = interaction.resizeRects.restricted;\r\n    resizeEvent.deltaRect = interaction.resizeRects.delta;\r\n  }\r\n\r\n  interaction.target.fire(resizeEvent);\r\n\r\n  interaction._interacting = true;\r\n\r\n  interaction.prevEvent = resizeEvent;\r\n});\r\n\r\nInteraction.signals.on('action-move', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'resize') { return; }\r\n\r\n  const resizeEvent = new InteractEvent(interaction, event, 'resize', 'move', interaction.element);\r\n  const resizeOptions = interaction.target.options.resize;\r\n  const invert = resizeOptions.invert;\r\n  const invertible = invert === 'reposition' || invert === 'negate';\r\n\r\n  let edges = interaction.prepared.edges;\r\n\r\n  if (edges) {\r\n    const start      = interaction.resizeRects.start;\r\n    const current    = interaction.resizeRects.current;\r\n    const restricted = interaction.resizeRects.restricted;\r\n    const delta      = interaction.resizeRects.delta;\r\n    const previous   = utils.extend(interaction.resizeRects.previous, restricted);\r\n    const originalEdges = edges;\r\n\r\n    let dx = resizeEvent.dx;\r\n    let dy = resizeEvent.dy;\r\n\r\n    if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\r\n      // `resize.preserveAspectRatio` takes precedence over `resize.square`\r\n      const startAspectRatio = resizeOptions.preserveAspectRatio\r\n        ? interaction.resizeStartAspectRatio\r\n        : 1;\r\n\r\n      edges = interaction.prepared._linkedEdges;\r\n\r\n      if ((originalEdges.left && originalEdges.bottom)\r\n          || (originalEdges.right && originalEdges.top)) {\r\n        dy = -dx / startAspectRatio;\r\n      }\r\n      else if (originalEdges.left || originalEdges.right ) { dy = dx / startAspectRatio; }\r\n      else if (originalEdges.top  || originalEdges.bottom) { dx = dy * startAspectRatio; }\r\n    }\r\n\r\n    // update the 'current' rect without modifications\r\n    if (edges.top   ) { current.top    += dy; }\r\n    if (edges.bottom) { current.bottom += dy; }\r\n    if (edges.left  ) { current.left   += dx; }\r\n    if (edges.right ) { current.right  += dx; }\r\n\r\n    if (invertible) {\r\n      // if invertible, copy the current rect\r\n      utils.extend(restricted, current);\r\n\r\n      if (invert === 'reposition') {\r\n        // swap edge values if necessary to keep width/height positive\r\n        let swap;\r\n\r\n        if (restricted.top > restricted.bottom) {\r\n          swap = restricted.top;\r\n\r\n          restricted.top = restricted.bottom;\r\n          restricted.bottom = swap;\r\n        }\r\n        if (restricted.left > restricted.right) {\r\n          swap = restricted.left;\r\n\r\n          restricted.left = restricted.right;\r\n          restricted.right = swap;\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      // if not invertible, restrict to minimum of 0x0 rect\r\n      restricted.top    = Math.min(current.top, start.bottom);\r\n      restricted.bottom = Math.max(current.bottom, start.top);\r\n      restricted.left   = Math.min(current.left, start.right);\r\n      restricted.right  = Math.max(current.right, start.left);\r\n    }\r\n\r\n    restricted.width  = restricted.right  - restricted.left;\r\n    restricted.height = restricted.bottom - restricted.top ;\r\n\r\n    for (const edge in restricted) {\r\n      delta[edge] = restricted[edge] - previous[edge];\r\n    }\r\n\r\n    resizeEvent.edges = interaction.prepared.edges;\r\n    resizeEvent.rect = restricted;\r\n    resizeEvent.deltaRect = delta;\r\n  }\r\n\r\n  interaction.target.fire(resizeEvent);\r\n\r\n  interaction.prevEvent = resizeEvent;\r\n\r\n  // if the action was ended in a resizemove listener\r\n  if (!interaction.interacting()) { return false; }\r\n});\r\n\r\nInteraction.signals.on('action-end', function ({ interaction, event }) {\r\n  if (interaction.prepared.name !== 'resize') { return; }\r\n\r\n  const resizeEvent = new InteractEvent(interaction, event, 'resize', 'end', interaction.element);\r\n\r\n  interaction.target.fire(resizeEvent);\r\n  interaction.prevEvent = resizeEvent;\r\n});\r\n\r\n/*\\\r\n * Interactable.resizable\r\n [ method ]\r\n *\r\n * Gets or sets whether resize actions can be performed on the\r\n * Interactable\r\n *\r\n = (boolean) Indicates if this can be the target of resize elements\r\n   | var isResizeable = interact('input[type=text]').resizable();\r\n * or\r\n - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\r\n = (object) This Interactable\r\n   | interact(element).resizable({\r\n   |   onstart: function (event) {},\r\n   |   onmove : function (event) {},\r\n   |   onend  : function (event) {},\r\n   |\r\n   |   edges: {\r\n   |     top   : true,       // Use pointer coords to check for resize.\r\n   |     left  : false,      // Disable resizing from left edge.\r\n   |     bottom: '.resize-s',// Resize if pointer target matches selector\r\n   |     right : handleEl    // Resize if pointer target is the given Element\r\n   |   },\r\n   |\r\n   |     // Width and height can be adjusted independently. When `true`, width and\r\n   |     // height are adjusted at a 1:1 ratio.\r\n   |     square: false,\r\n   |\r\n   |     // Width and height can be adjusted independently. When `true`, width and\r\n   |     // height maintain the aspect ratio they had when resizing started.\r\n   |     preserveAspectRatio: false,\r\n   |\r\n   |   // a value of 'none' will limit the resize rect to a minimum of 0x0\r\n   |   // 'negate' will allow the rect to have negative width/height\r\n   |   // 'reposition' will keep the width/height positive by swapping\r\n   |   // the top and bottom edges and/or swapping the left and right edges\r\n   |   invert: 'none' || 'negate' || 'reposition'\r\n   |\r\n   |   // limit multiple resizes.\r\n   |   // See the explanation in the @Interactable.draggable example\r\n   |   max: Infinity,\r\n   |   maxPerElement: 1,\r\n   | });\r\n  \\*/\r\nInteractable.prototype.resizable = function (options) {\r\n  if (utils.isObject(options)) {\r\n    this.options.resize.enabled = options.enabled === false? false: true;\r\n    this.setPerAction('resize', options);\r\n    this.setOnEvents('resize', options);\r\n\r\n    if (/^x$|^y$|^xy$/.test(options.axis)) {\r\n      this.options.resize.axis = options.axis;\r\n    }\r\n    else if (options.axis === null) {\r\n      this.options.resize.axis = defaultOptions.resize.axis;\r\n    }\r\n\r\n    if (utils.isBool(options.preserveAspectRatio)) {\r\n      this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\r\n    }\r\n    else if (utils.isBool(options.square)) {\r\n      this.options.resize.square = options.square;\r\n    }\r\n\r\n    return this;\r\n  }\r\n  if (utils.isBool(options)) {\r\n    this.options.resize.enabled = options;\r\n\r\n    return this;\r\n  }\r\n  return this.options.resize;\r\n};\r\n\r\nfunction checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\r\n  // false, '', undefined, null\r\n  if (!value) { return false; }\r\n\r\n  // true value, use pointer coords and element rect\r\n  if (value === true) {\r\n    // if dimensions are negative, \"switch\" edges\r\n    const width  = utils.isNumber(rect.width )? rect.width  : rect.right  - rect.left;\r\n    const height = utils.isNumber(rect.height)? rect.height : rect.bottom - rect.top ;\r\n\r\n    if (width < 0) {\r\n      if      (name === 'left' ) { name = 'right'; }\r\n      else if (name === 'right') { name = 'left' ; }\r\n    }\r\n    if (height < 0) {\r\n      if      (name === 'top'   ) { name = 'bottom'; }\r\n      else if (name === 'bottom') { name = 'top'   ; }\r\n    }\r\n\r\n    if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\r\n    if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\r\n\r\n    if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\r\n    if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\r\n  }\r\n\r\n  // the remaining checks require an element\r\n  if (!utils.isElement(element)) { return false; }\r\n\r\n  return utils.isElement(value)\r\n  // the value is an element to use as a resize handle\r\n    ? value === element\r\n    // otherwise check if element matches value as selector\r\n    : utils.matchesUpTo(element, value, interactableElement);\r\n}\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.resizeAxes = 'xy';\r\n});\r\n\r\nInteractEvent.signals.on('set-delta', function ({ interaction, iEvent, action }) {\r\n  if (action !== 'resize' || !interaction.resizeAxes) { return; }\r\n\r\n  const options = interaction.target.options;\r\n\r\n  if (options.resize.square) {\r\n    if (interaction.resizeAxes === 'y') {\r\n      iEvent.dx = iEvent.dy;\r\n    }\r\n    else {\r\n      iEvent.dy = iEvent.dx;\r\n    }\r\n    iEvent.axes = 'xy';\r\n  }\r\n  else {\r\n    iEvent.axes = interaction.resizeAxes;\r\n\r\n    if (interaction.resizeAxes === 'x') {\r\n      iEvent.dy = 0;\r\n    }\r\n    else if (interaction.resizeAxes === 'y') {\r\n      iEvent.dx = 0;\r\n    }\r\n  }\r\n});\r\n\r\nactions.resize = resize;\r\nactions.names.push('resize');\r\nutils.merge(Interactable.eventTypes, [\r\n  'resizestart',\r\n  'resizemove',\r\n  'resizeinertiastart',\r\n  'resizeinertiaresume',\r\n  'resizeend',\r\n]);\r\nactions.methodDict.resize = 'resizable';\r\n\r\ndefaultOptions.resize = resize.defaults;\r\n\r\nmodule.exports = resize;\r\n","const raf            = require('./utils/raf');\r\nconst getWindow      = require('./utils/window').getWindow;\r\nconst isWindow       = require('./utils/isType').isWindow;\r\nconst domUtils       = require('./utils/domUtils');\r\nconst Interaction    = require('./Interaction');\r\nconst defaultOptions = require('./defaultOptions');\r\n\r\nconst autoScroll = {\r\n  defaults: {\r\n    enabled  : false,\r\n    container: null,     // the item that is scrolled (Window or HTMLElement)\r\n    margin   : 60,\r\n    speed    : 300,      // the scroll speed in pixels per second\r\n  },\r\n\r\n  interaction: null,\r\n  i: null,    // the handle returned by window.setInterval\r\n  x: 0, y: 0, // Direction each pulse is to scroll in\r\n\r\n  isScrolling: false,\r\n  prevTime: 0,\r\n\r\n  start: function (interaction) {\r\n    autoScroll.isScrolling = true;\r\n    raf.cancel(autoScroll.i);\r\n\r\n    autoScroll.interaction = interaction;\r\n    autoScroll.prevTime = new Date().getTime();\r\n    autoScroll.i = raf.request(autoScroll.scroll);\r\n  },\r\n\r\n  stop: function () {\r\n    autoScroll.isScrolling = false;\r\n    raf.cancel(autoScroll.i);\r\n  },\r\n\r\n  // scroll the window by the values in scroll.x/y\r\n  scroll: function () {\r\n    const options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll;\r\n    const container = options.container || getWindow(autoScroll.interaction.element);\r\n    const now = new Date().getTime();\r\n    // change in time in seconds\r\n    const dt = (now - autoScroll.prevTime) / 1000;\r\n    // displacement\r\n    const s = options.speed * dt;\r\n\r\n    if (s >= 1) {\r\n      if (isWindow(container)) {\r\n        container.scrollBy(autoScroll.x * s, autoScroll.y * s);\r\n      }\r\n      else if (container) {\r\n        container.scrollLeft += autoScroll.x * s;\r\n        container.scrollTop  += autoScroll.y * s;\r\n      }\r\n\r\n      autoScroll.prevTime = now;\r\n    }\r\n\r\n    if (autoScroll.isScrolling) {\r\n      raf.cancel(autoScroll.i);\r\n      autoScroll.i = raf.request(autoScroll.scroll);\r\n    }\r\n  },\r\n  check: function (interactable, actionName) {\r\n    const options = interactable.options;\r\n\r\n    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;\r\n  },\r\n  onInteractionMove: function ({ interaction, pointer }) {\r\n    if (!(interaction.interacting()\r\n          && autoScroll.check(interaction.target, interaction.prepared.name))) {\r\n      return;\r\n    }\r\n\r\n    if (interaction.simulation) {\r\n      autoScroll.x = autoScroll.y = 0;\r\n      return;\r\n    }\r\n\r\n    let top;\r\n    let right;\r\n    let bottom;\r\n    let left;\r\n\r\n    const options = interaction.target.options[interaction.prepared.name].autoScroll;\r\n    const container = options.container || getWindow(interaction.element);\r\n\r\n    if (isWindow(container)) {\r\n      left   = pointer.clientX < autoScroll.margin;\r\n      top    = pointer.clientY < autoScroll.margin;\r\n      right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\r\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\r\n    }\r\n    else {\r\n      const rect = domUtils.getElementClientRect(container);\r\n\r\n      left   = pointer.clientX < rect.left   + autoScroll.margin;\r\n      top    = pointer.clientY < rect.top    + autoScroll.margin;\r\n      right  = pointer.clientX > rect.right  - autoScroll.margin;\r\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin;\r\n    }\r\n\r\n    autoScroll.x = (right ? 1: left? -1: 0);\r\n    autoScroll.y = (bottom? 1:  top? -1: 0);\r\n\r\n    if (!autoScroll.isScrolling) {\r\n      // set the autoScroll properties to those of the target\r\n      autoScroll.margin = options.margin;\r\n      autoScroll.speed  = options.speed;\r\n\r\n      autoScroll.start(interaction);\r\n    }\r\n  },\r\n};\r\n\r\nInteraction.signals.on('stop-active', function () {\r\n  autoScroll.stop();\r\n});\r\n\r\nInteraction.signals.on('action-move', autoScroll.onInteractionMove);\r\n\r\ndefaultOptions.perAction.autoScroll = autoScroll.defaults;\r\n\r\nmodule.exports = autoScroll;\r\n","const autoStart   = require('./index');\r\nconst Interaction = require('../Interaction');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.delayTimer = null;\r\n});\r\n\r\nautoStart.signals.on('prepared', function ({ interaction }) {\r\n  const actionName = interaction.prepared.name;\r\n\r\n  if (!actionName) { return; }\r\n\r\n  const delay = interaction.target.options[actionName].delay;\r\n\r\n  if (delay > 0) {\r\n    interaction.delayTimer = setTimeout(() => {\r\n      interaction.start(interaction.prepared, interaction.target, interaction.element);\r\n    }, delay);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('move', function ({ interaction, duplicate }) {\r\n  if (interaction.pointerWasMoved && !duplicate) {\r\n    clearTimeout(interaction.delayTimer);\r\n  }\r\n});\r\n\r\n// prevent regular down->move autoStart\r\nautoStart.signals.on('before-start', function ({ interaction }) {\r\n  const actionName = interaction.prepared.name;\r\n\r\n  if (!actionName) { return; }\r\n\r\n  const delay = interaction.target.options[actionName].delay;\r\n\r\n  if (delay > 0) {\r\n    interaction.prepared.name = null;\r\n  }\r\n});\r\n","const autoStart = require('./index');\r\nconst scope     = require('../scope');\r\nconst browser   = require('../utils/browser');\r\n\r\nconst { isElement } = require('../utils/isType');\r\nconst { matchesSelector, parentNode } = require('../utils/domUtils');\r\n\r\nrequire('./index').setActionDefaults(require('../actions/drag'));\r\n\r\nautoStart.signals.on('before-start',  function ({ interaction, eventTarget, dx, dy }) {\r\n  if (interaction.prepared.name !== 'drag') { return; }\r\n\r\n  // check if a drag is in the correct axis\r\n  const absX = Math.abs(dx);\r\n  const absY = Math.abs(dy);\r\n  const dragOptions = interaction.target.options.drag;\r\n  const startAxis = dragOptions.startAxis;\r\n  const currentAxis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\r\n\r\n  interaction.prepared.axis = dragOptions.lockAxis === 'start'\r\n    ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'\r\n    : dragOptions.lockAxis;\r\n\r\n  // if the movement isn't in the startAxis of the interactable\r\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\r\n    // cancel the prepared action\r\n    interaction.prepared.name = null;\r\n\r\n    // then try to get a drag from another ineractable\r\n\r\n    if (!interaction.prepared.name) {\r\n\r\n      let element = eventTarget;\r\n\r\n      const getDraggable = function (interactable, selector, context) {\r\n        const elements = browser.useMatchesSelectorPolyfill\r\n            ? context.querySelectorAll(selector)\r\n            : undefined;\r\n\r\n        if (interactable === interaction.target) { return; }\r\n\r\n        let action = null;\r\n\r\n        if (interactable.inContext(eventTarget)\r\n            && !interactable.options.drag.manualStart\r\n            && !autoStart.testIgnore(interactable, element, eventTarget)\r\n            && autoStart.testAllow(interactable, element, eventTarget)\r\n            && matchesSelector(element, selector, elements)) {\r\n\r\n          action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\r\n        }\r\n        if (action\r\n            && action.name === 'drag'\r\n            && checkStartAxis(currentAxis, interactable)\r\n            && autoStart.withinInteractionLimit(interactable, element, { name: 'drag' })) {\r\n\r\n          return interactable;\r\n        }\r\n      };\r\n\r\n      let action = null;\r\n\r\n      // check all interactables\r\n      while (isElement(element)) {\r\n        const elementInteractable = scope.interactables.get(element);\r\n\r\n        if (elementInteractable\r\n            && elementInteractable !== interaction.target\r\n            && !elementInteractable.options.drag.manualStart) {\r\n\r\n          action = elementInteractable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);\r\n        }\r\n        if (action\r\n            && action.name === 'drag'\r\n            && checkStartAxis(currentAxis, elementInteractable)) {\r\n\r\n          interaction.prepared.name = 'drag';\r\n          interaction.target = elementInteractable;\r\n          interaction.element = element;\r\n          break;\r\n        }\r\n\r\n        const selectorInteractable = scope.interactables.forEachSelector(getDraggable);\r\n\r\n        if (selectorInteractable) {\r\n          interaction.prepared.name = 'drag';\r\n          interaction.target = selectorInteractable;\r\n          interaction.element = element;\r\n          break;\r\n        }\r\n\r\n        element = parentNode(element);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nfunction checkStartAxis (startAxis, interactable) {\r\n  if (!interactable) { return false; }\r\n\r\n  const thisAxis = interactable.options.drag.startAxis;\r\n\r\n  return (startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis);\r\n}\r\n","require('./index').setActionDefaults(require('../actions/gesture'));\r\n","const interact       = require('../interact');\r\nconst Interactable   = require('../Interactable');\r\nconst Interaction    = require('../Interaction');\r\nconst actions        = require('../actions');\r\nconst defaultOptions = require('../defaultOptions');\r\nconst browser        = require('../utils/browser');\r\nconst scope          = require('../scope');\r\nconst utils          = require('../utils');\r\nconst signals        = require('../utils/Signals').new();\r\n\r\nconst autoStart = {\r\n  signals,\r\n  testIgnore,\r\n  testAllow,\r\n  withinInteractionLimit,\r\n  // Allow this many interactions to happen simultaneously\r\n  maxInteractions: Infinity,\r\n  perActionDefaults: {\r\n    manualStart: false,\r\n    max: Infinity,\r\n    maxPerElement: 1,\r\n  },\r\n  setActionDefaults: function (action) {\r\n    utils.extend(action.defaults, autoStart.perActionDefaults);\r\n  },\r\n};\r\n\r\nfunction testIgnore (interactable, interactableElement, element) {\r\n  const ignoreFrom = interactable.options.ignoreFrom;\r\n\r\n  if (!ignoreFrom || !utils.isElement(element)) { return false; }\r\n\r\n  if (utils.isString(ignoreFrom)) {\r\n    return utils.matchesUpTo(element, ignoreFrom, interactableElement);\r\n  }\r\n  else if (utils.isElement(ignoreFrom)) {\r\n    return utils.nodeContains(ignoreFrom, element);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction testAllow (interactable, interactableElement, element) {\r\n  const allowFrom = interactable.options.allowFrom;\r\n\r\n  if (!allowFrom) { return true; }\r\n\r\n  if (!utils.isElement(element)) { return false; }\r\n\r\n  if (utils.isString(allowFrom)) {\r\n    return utils.matchesUpTo(element, allowFrom, interactableElement);\r\n  }\r\n  else if (utils.isElement(allowFrom)) {\r\n    return utils.nodeContains(allowFrom, element);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// set cursor style on mousedown\r\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget }) {\r\n  if (interaction.interacting()) { return; }\r\n\r\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\r\n  prepare(interaction, actionInfo);\r\n});\r\n\r\n// set cursor style on mousemove\r\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget }) {\r\n  if (!interaction.mouse || interaction.pointerIsDown) { return; }\r\n\r\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget);\r\n  prepare(interaction, actionInfo);\r\n});\r\n\r\nInteraction.signals.on('move', function (arg) {\r\n  const { interaction, event } = arg;\r\n\r\n  if (!interaction.pointerIsDown\r\n      || interaction.interacting()\r\n      || !interaction.pointerWasMoved\r\n      || !interaction.prepared.name) {\r\n    return;\r\n  }\r\n\r\n  signals.fire('before-start', arg);\r\n\r\n  const target = interaction.target;\r\n\r\n  if (interaction.prepared.name && target) {\r\n    // check manualStart and interaction limit\r\n    if (target.options[interaction.prepared.name].manualStart\r\n        || !withinInteractionLimit(target, interaction.element, interaction.prepared)) {\r\n      interaction.stop(event);\r\n    }\r\n    else {\r\n      interaction.start(interaction.prepared, target, interaction.element);\r\n    }\r\n  }\r\n});\r\n\r\n// Check if the current target supports the action.\r\n// If so, return the validated action. Otherwise, return null\r\nfunction validateAction (action, interactable) {\r\n  if (utils.isObject(action) && interactable.options[action.name].enabled) {\r\n    return action;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction validateSelector (interaction, pointer, event, matches, matchElements) {\r\n  for (let i = 0, len = matches.length; i < len; i++) {\r\n    const match = matches[i];\r\n    const matchElement = matchElements[i];\r\n    const action = validateAction(match.getAction(pointer, event, interaction, matchElement), match);\r\n\r\n    if (action && withinInteractionLimit(match, matchElement, action)) {\r\n      return {\r\n        action,\r\n        target: match,\r\n        element: matchElement,\r\n      };\r\n    }\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction getActionInfo (interaction, pointer, event, eventTarget) {\r\n  let matches = [];\r\n  let matchElements = [];\r\n\r\n  let element = eventTarget;\r\n  let action = null;\r\n\r\n  function pushMatches (interactable, selector, context) {\r\n    const elements = (browser.useMatchesSelectorPolyfill\r\n      ? context.querySelectorAll(selector)\r\n      : undefined);\r\n\r\n    if (interactable.inContext(element)\r\n        && !module.exports.testIgnore(interactable, element, eventTarget)\r\n      && module.exports.testAllow(interactable, element, eventTarget)\r\n      && utils.matchesSelector(element, selector, elements)) {\r\n\r\n      matches.push(interactable);\r\n      matchElements.push(element);\r\n    }\r\n  }\r\n\r\n  while (utils.isElement(element)) {\r\n    matches = [];\r\n    matchElements = [];\r\n\r\n    const elementInteractable = scope.interactables.get(element);\r\n\r\n    if (elementInteractable\r\n        && (action = validateAction(elementInteractable.getAction(pointer, event, interaction, element), elementInteractable))\r\n        && !elementInteractable.options[action.name].manualStart) {\r\n      return {\r\n        element,\r\n        action,\r\n        target: elementInteractable,\r\n      };\r\n    }\r\n    else {\r\n      scope.interactables.forEachSelector(pushMatches);\r\n\r\n      const actionInfo = validateSelector(interaction, pointer, event, matches, matchElements);\r\n\r\n      if (actionInfo.action\r\n          && !actionInfo.target.options[actionInfo.action.name].manualStart) {\r\n        return actionInfo;\r\n      }\r\n    }\r\n\r\n    element = utils.parentNode(element);\r\n  }\r\n\r\n  return {};\r\n}\r\n\r\nfunction prepare (interaction, { action, target, element }) {\r\n  action = action || {};\r\n\r\n  if (interaction.target && interaction.target.options.styleCursor) {\r\n    const cursorTarget = interaction.target.options.cursorTarget || interaction.target._doc.documentElement;\r\n    cursorTarget.style.cursor = '';\r\n  }\r\n\r\n  interaction.target = target;\r\n  interaction.element = element;\r\n  utils.copyAction(interaction.prepared, action);\r\n\r\n  if (target && target.options.styleCursor) {\r\n    const cursor = action? actions[action.name].getCursor(action) : '';\r\n    const cursorTarget = interaction.target.options.cursorTarget || interaction.target._doc.documentElement;\r\n    cursorTarget.style.cursor = cursor;\r\n  }\r\n\r\n  signals.fire('prepared', { interaction: interaction });\r\n}\r\n\r\nInteractable.prototype.getAction = function (pointer, event, interaction, element) {\r\n  const action = this.defaultActionChecker(pointer, event, interaction, element);\r\n\r\n  if (this.options.actionChecker) {\r\n    return this.options.actionChecker(pointer, event, action, this, element, interaction);\r\n  }\r\n\r\n  return action;\r\n};\r\n\r\n/*\\\r\n * Interactable.actionChecker\r\n [ method ]\r\n *\r\n * Gets or sets the function used to check action to be performed on\r\n * pointerDown\r\n *\r\n - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\r\n = (Function | Interactable) The checker function or this Interactable\r\n *\r\n | interact('.resize-drag')\r\n |   .resizable(true)\r\n |   .draggable(true)\r\n |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\r\n |\r\n |   if (interact.matchesSelector(event.target, '.drag-handle') {\r\n |     // force drag with handle target\r\n |     action.name = drag;\r\n |   }\r\n |   else {\r\n |     // resize from the top and right edges\r\n |     action.name  = 'resize';\r\n |     action.edges = { top: true, right: true };\r\n |   }\r\n |\r\n |   return action;\r\n | });\r\n\\*/\r\nInteractable.prototype.actionChecker = function (checker) {\r\n  if (utils.isFunction(checker)) {\r\n    this.options.actionChecker = checker;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (checker === null) {\r\n    delete this.options.actionChecker;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.actionChecker;\r\n};\r\n\r\n/*\\\r\n * Interactable.styleCursor\r\n [ method ]\r\n *\r\n * Returns or sets whether the the cursor should be changed depending on the\r\n * action that would be performed if the mouse were pressed and dragged.\r\n *\r\n - newValue (boolean) #optional\r\n = (boolean | Interactable) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.styleCursor = function (newValue) {\r\n  if (utils.isBool(newValue)) {\r\n    this.options.styleCursor = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  if (newValue === null) {\r\n    delete this.options.styleCursor;\r\n\r\n    return this;\r\n  }\r\n\r\n  return this.options.styleCursor;\r\n};\r\n\r\n/*\\\r\n * Interactable.ignoreFrom\r\n [ method ]\r\n *\r\n * If the target of the `mousedown`, `pointerdown` or `touchstart`\r\n * event or any of it's parents match the given CSS selector or\r\n * Element, no drag/resize/gesture is started.\r\n *\r\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\r\n = (string | Element | object) The current ignoreFrom value or this Interactable\r\n **\r\n | interact(element, { ignoreFrom: document.getElementById('no-action') });\r\n | // or\r\n | interact(element).ignoreFrom('input, textarea, a');\r\n\\*/\r\nInteractable.prototype.ignoreFrom = function (newValue) {\r\n  if (utils.trySelector(newValue)) {            // CSS selector to match event.target\r\n    this.options.ignoreFrom = newValue;\r\n    return this;\r\n  }\r\n\r\n  if (utils.isElement(newValue)) {              // specific element\r\n    this.options.ignoreFrom = newValue;\r\n    return this;\r\n  }\r\n\r\n  return this.options.ignoreFrom;\r\n};\r\n\r\n/*\\\r\n * Interactable.allowFrom\r\n [ method ]\r\n *\r\n * A drag/resize/gesture is started only If the target of the\r\n * `mousedown`, `pointerdown` or `touchstart` event or any of it's\r\n * parents match the given CSS selector or Element.\r\n *\r\n - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\r\n = (string | Element | object) The current allowFrom value or this Interactable\r\n **\r\n | interact(element, { allowFrom: document.getElementById('drag-handle') });\r\n | // or\r\n | interact(element).allowFrom('.handle');\r\n\\*/\r\nInteractable.prototype.allowFrom = function (newValue) {\r\n  if (utils.trySelector(newValue)) {            // CSS selector to match event.target\r\n    this.options.allowFrom = newValue;\r\n    return this;\r\n  }\r\n\r\n  if (utils.isElement(newValue)) {              // specific element\r\n    this.options.allowFrom = newValue;\r\n    return this;\r\n  }\r\n\r\n  return this.options.allowFrom;\r\n};\r\n\r\nInteraction.signals.on('stop', function ({ interaction }) {\r\n  const target = interaction.target;\r\n\r\n  if (target && target.options.styleCursor) {\r\n    const cursorTarget = target.options.cursorTarget || target._doc.documentElement;\r\n    cursorTarget.style.cursor = '';\r\n  }\r\n});\r\n\r\nInteractable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {\r\n  const rect = this.getRect(element);\r\n  let action = null;\r\n\r\n  for (const actionName of actions.names) {\r\n    action = actions[actionName].checker(pointer, event, this, element, interaction, rect);\r\n\r\n    if (action) {\r\n      return action;\r\n    }\r\n  }\r\n};\r\n\r\nfunction withinInteractionLimit (interactable, element, action) {\r\n  const options = interactable.options;\r\n  const maxActions = options[action.name].max;\r\n  const maxPerElement = options[action.name].maxPerElement;\r\n  let activeInteractions = 0;\r\n  let targetCount = 0;\r\n  let targetElementCount = 0;\r\n\r\n  // no actions if any of these values == 0\r\n  if (!(maxActions && maxPerElement && autoStart.maxInteractions)) { return; }\r\n\r\n  for (let i = 0, len = scope.interactions.length; i < len; i++) {\r\n    const interaction = scope.interactions[i];\r\n    const otherAction = interaction.prepared.name;\r\n\r\n    if (!interaction.interacting()) { continue; }\r\n\r\n    activeInteractions++;\r\n\r\n    if (activeInteractions >= autoStart.maxInteractions) {\r\n      return false;\r\n    }\r\n\r\n    if (interaction.target !== interactable) { continue; }\r\n\r\n    targetCount += (otherAction === action.name)|0;\r\n\r\n    if (targetCount >= maxActions) {\r\n      return false;\r\n    }\r\n\r\n    if (interaction.element === element) {\r\n      targetElementCount++;\r\n\r\n      if (otherAction !== action.name || targetElementCount >= maxPerElement) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return autoStart.maxInteractions > 0;\r\n}\r\n\r\n/*\\\r\n * interact.maxInteractions\r\n [ method ]\r\n **\r\n * Returns or sets the maximum number of concurrent interactions allowed.\r\n * By default only 1 interaction is allowed at a time (for backwards\r\n * compatibility). To allow multiple interactions on the same Interactables\r\n * and elements, you need to enable it in the draggable, resizable and\r\n * gesturable `'max'` and `'maxPerElement'` options.\r\n **\r\n - newValue (number) #optional Any number. newValue <= 0 means no interactions.\r\n\\*/\r\ninteract.maxInteractions = function (newValue) {\r\n  if (utils.isNumber(newValue)) {\r\n    autoStart.maxInteractions = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  return autoStart.maxInteractions;\r\n};\r\n\r\nInteractable.settingsMethods.push('styleCursor');\r\nInteractable.settingsMethods.push('actionChecker');\r\nInteractable.settingsMethods.push('ignoreFrom');\r\nInteractable.settingsMethods.push('allowFrom');\r\n\r\ndefaultOptions.base.actionChecker = null;\r\ndefaultOptions.base.ignoreFrom = null;\r\ndefaultOptions.base.allowFrom = null;\r\ndefaultOptions.base.styleCursor = true;\r\n\r\nutils.extend(defaultOptions.perAction, autoStart.perActionDefaults);\r\n\r\nmodule.exports = autoStart;\r\n","require('./index').setActionDefaults(require('../actions/resize'));\r\n","module.exports = {\r\n  base: {\r\n    accept        : null,\r\n    preventDefault: 'auto',\r\n    origin        : { x: 0, y: 0 },\r\n    deltaSource   : 'page',\r\n    allowFrom     : null,\r\n  },\r\n\r\n  perAction: {\r\n    inertia: {\r\n      enabled          : false,\r\n      resistance       : 10,    // the lambda in exponential decay\r\n      minSpeed         : 100,   // target speed must be above this for inertia to start\r\n      endSpeed         : 10,    // the speed at which inertia is slow enough to stop\r\n      allowResume      : true,  // allow resuming an action in inertia phase\r\n      smoothEndDuration: 300,   // animate to snap/restrict endOnly if there's no inertia\r\n    },\r\n  },\r\n\r\n  _holdDuration: 600,\r\n};\r\n","/* browser entry point */\r\n\r\n// Legacy browser support\r\nrequire('./legacyBrowsers');\r\n\r\n// pointerEvents\r\nrequire('./pointerEvents');\r\nrequire('./pointerEvents/interactableTargets');\r\n\r\n// inertia\r\nrequire('./inertia');\r\n\r\n// modifiers\r\nrequire('./modifiers/snap');\r\nrequire('./modifiers/restrict');\r\n\r\n// delay\r\nrequire('./autoStart/delay');\r\n\r\n// actions\r\nrequire('./autoStart/gesture');\r\nrequire('./autoStart/resize');\r\nrequire('./autoStart/drag');\r\n\r\nrequire('./actions/drop');\r\n\r\n// Interactable preventDefault setting\r\nrequire('./interactablePreventDefault.js');\r\n\r\n// autoScroll\r\nrequire('./autoScroll');\r\n\r\n// export interact\r\nmodule.exports = require('./interact');\r\n","const InteractEvent  = require('./InteractEvent');\r\nconst Interaction    = require('./Interaction');\r\nconst modifiers      = require('./modifiers');\r\nconst utils          = require('./utils');\r\nconst animationFrame = require('./utils/raf');\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.inertiaStatus = {\r\n    active     : false,\r\n    smoothEnd  : false,\r\n    allowResume: false,\r\n\r\n    startEvent: null,\r\n    upCoords  : {},\r\n\r\n    xe: 0, ye: 0,\r\n    sx: 0, sy: 0,\r\n\r\n    t0: 0,\r\n    vx0: 0, vys: 0,\r\n    duration: 0,\r\n\r\n    lambda_v0: 0,\r\n    one_ve_v0: 0,\r\n    i  : null,\r\n  };\r\n\r\n  interaction.boundInertiaFrame   = () => inertiaFrame  .apply(interaction);\r\n  interaction.boundSmoothEndFrame = () => smoothEndFrame.apply(interaction);\r\n});\r\n\r\nInteraction.signals.on('down', function ({ interaction, event, pointer, eventTarget }) {\r\n  const status = interaction.inertiaStatus;\r\n\r\n  // Check if the down event hits the current inertia target\r\n  if (status.active) {\r\n    let element = eventTarget;\r\n\r\n    // climb up the DOM tree from the event target\r\n    while (utils.isElement(element)) {\r\n\r\n      // if interaction element is the current inertia target element\r\n      if (element === interaction.element) {\r\n        // stop inertia\r\n        animationFrame.cancel(status.i);\r\n        status.active = false;\r\n        interaction.simulation = null;\r\n\r\n        // update pointers to the down event's coordinates\r\n        interaction.updatePointer(pointer);\r\n        utils.setCoords(interaction.curCoords, interaction.pointers);\r\n\r\n        // fire appropriate signals\r\n        const signalArg = { interaction };\r\n        Interaction.signals.fire('before-action-move', signalArg);\r\n        Interaction.signals.fire('action-resume'     , signalArg);\r\n\r\n        // fire a reume event\r\n        const resumeEvent = new InteractEvent(interaction,\r\n                                              event,\r\n                                              interaction.prepared.name,\r\n                                              'inertiaresume',\r\n                                              interaction.element);\r\n\r\n        interaction.target.fire(resumeEvent);\r\n        interaction.prevEvent = resumeEvent;\r\n        modifiers.resetStatuses(interaction.modifierStatuses);\r\n\r\n        utils.copyCoords(interaction.prevCoords, interaction.curCoords);\r\n        break;\r\n      }\r\n\r\n      element = utils.parentNode(element);\r\n    }\r\n  }\r\n});\r\n\r\nInteraction.signals.on('up', function ({ interaction, event }) {\r\n  const status = interaction.inertiaStatus;\r\n\r\n  if (!interaction.interacting() || status.active) { return; }\r\n\r\n  const target = interaction.target;\r\n  const options = target && target.options;\r\n  const inertiaOptions = options && interaction.prepared.name && options[interaction.prepared.name].inertia;\r\n\r\n  const now = new Date().getTime();\r\n  const statuses = {};\r\n  const page = utils.extend({}, interaction.curCoords.page);\r\n  const pointerSpeed = interaction.pointerDelta.client.speed;\r\n  let inertiaPossible = false;\r\n  let inertia = false;\r\n  let smoothEnd = false;\r\n  let modifierResult;\r\n\r\n  // check if inertia should be started\r\n  inertiaPossible = (inertiaOptions && inertiaOptions.enabled\r\n                     && interaction.prepared.name !== 'gesture'\r\n                     && event !== status.startEvent);\r\n\r\n  inertia = (inertiaPossible\r\n            && (now - interaction.curCoords.timeStamp) < 50\r\n            && pointerSpeed > inertiaOptions.minSpeed\r\n            && pointerSpeed > inertiaOptions.endSpeed);\r\n\r\n  // smoothEnd\r\n  if (inertiaPossible && !inertia) {\r\n    modifiers.resetStatuses(statuses);\r\n\r\n    modifierResult = modifiers.setAll(interaction, page, statuses, true, true);\r\n\r\n    if (modifierResult.shouldMove && modifierResult.locked) {\r\n      smoothEnd = true;\r\n    }\r\n  }\r\n\r\n  if (!(inertia || smoothEnd)) { return; }\r\n\r\n  utils.copyCoords(status.upCoords, interaction.curCoords);\r\n\r\n  interaction.pointers[0] = status.startEvent =\r\n    new InteractEvent(interaction, event, interaction.prepared.name, 'inertiastart', interaction.element);\r\n\r\n  status.t0 = now;\r\n\r\n  status.active = true;\r\n  status.allowResume = inertiaOptions.allowResume;\r\n  interaction.simulation = status;\r\n\r\n  target.fire(status.startEvent);\r\n\r\n  if (inertia) {\r\n    status.vx0 = interaction.pointerDelta.client.vx;\r\n    status.vy0 = interaction.pointerDelta.client.vy;\r\n    status.v0 = pointerSpeed;\r\n\r\n    calcInertia(interaction, status);\r\n\r\n    utils.extend(page, interaction.curCoords.page);\r\n\r\n    page.x += status.xe;\r\n    page.y += status.ye;\r\n\r\n    modifiers.resetStatuses(statuses);\r\n\r\n    modifierResult = modifiers.setAll(interaction, page, statuses, true, true);\r\n\r\n    status.modifiedXe += modifierResult.dx;\r\n    status.modifiedYe += modifierResult.dy;\r\n\r\n    status.i = animationFrame.request(interaction.boundInertiaFrame);\r\n  }\r\n  else {\r\n    status.smoothEnd = true;\r\n    status.xe = modifierResult.dx;\r\n    status.ye = modifierResult.dy;\r\n\r\n    status.sx = status.sy = 0;\r\n\r\n    status.i = animationFrame.request(interaction.boundSmoothEndFrame);\r\n  }\r\n});\r\n\r\nInteraction.signals.on('stop-active', function ({ interaction }) {\r\n  const status = interaction.inertiaStatus;\r\n\r\n  if (status.active) {\r\n    animationFrame.cancel(status.i);\r\n    status.active = false;\r\n    interaction.simulation = null;\r\n  }\r\n});\r\n\r\nfunction calcInertia (interaction, status) {\r\n  const inertiaOptions = interaction.target.options[interaction.prepared.name].inertia;\r\n  const lambda = inertiaOptions.resistance;\r\n  const inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\r\n\r\n  status.x0 = interaction.prevEvent.pageX;\r\n  status.y0 = interaction.prevEvent.pageY;\r\n  status.t0 = status.startEvent.timeStamp / 1000;\r\n  status.sx = status.sy = 0;\r\n\r\n  status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\r\n  status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\r\n  status.te = inertiaDur;\r\n\r\n  status.lambda_v0 = lambda / status.v0;\r\n  status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\r\n}\r\n\r\nfunction inertiaFrame () {\r\n  updateInertiaCoords(this);\r\n  utils.setCoordDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\r\n\r\n  const status = this.inertiaStatus;\r\n  const options = this.target.options[this.prepared.name].inertia;\r\n  const lambda = options.resistance;\r\n  const t = new Date().getTime() / 1000 - status.t0;\r\n\r\n  if (t < status.te) {\r\n\r\n    const progress =  1 - (Math.exp(-lambda * t) - status.lambda_v0) / status.one_ve_v0;\r\n\r\n    if (status.modifiedXe === status.xe && status.modifiedYe === status.ye) {\r\n      status.sx = status.xe * progress;\r\n      status.sy = status.ye * progress;\r\n    }\r\n    else {\r\n      const quadPoint = utils.getQuadraticCurvePoint(0, 0,\r\n                                                     status.xe,\r\n                                                     status.ye,\r\n                                                     status.modifiedXe,\r\n                                                     status.modifiedYe,\r\n                                                     progress);\r\n\r\n      status.sx = quadPoint.x;\r\n      status.sy = quadPoint.y;\r\n    }\r\n\r\n    this.doMove();\r\n\r\n    status.i = animationFrame.request(this.boundInertiaFrame);\r\n  }\r\n  else {\r\n    status.sx = status.modifiedXe;\r\n    status.sy = status.modifiedYe;\r\n\r\n    this.doMove();\r\n    this.end(status.startEvent);\r\n    status.active = false;\r\n    this.simulation = null;\r\n  }\r\n\r\n  utils.copyCoords(this.prevCoords, this.curCoords);\r\n}\r\n\r\nfunction smoothEndFrame () {\r\n  updateInertiaCoords(this);\r\n\r\n  const status = this.inertiaStatus;\r\n  const t = new Date().getTime() - status.t0;\r\n  const duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\r\n\r\n  if (t < duration) {\r\n    status.sx = utils.easeOutQuad(t, 0, status.xe, duration);\r\n    status.sy = utils.easeOutQuad(t, 0, status.ye, duration);\r\n\r\n    this.pointerMove(status.startEvent, status.startEvent);\r\n\r\n    status.i = animationFrame.request(this.boundSmoothEndFrame);\r\n  }\r\n  else {\r\n    status.sx = status.xe;\r\n    status.sy = status.ye;\r\n\r\n    this.pointerMove(status.startEvent, status.startEvent);\r\n    this.end(status.startEvent);\r\n\r\n    status.smoothEnd =\r\n      status.active = false;\r\n    this.simulation = null;\r\n  }\r\n}\r\n\r\nfunction updateInertiaCoords (interaction) {\r\n  const status = interaction.inertiaStatus;\r\n\r\n  // return if inertia isn't running\r\n  if (!status.active) { return; }\r\n\r\n  const pageUp   = status.upCoords.page;\r\n  const clientUp = status.upCoords.client;\r\n\r\n  utils.setCoords(interaction.curCoords, [ {\r\n    pageX  : pageUp.x   + status.sx,\r\n    pageY  : pageUp.y   + status.sy,\r\n    clientX: clientUp.x + status.sx,\r\n    clientY: clientUp.y + status.sy,\r\n  } ]);\r\n}\r\n","const browser      = require('./utils/browser');\r\nconst events       = require('./utils/events');\r\nconst utils        = require('./utils');\r\nconst scope        = require('./scope');\r\nconst Interactable = require('./Interactable');\r\nconst Interaction  = require('./Interaction');\r\n\r\nconst globalEvents = {};\r\n\r\n/*\\\r\n * interact\r\n [ method ]\r\n *\r\n * The methods of this variable can be used to set elements as\r\n * interactables and also to change various default settings.\r\n *\r\n * Calling it as a function and passing an element or a valid CSS selector\r\n * string returns an Interactable object which has various methods to\r\n * configure it.\r\n *\r\n - element (Element | string) The HTML or SVG Element to interact with or CSS selector\r\n = (object) An @Interactable\r\n *\r\n > Usage\r\n | interact('#draggable').draggable(true);\r\n |\r\n | var rectables = interact('rect');\r\n | rectables\r\n |     .gesturable(true)\r\n |     .on('gesturemove', function (event) {\r\n |         // ...\r\n |     });\r\n\\*/\r\nfunction interact (element, options) {\r\n  let interactable = scope.interactables.get(element, options);\r\n\r\n  if (!interactable) {\r\n    interactable = new Interactable(element, options);\r\n    interactable._iEvents.global = globalEvents;\r\n  }\r\n\r\n  return interactable;\r\n}\r\n\r\n/*\\\r\n * interact.isSet\r\n [ method ]\r\n *\r\n * Check if an element has been set\r\n - element (Element) The Element being searched for\r\n = (boolean) Indicates if the element or CSS selector was previously passed to interact\r\n\\*/\r\ninteract.isSet = function (element, options) {\r\n  return scope.interactables.indexOfElement(element, options && options.context) !== -1;\r\n};\r\n\r\n/*\\\r\n * interact.on\r\n [ method ]\r\n *\r\n * Adds a global listener for an InteractEvent or adds a DOM event to\r\n * `document`\r\n *\r\n - type       (string | array | object) The types of events to listen for\r\n - listener   (function) The function event (s)\r\n - useCapture (boolean) #optional useCapture flag for addEventListener\r\n = (object) interact\r\n\\*/\r\ninteract.on = function (type, listener, useCapture) {\r\n  if (utils.isString(type) && type.search(' ') !== -1) {\r\n    type = type.trim().split(/ +/);\r\n  }\r\n\r\n  if (utils.isArray(type)) {\r\n    for (const eventType of type) {\r\n      interact.on(eventType, listener, useCapture);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (utils.isObject(type)) {\r\n    for (const prop in type) {\r\n      interact.on(prop, type[prop], listener);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  // if it is an InteractEvent type, add listener to globalEvents\r\n  if (utils.contains(Interactable.eventTypes, type)) {\r\n    // if this type of event was never bound\r\n    if (!globalEvents[type]) {\r\n      globalEvents[type] = [listener];\r\n    }\r\n    else {\r\n      globalEvents[type].push(listener);\r\n    }\r\n  }\r\n  // If non InteractEvent type, addEventListener to document\r\n  else {\r\n    events.add(scope.document, type, listener, useCapture);\r\n  }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.off\r\n [ method ]\r\n *\r\n * Removes a global InteractEvent listener or DOM event from `document`\r\n *\r\n - type       (string | array | object) The types of events that were listened for\r\n - listener   (function) The listener function to be removed\r\n - useCapture (boolean) #optional useCapture flag for removeEventListener\r\n = (object) interact\r\n \\*/\r\ninteract.off = function (type, listener, useCapture) {\r\n  if (utils.isString(type) && type.search(' ') !== -1) {\r\n    type = type.trim().split(/ +/);\r\n  }\r\n\r\n  if (utils.isArray(type)) {\r\n    for (const eventType of type) {\r\n      interact.off(eventType, listener, useCapture);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (utils.isObject(type)) {\r\n    for (const prop in type) {\r\n      interact.off(prop, type[prop], listener);\r\n    }\r\n\r\n    return interact;\r\n  }\r\n\r\n  if (!utils.contains(Interactable.eventTypes, type)) {\r\n    events.remove(scope.document, type, listener, useCapture);\r\n  }\r\n  else {\r\n    let index;\r\n\r\n    if (type in globalEvents\r\n        && (index = utils.indexOf(globalEvents[type], listener)) !== -1) {\r\n      globalEvents[type].splice(index, 1);\r\n    }\r\n  }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.debug\r\n [ method ]\r\n *\r\n * Returns an object which exposes internal data\r\n = (object) An object with properties that outline the current state and expose internal functions and variables\r\n\\*/\r\ninteract.debug = function () {\r\n  return scope;\r\n};\r\n\r\n// expose the functions used to calculate multi-touch properties\r\ninteract.getPointerAverage  = utils.pointerAverage;\r\ninteract.getTouchBBox       = utils.touchBBox;\r\ninteract.getTouchDistance   = utils.touchDistance;\r\ninteract.getTouchAngle      = utils.touchAngle;\r\n\r\ninteract.getElementRect       = utils.getElementRect;\r\ninteract.getElementClientRect = utils.getElementClientRect;\r\ninteract.matchesSelector      = utils.matchesSelector;\r\ninteract.closest              = utils.closest;\r\n\r\n/*\\\r\n * interact.supportsTouch\r\n [ method ]\r\n *\r\n = (boolean) Whether or not the browser supports touch input\r\n\\*/\r\ninteract.supportsTouch = function () {\r\n  return browser.supportsTouch;\r\n};\r\n\r\n/*\\\r\n * interact.supportsPointerEvent\r\n [ method ]\r\n *\r\n = (boolean) Whether or not the browser supports PointerEvents\r\n\\*/\r\ninteract.supportsPointerEvent = function () {\r\n  return browser.supportsPointerEvent;\r\n};\r\n\r\n/*\\\r\n * interact.stop\r\n [ method ]\r\n *\r\n * Cancels all interactions (end events are not fired)\r\n *\r\n - event (Event) An event on which to call preventDefault()\r\n = (object) interact\r\n\\*/\r\ninteract.stop = function (event) {\r\n  for (let i = scope.interactions.length - 1; i >= 0; i--) {\r\n    scope.interactions[i].stop(event);\r\n  }\r\n\r\n  return interact;\r\n};\r\n\r\n/*\\\r\n * interact.pointerMoveTolerance\r\n [ method ]\r\n * Returns or sets the distance the pointer must be moved before an action\r\n * sequence occurs. This also affects tolerance for tap events.\r\n *\r\n - newValue (number) #optional The movement from the start position must be greater than this value\r\n = (number | Interactable) The current setting or interact\r\n\\*/\r\ninteract.pointerMoveTolerance = function (newValue) {\r\n  if (utils.isNumber(newValue)) {\r\n    Interaction.pointerMoveTolerance = newValue;\r\n\r\n    return this;\r\n  }\r\n\r\n  return Interaction.pointerMoveTolerance;\r\n};\r\n\r\ninteract.addDocument    = scope.addDocument;\r\ninteract.removeDocument = scope.removeDocument;\r\n\r\nscope.interact = interact;\r\n\r\nmodule.exports = interact;\r\n","const Interactable = require('./Interactable');\r\nconst Interaction  = require('./Interaction');\r\nconst scope        = require('./scope');\r\nconst isType       = require('./utils/isType');\r\n\r\nconst { nodeContains } = require('./utils/domUtils');\r\n\r\n/*\\\r\n * Interactable.preventDefault\r\n [ method ]\r\n *\r\n * Returns or sets whether to prevent the browser's default behaviour\r\n * in response to pointer events. Can be set to:\r\n *  - `'always'` to always prevent\r\n *  - `'never'` to never prevent\r\n *  - `'auto'` to let interact.js try to determine what would be best\r\n *\r\n - newValue (string) #optional `true`, `false` or `'auto'`\r\n = (string | Interactable) The current setting or this Interactable\r\n\\*/\r\nInteractable.prototype.preventDefault = function (newValue) {\r\n  if (/^(always|never|auto)$/.test(newValue)) {\r\n    this.options.preventDefault = newValue;\r\n    return this;\r\n  }\r\n\r\n  if (isType.isBool(newValue)) {\r\n    this.options.preventDefault = newValue? 'always' : 'never';\r\n    return this;\r\n  }\r\n\r\n  return this.options.preventDefault;\r\n};\r\n\r\nInteractable.prototype.checkAndPreventDefault = function (event) {\r\n  const setting = this.options.preventDefault;\r\n\r\n  if (setting === 'never') { return; }\r\n\r\n  if (setting === 'always') {\r\n    event.preventDefault();\r\n    return;\r\n  }\r\n\r\n  // setting === 'auto'\r\n\r\n  // don't preventDefault of pointerdown events\r\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\r\n    return;\r\n  }\r\n\r\n  // don't preventDefault on input elements\r\n  if (/^(input|select|textarea)$/i.test(event.target.nodeName)) {\r\n    return;\r\n  }\r\n\r\n  event.preventDefault();\r\n};\r\n\r\nfunction onInteractionEvent ({ interaction, event }) {\r\n  if (interaction.target) {\r\n    interaction.target.checkAndPreventDefault(event);\r\n  }\r\n}\r\n\r\nfor (const eventSignal of ['down', 'move', 'up', 'cancel']) {\r\n  Interaction.signals.on(eventSignal, onInteractionEvent);\r\n}\r\n\r\n// prevent native HTML5 drag on interact.js target elements\r\nInteraction.docEvents.dragstart = function preventNativeDrag (event) {\r\n  for (const interaction of scope.interactions) {\r\n\r\n    if (interaction.element\r\n        && (interaction.element === event.target\r\n            || nodeContains(interaction.element, event.target))) {\r\n\r\n      interaction.target.checkAndPreventDefault(event);\r\n      return;\r\n    }\r\n  }\r\n};\r\n","const scope   = require('./scope');\r\nconst events  = require('./utils/events');\r\nconst browser = require('./utils/browser');\r\nconst iFinder = require('./utils/interactionFinder');\r\n\r\nconst toString = Object.prototype.toString;\r\n\r\nif (!window.Array.isArray) {\r\n  window.Array.isArray = function (obj) {\r\n    return toString.call(obj) === '[object Array]';\r\n  };\r\n}\r\n\r\nif (!String.prototype.trim) {\r\n  String.prototype.trim = function () {\r\n    return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\r\n  };\r\n}\r\n\r\n// http://www.quirksmode.org/dom/events/click.html\r\n// >Events leading to dblclick\r\n//\r\n// IE8 doesn't fire down event before dblclick.\r\n// This workaround tries to fire a tap and doubletap after dblclick\r\nfunction onIE8Dblclick (event) {\r\n  const interaction = iFinder.search(event, event.type, event.target);\r\n\r\n  if (!interaction) { return; }\r\n\r\n  if (interaction.prevTap\r\n      && event.clientX === interaction.prevTap.clientX\r\n      && event.clientY === interaction.prevTap.clientY\r\n      && event.target  === interaction.prevTap.target) {\r\n\r\n    interaction.downTargets[0] = event.target;\r\n    interaction.downTimes  [0] = new Date().getTime();\r\n\r\n    scope.pointerEvents.collectEventTargets(interaction, event, event, event.target, 'tap');\r\n  }\r\n}\r\n\r\nif (browser.isIE8) {\r\n  const selectFix = function (event) {\r\n    for (const interaction of scope.interactions) {\r\n      if (interaction.interacting()) {\r\n        interaction.target.checkAndPreventDefault(event);\r\n      }\r\n    }\r\n  };\r\n\r\n  const onDocIE8 = function onDocIE8 ({ doc, win }, signalName) {\r\n    const eventMethod = signalName.indexOf('listen') === 0\r\n      ? events.add : events.remove;\r\n\r\n    // For IE's lack of Event#preventDefault\r\n    eventMethod(doc, 'selectstart', selectFix);\r\n\r\n    if (scope.pointerEvents) {\r\n      eventMethod(doc, 'dblclick', onIE8Dblclick);\r\n    }\r\n  };\r\n\r\n  scope.signals.on('add-document'   , onDocIE8);\r\n  scope.signals.on('remove-document', onDocIE8);\r\n}\r\n\r\nmodule.exports = null;\r\n","const InteractEvent = require('../InteractEvent');\r\nconst Interaction   = require('../Interaction');\r\nconst extend        = require('../utils/extend');\r\n\r\nconst modifiers = {\r\n  names: [],\r\n\r\n  setOffsets: function (interaction, coords) {\r\n    const { target, element } = interaction;\r\n    const rect = target.getRect(element);\r\n\r\n    if (rect) {\r\n      interaction.startOffset.left = coords.page.x - rect.left;\r\n      interaction.startOffset.top  = coords.page.y - rect.top;\r\n\r\n      interaction.startOffset.right  = rect.right  - coords.page.x;\r\n      interaction.startOffset.bottom = rect.bottom - coords.page.y;\r\n\r\n      if (!('width'  in rect)) { rect.width  = rect.right  - rect.left; }\r\n      if (!('height' in rect)) { rect.height = rect.bottom - rect.top ; }\r\n    }\r\n    else {\r\n      interaction.startOffset.left = interaction.startOffset.top = interaction.startOffset.right = interaction.startOffset.bottom = 0;\r\n    }\r\n\r\n    modifiers.setModifierOffsets(interaction, target, element, rect, interaction.modifierOffsets);\r\n  },\r\n\r\n  setModifierOffsets: function (interaction, interactable, element, rect, offsets) {\r\n    for (let i = 0; i < modifiers.names.length; i++) {\r\n      const modifierName = modifiers.names[i];\r\n\r\n      offsets[modifierName] =\r\n        modifiers[modifiers.names[i]].setOffset(interaction,\r\n                                                interactable, element, rect,\r\n                                                interaction.startOffset);\r\n    }\r\n  },\r\n\r\n  setAll: function (interaction, coordsArg, statuses, preEnd, requireEndOnly) {\r\n    const result = {\r\n      dx: 0,\r\n      dy: 0,\r\n      changed: false,\r\n      locked: false,\r\n      shouldMove: true,\r\n    };\r\n    const target = interaction.target;\r\n    const coords = extend({}, coordsArg);\r\n\r\n    let currentStatus;\r\n\r\n    for (const modifierName of modifiers.names) {\r\n      const modifier = modifiers[modifierName];\r\n\r\n      if (!modifier.shouldDo(target, interaction.prepared.name, preEnd, requireEndOnly)) { continue; }\r\n\r\n      currentStatus = modifier.set(coords, interaction, statuses[modifierName]);\r\n\r\n      if (currentStatus.locked) {\r\n        coords.x += currentStatus.dx;\r\n        coords.y += currentStatus.dy;\r\n\r\n        result.dx += currentStatus.dx;\r\n        result.dy += currentStatus.dy;\r\n\r\n        result.locked = true;\r\n      }\r\n    }\r\n\r\n    // a move should be fired if the modified coords of\r\n    // the last modifier status that was calculated changes\r\n    result.shouldMove = !currentStatus || currentStatus.changed;\r\n\r\n    return result;\r\n  },\r\n\r\n  resetStatuses: function (statuses) {\r\n    for (const modifierName of modifiers.names) {\r\n      statuses[modifierName] = modifiers[modifierName].reset(statuses[modifierName] || {});\r\n    }\r\n\r\n    return statuses;\r\n  },\r\n\r\n  start: function ({ interaction }, signalName) {\r\n    modifiers.setOffsets(interaction, signalName === 'action-resume'? interaction.curCoords : interaction.startCoords);\r\n\r\n    modifiers.resetStatuses(interaction.modifierStatuses);\r\n    modifiers.setAll(interaction, interaction.startCoords.page, interaction.modifierStatuses);\r\n  },\r\n};\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.startOffset      = { left: 0, right: 0, top: 0, bottom: 0 };\r\n  interaction.modifierOffsets  = {};\r\n  interaction.modifierStatuses = modifiers.resetStatuses({});\r\n});\r\n\r\nInteraction.signals.on('action-start' , modifiers.start);\r\nInteraction.signals.on('action-resume', modifiers.start);\r\n\r\nInteraction.signals.on('before-action-move', function ({ interaction, preEnd, interactingBeforeMove }) {\r\n  const modifierResult = modifiers.setAll(interaction, interaction.curCoords.page, interaction.modifierStatuses, preEnd);\r\n\r\n  // don't fire an action move if a modifier would keep the event in the same\r\n  // cordinates as before\r\n  if (!modifierResult.shouldMove && interactingBeforeMove) {\r\n    interaction._dontFireMove = true;\r\n  }\r\n});\r\n\r\nInteraction.signals.on('action-end', function ({ interaction, event }) {\r\n  for (let i = 0; i < modifiers.names.length; i++) {\r\n    // if the endOnly option is true for any modifier\r\n    if (modifiers[modifiers.names[i]].shouldDo(interaction.target, interaction.prepared.name, true, true)) {\r\n      // fire a move event at the modified coordinates\r\n      interaction.doMove({ event, preEnd: true });\r\n      break;\r\n    }\r\n  }\r\n});\r\n\r\nInteractEvent.signals.on('set-xy', function ({ iEvent, interaction, page, client, phase, action: actionName }) {\r\n  const target = interaction.target;\r\n\r\n  for (let i = 0; i < modifiers.names.length; i++) {\r\n    const modifierName = modifiers.names[i];\r\n    const modifier = modifiers[modifierName];\r\n\r\n    iEvent[modifierName] = modifier.modifyCoords(page, client, target, interaction.modifierStatuses[modifierName], actionName, phase);\r\n  }\r\n});\r\n\r\nmodule.exports = modifiers;\r\n","const modifiers      = require('./index');\r\nconst utils          = require('../utils');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst restrict = {\r\n  defaults: {\r\n    enabled    : false,\r\n    endOnly    : false,\r\n    restriction: null,\r\n    elementRect: null,\r\n  },\r\n\r\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\r\n    const restrictOptions = interactable.options[actionName].restrict;\r\n\r\n    return (restrictOptions && restrictOptions.enabled\r\n            && (preEnd || !restrictOptions.endOnly)\r\n            && (!requireEndOnly || restrictOptions.endOnly));\r\n  },\r\n\r\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\r\n    const elementRect = interactable.options[interaction.prepared.name].restrict.elementRect;\r\n    const offset = {};\r\n\r\n    if (rect && elementRect) {\r\n      offset.left = startOffset.left - (rect.width  * elementRect.left);\r\n      offset.top  = startOffset.top  - (rect.height * elementRect.top);\r\n\r\n      offset.right  = startOffset.right  - (rect.width  * (1 - elementRect.right));\r\n      offset.bottom = startOffset.bottom - (rect.height * (1 - elementRect.bottom));\r\n    }\r\n    else {\r\n      offset.left = offset.top = offset.right = offset.bottom = 0;\r\n    }\r\n\r\n    return offset;\r\n  },\r\n\r\n  set: function (pageCoords, interaction, status) {\r\n    const target    = interaction.target;\r\n    const restrictOptions  = target && target.options[interaction.prepared.name].restrict;\r\n    let restriction = restrictOptions && restrictOptions.restriction;\r\n\r\n    if (!restriction) {\r\n      return status;\r\n    }\r\n\r\n    const page = status.useStatusXY\r\n      ? { x: status.x, y: status.y }\r\n      : utils.extend({}, pageCoords);\r\n\r\n    status.dx = 0;\r\n    status.dy = 0;\r\n    status.locked = false;\r\n\r\n    let rect;\r\n    let restrictedX;\r\n    let restrictedY;\r\n\r\n    if (utils.isString(restriction)) {\r\n      if (restriction === 'parent') {\r\n        restriction = utils.parentNode(interaction.element);\r\n      }\r\n      else if (restriction === 'self') {\r\n        restriction = target.getRect(interaction.element);\r\n      }\r\n      else {\r\n        restriction = utils.closest(interaction.element, restriction);\r\n      }\r\n\r\n      if (!restriction) { return status; }\r\n    }\r\n\r\n    if (utils.isFunction(restriction)) {\r\n      restriction = restriction(page.x, page.y, interaction.element);\r\n    }\r\n\r\n    if (utils.isElement(restriction)) {\r\n      restriction = utils.getElementRect(restriction);\r\n    }\r\n\r\n    rect = restriction;\r\n\r\n    const offset = interaction.modifierOffsets.restrict;\r\n\r\n    if (!restriction) {\r\n      restrictedX = page.x;\r\n      restrictedY = page.y;\r\n    }\r\n    // object is assumed to have\r\n    // x, y, width, height or\r\n    // left, top, right, bottom\r\n    else if ('x' in restriction && 'y' in restriction) {\r\n      restrictedX = Math.max(Math.min(rect.x + rect.width  - offset.right , page.x), rect.x + offset.left);\r\n      restrictedY = Math.max(Math.min(rect.y + rect.height - offset.bottom, page.y), rect.y + offset.top );\r\n    }\r\n    else {\r\n      restrictedX = Math.max(Math.min(rect.right  - offset.right , page.x), rect.left + offset.left);\r\n      restrictedY = Math.max(Math.min(rect.bottom - offset.bottom, page.y), rect.top  + offset.top );\r\n    }\r\n\r\n    status.dx = restrictedX - page.x;\r\n    status.dy = restrictedY - page.y;\r\n\r\n    status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\r\n    status.locked = !!(status.dx || status.dy);\r\n\r\n    status.restrictedX = restrictedX;\r\n    status.restrictedY = restrictedY;\r\n\r\n    return status;\r\n  },\r\n\r\n  reset: function (status) {\r\n    status.dx = status.dy = 0;\r\n    status.modifiedX = status.modifiedY = NaN;\r\n    status.locked = false;\r\n    status.changed = true;\r\n\r\n    return status;\r\n  },\r\n\r\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\r\n    const options = interactable.options[actionName].restrict;\r\n    const elementRect = options && options.elementRect;\r\n\r\n    if (options && options.enabled\r\n        && !(phase === 'start' && elementRect && status.locked)) {\r\n\r\n      if (status.locked) {\r\n        page.x += status.dx;\r\n        page.y += status.dy;\r\n        client.x += status.dx;\r\n        client.y += status.dy;\r\n\r\n        return {\r\n          dx: status.dx,\r\n          dy: status.dy,\r\n        };\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nmodifiers.restrict = restrict;\r\nmodifiers.names.push('restrict');\r\n\r\ndefaultOptions.perAction.restrict = restrict.defaults;\r\n\r\nmodule.exports = restrict;\r\n","const modifiers      = require('./index');\r\nconst interact       = require('../interact');\r\nconst utils          = require('../utils');\r\nconst defaultOptions = require('../defaultOptions');\r\n\r\nconst snap = {\r\n  defaults: {\r\n    enabled: false,\r\n    endOnly: false,\r\n    range  : Infinity,\r\n    targets: null,\r\n    offsets: null,\r\n\r\n    relativePoints: null,\r\n  },\r\n\r\n  shouldDo: function (interactable, actionName, preEnd, requireEndOnly) {\r\n    const snapOptions = interactable.options[actionName].snap;\r\n\r\n    return (snapOptions && snapOptions.enabled\r\n            && (preEnd || !snapOptions.endOnly)\r\n            && (!requireEndOnly || snapOptions.endOnly));\r\n  },\r\n\r\n  setOffset: function (interaction, interactable, element, rect, startOffset) {\r\n    const offsets = [];\r\n    const origin = utils.getOriginXY(interactable, element);\r\n    const snapOptions = interactable.options[interaction.prepared.name].snap || {};\r\n    let snapOffset;\r\n\r\n    if (snapOptions.offset === 'startCoords') {\r\n      snapOffset = {\r\n        x: interaction.startCoords.page.x - origin.x,\r\n        y: interaction.startCoords.page.y - origin.y,\r\n      };\r\n    }\r\n    else if (snapOptions.offset === 'self') {\r\n      snapOffset = {\r\n        x: rect.left - origin.x,\r\n        y: rect.top - origin.y,\r\n      };\r\n    }\r\n    else {\r\n      snapOffset = snapOptions.offset || { x: 0, y: 0 };\r\n    }\r\n\r\n    if (rect && snapOptions.relativePoints && snapOptions.relativePoints.length) {\r\n      for (const { x: relativeX, y: relativeY } of snapOptions.relativePoints) {\r\n        offsets.push({\r\n          x: startOffset.left - (rect.width  * relativeX) + snapOffset.x,\r\n          y: startOffset.top  - (rect.height * relativeY) + snapOffset.y,\r\n        });\r\n      }\r\n    }\r\n    else {\r\n      offsets.push(snapOffset);\r\n    }\r\n\r\n    return offsets;\r\n  },\r\n\r\n  set: function (pageCoords, interaction, status) {\r\n    const snapOptions = interaction.target.options[interaction.prepared.name].snap;\r\n    const targets = [];\r\n    let target;\r\n    let page;\r\n    let i;\r\n\r\n    if (status.useStatusXY) {\r\n      page = { x: status.x, y: status.y };\r\n    }\r\n    else {\r\n      const origin = utils.getOriginXY(interaction.target, interaction.element);\r\n\r\n      page = utils.extend({}, pageCoords);\r\n\r\n      page.x -= origin.x;\r\n      page.y -= origin.y;\r\n    }\r\n\r\n    status.realX = page.x;\r\n    status.realY = page.y;\r\n\r\n    const offsets = interaction.modifierOffsets.snap;\r\n    let len = snapOptions.targets? snapOptions.targets.length : 0;\r\n\r\n    for (const { x: offsetX, y: offsetY } of offsets) {\r\n      const relativeX = page.x - offsetX;\r\n      const relativeY = page.y - offsetY;\r\n\r\n      for (const snapTarget of snapOptions.targets) {\r\n        if (utils.isFunction(snapTarget)) {\r\n          target = snapTarget(relativeX, relativeY, interaction);\r\n        }\r\n        else {\r\n          target = snapTarget;\r\n        }\r\n\r\n        if (!target) { continue; }\r\n\r\n        targets.push({\r\n          x: utils.isNumber(target.x) ? (target.x + offsetX) : relativeX,\r\n          y: utils.isNumber(target.y) ? (target.y + offsetY) : relativeY,\r\n\r\n          range: utils.isNumber(target.range)? target.range: snapOptions.range,\r\n        });\r\n      }\r\n    }\r\n\r\n    const closest = {\r\n      target: null,\r\n      inRange: false,\r\n      distance: 0,\r\n      range: 0,\r\n      dx: 0,\r\n      dy: 0,\r\n    };\r\n\r\n    for (i = 0, len = targets.length; i < len; i++) {\r\n      target = targets[i];\r\n\r\n      const range = target.range;\r\n      const dx = target.x - page.x;\r\n      const dy = target.y - page.y;\r\n      const distance = utils.hypot(dx, dy);\r\n      let inRange = distance <= range;\r\n\r\n      // Infinite targets count as being out of range\r\n      // compared to non infinite ones that are in range\r\n      if (range === Infinity && closest.inRange && closest.range !== Infinity) {\r\n        inRange = false;\r\n      }\r\n\r\n      if (!closest.target || (inRange\r\n          // is the closest target in range?\r\n          ? (closest.inRange && range !== Infinity\r\n          // the pointer is relatively deeper in this target\r\n          ? distance / range < closest.distance / closest.range\r\n          // this target has Infinite range and the closest doesn't\r\n          : (range === Infinity && closest.range !== Infinity)\r\n          // OR this target is closer that the previous closest\r\n        || distance < closest.distance)\r\n          // The other is not in range and the pointer is closer to this target\r\n          : (!closest.inRange && distance < closest.distance))) {\r\n\r\n        closest.target = target;\r\n        closest.distance = distance;\r\n        closest.range = range;\r\n        closest.inRange = inRange;\r\n        closest.dx = dx;\r\n        closest.dy = dy;\r\n\r\n        status.range = range;\r\n      }\r\n    }\r\n\r\n    let snapChanged;\r\n\r\n    if (closest.target) {\r\n      snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\r\n\r\n      status.snappedX = closest.target.x;\r\n      status.snappedY = closest.target.y;\r\n    }\r\n    else {\r\n      snapChanged = true;\r\n\r\n      status.snappedX = NaN;\r\n      status.snappedY = NaN;\r\n    }\r\n\r\n    status.dx = closest.dx;\r\n    status.dy = closest.dy;\r\n\r\n    status.changed = (snapChanged || (closest.inRange && !status.locked));\r\n    status.locked = closest.inRange;\r\n\r\n    return status;\r\n  },\r\n\r\n  reset: function (status) {\r\n    status.dx = status.dy = 0;\r\n    status.snappedX = status.snappedY = NaN;\r\n    status.locked = false;\r\n    status.changed = true;\r\n\r\n    return status;\r\n  },\r\n\r\n  modifyCoords: function (page, client, interactable, status, actionName, phase) {\r\n    const snapOptions = interactable.options[actionName].snap;\r\n    const relativePoints = snapOptions && snapOptions.relativePoints;\r\n\r\n    if (snapOptions && snapOptions.enabled\r\n        && !(phase === 'start' && relativePoints && relativePoints.length)) {\r\n\r\n      if (status.locked) {\r\n        page.x += status.dx;\r\n        page.y += status.dy;\r\n        client.x += status.dx;\r\n        client.y += status.dy;\r\n      }\r\n\r\n      return {\r\n        range  : status.range,\r\n        locked : status.locked,\r\n        x      : status.snappedX,\r\n        y      : status.snappedY,\r\n        realX  : status.realX,\r\n        realY  : status.realY,\r\n        dx     : status.dx,\r\n        dy     : status.dy,\r\n      };\r\n    }\r\n  },\r\n};\r\n\r\ninteract.createSnapGrid = function (grid) {\r\n  return function (x, y) {\r\n    const limits = grid.limits || {\r\n      left  : -Infinity,\r\n      right :  Infinity,\r\n      top   : -Infinity,\r\n      bottom:  Infinity,\r\n    };\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (utils.isObject(grid.offset)) {\r\n      offsetX = grid.offset.x;\r\n      offsetY = grid.offset.y;\r\n    }\r\n\r\n    const gridx = Math.round((x - offsetX) / grid.x);\r\n    const gridy = Math.round((y - offsetY) / grid.y);\r\n\r\n    const newX = Math.max(limits.left, Math.min(limits.right , gridx * grid.x + offsetX));\r\n    const newY = Math.max(limits.top , Math.min(limits.bottom, gridy * grid.y + offsetY));\r\n\r\n    return {\r\n      x: newX,\r\n      y: newY,\r\n      range: grid.range,\r\n    };\r\n  };\r\n};\r\n\r\nmodifiers.snap = snap;\r\nmodifiers.names.push('snap');\r\n\r\ndefaultOptions.perAction.snap = snap.defaults;\r\n\r\nmodule.exports = snap;\r\n","const scope       = require('../scope');\r\nconst Interaction = require('../Interaction');\r\nconst utils       = require('../utils');\r\nconst browser     = require('../utils/browser');\r\nconst defaults    = require('../defaultOptions');\r\nconst signals     = require('../utils/Signals').new();\r\n\r\nconst simpleSignals = [ 'down', 'up', 'up', 'cancel' ];\r\nconst simpleEvents = [ 'down', 'up', 'tap', 'cancel' ];\r\n\r\nfunction preventOriginalDefault () {\r\n  this.originalEvent.preventDefault();\r\n}\r\n\r\nfunction stopImmediatePropagation () {\r\n  this.immediatePropagationStopped = this.propagationStopped = true;\r\n}\r\n\r\nfunction stopPropagation () {\r\n  this.propagationStopped = true;\r\n}\r\n\r\nfunction firePointers (interaction, pointer, event, eventTarget, targets, eventType) {\r\n  const pointerIndex = interaction.mouse? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\r\n  let pointerEvent = {};\r\n  let i;\r\n  // for tap events\r\n  let interval;\r\n  let createNewDoubleTap;\r\n\r\n  // if it's a doubletap then the event properties would have been\r\n  // copied from the tap event and provided as the pointer argument\r\n  if (eventType === 'doubletap') {\r\n    pointerEvent = pointer;\r\n  }\r\n  else {\r\n    utils.pointerExtend(pointerEvent, event);\r\n    if (event !== pointer) {\r\n      utils.pointerExtend(pointerEvent, pointer);\r\n    }\r\n\r\n    pointerEvent.preventDefault           = preventOriginalDefault;\r\n    pointerEvent.stopPropagation          = stopPropagation;\r\n    pointerEvent.stopImmediatePropagation = stopImmediatePropagation;\r\n    pointerEvent.interaction              = interaction;\r\n\r\n    pointerEvent.timeStamp     = new Date().getTime();\r\n    pointerEvent.originalEvent = event;\r\n    pointerEvent.type          = eventType;\r\n    pointerEvent.pointerId     = utils.getPointerId(pointer);\r\n    pointerEvent.pointerType   = interaction.mouse? 'mouse' : !browser.supportsPointerEvent? 'touch'\r\n      : utils.isString(pointer.pointerType)\r\n        ? pointer.pointerType\r\n        : [undefined, undefined,'touch', 'pen', 'mouse'][pointer.pointerType];\r\n  }\r\n\r\n  if (eventType === 'tap') {\r\n    pointerEvent.dt = pointerEvent.timeStamp - interaction.downTimes[pointerIndex];\r\n\r\n    interval = pointerEvent.timeStamp - interaction.tapTime;\r\n    createNewDoubleTap = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap'\r\n                            && interaction.prevTap.target === pointerEvent.target\r\n                            && interval < 500);\r\n\r\n    pointerEvent.double = createNewDoubleTap;\r\n\r\n    interaction.tapTime = pointerEvent.timeStamp;\r\n  }\r\n\r\n  const signalArg = {\r\n    pointerEvent,\r\n    pointer,\r\n    event,\r\n    targets,\r\n  };\r\n\r\n  signals.fire('new', signalArg);\r\n\r\n  for (i = 0; i < targets.length; i++) {\r\n    const target = targets[i];\r\n\r\n    pointerEvent.currentTarget = target.element;\r\n\r\n    for (const prop in target.props || {}) {\r\n      pointerEvent[prop] = target.props[prop];\r\n    }\r\n\r\n    target.eventable.fire(pointerEvent);\r\n\r\n    if (pointerEvent.immediatePropagationStopped\r\n        || (pointerEvent.propagationStopped\r\n            && (i + 1) < targets.length && targets[i + 1].element !== pointerEvent.currentTarget)) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  signals.fire('fired', signalArg);\r\n\r\n  if (createNewDoubleTap) {\r\n    const doubleTap = {};\r\n\r\n    utils.extend(doubleTap, pointerEvent);\r\n\r\n    doubleTap.dt   = interval;\r\n    doubleTap.type = 'doubletap';\r\n\r\n    collectEventTargets(interaction, doubleTap, event, eventTarget, 'doubletap');\r\n\r\n    interaction.prevTap = doubleTap;\r\n  }\r\n  else if (eventType === 'tap') {\r\n    interaction.prevTap = pointerEvent;\r\n  }\r\n}\r\n\r\nfunction collectEventTargets (interaction, pointer, event, eventTarget, eventType) {\r\n  const pointerIndex = interaction.mouse? 0 : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer));\r\n\r\n  // do not fire a tap event if the pointer was moved before being lifted\r\n  if (eventType === 'tap' && (interaction.pointerWasMoved\r\n      // or if the pointerup target is different to the pointerdown target\r\n      || !(interaction.downTargets[pointerIndex] && interaction.downTargets[pointerIndex] === eventTarget))) {\r\n    return;\r\n  }\r\n\r\n  const targets = [];\r\n  const path = utils.getPath(eventTarget);\r\n  const signalArg = {\r\n    targets,\r\n    interaction,\r\n    pointer,\r\n    event,\r\n    eventTarget,\r\n    eventType,\r\n    path,\r\n    element: null,\r\n  };\r\n\r\n  for (const element of path) {\r\n    signalArg.element = element;\r\n\r\n    signals.fire('collect-targets', signalArg);\r\n  }\r\n\r\n  // create the tap event even if there are no listeners so that\r\n  // doubletap can still be created and fired\r\n  if (targets.length || eventType === 'tap') {\r\n    firePointers(interaction, pointer, event, eventTarget, targets, eventType);\r\n  }\r\n}\r\n\r\nInteraction.signals.on('move', function ({ interaction, pointer, event, eventTarget, duplicateMove }) {\r\n  const pointerIndex = (interaction.mouse\r\n    ? 0\r\n    : utils.indexOf(interaction.pointerIds, utils.getPointerId(pointer)));\r\n\r\n  if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\r\n    if (interaction.pointerIsDown) {\r\n      clearTimeout(interaction.holdTimers[pointerIndex]);\r\n    }\r\n\r\n    collectEventTargets(interaction, pointer, event, eventTarget, 'move');\r\n  }\r\n});\r\n\r\nInteraction.signals.on('down', function ({ interaction, pointer, event, eventTarget, pointerIndex }) {\r\n  // copy event to be used in timeout for IE8\r\n  const eventCopy = browser.isIE8? utils.extend({}, event) : event;\r\n\r\n  interaction.holdTimers[pointerIndex] = setTimeout(function () {\r\n\r\n    collectEventTargets(interaction,\r\n                        browser.isIE8? eventCopy : pointer,\r\n                        eventCopy,\r\n                        eventTarget,\r\n                        'hold');\r\n\r\n  }, defaults._holdDuration);\r\n});\r\n\r\nfunction createSignalListener (event) {\r\n  return function (arg) {\r\n    collectEventTargets(arg.interaction,\r\n                        arg.pointer,\r\n                        arg.event,\r\n                        arg.eventTarget,\r\n                        event);\r\n  };\r\n}\r\n\r\nfor (let i = 0; i < simpleSignals.length; i++) {\r\n  Interaction.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i]));\r\n}\r\n\r\nInteraction.signals.on('new', function (interaction) {\r\n  interaction.prevTap = null;  // the most recent tap event on this interaction\r\n  interaction.tapTime = 0;     // time of the most recent tap event\r\n});\r\n\r\nmodule.exports = scope.pointerEvents = {\r\n  firePointers,\r\n  collectEventTargets,\r\n  preventOriginalDefault,\r\n  signals,\r\n  types: [\r\n    'down',\r\n    'move',\r\n    'up',\r\n    'cancel',\r\n    'tap',\r\n    'doubletap',\r\n    'hold',\r\n  ],\r\n};\r\n","const pointerEvents = require('./index');\r\nconst Interactable  = require('../Interactable');\r\nconst browser       = require('../utils/browser');\r\nconst isType        = require('../utils/isType');\r\nconst domUtils      = require('../utils/domUtils');\r\nconst scope         = require('../scope');\r\nconst { merge }     = require('../utils/arr');\r\n\r\npointerEvents.signals.on('collect-targets', function ({ targets, element, eventType }) {\r\n  function collectSelectors (interactable, selector, context) {\r\n    const els = browser.useMatchesSelectorPolyfill\r\n        ? context.querySelectorAll(selector)\r\n        : undefined;\r\n\r\n    const eventable = interactable._iEvents;\r\n\r\n    if (eventable[eventType]\r\n        && isType.isElement(element)\r\n        && interactable.inContext(element)\r\n        && domUtils.matchesSelector(element, selector, els)) {\r\n\r\n      targets.push({\r\n        element,\r\n        eventable,\r\n        props: { interactable },\r\n      });\r\n    }\r\n  }\r\n\r\n  const interactable = scope.interactables.get(element);\r\n\r\n  if (interactable) {\r\n    const eventable = interactable._iEvents;\r\n\r\n    if (eventable[eventType]) {\r\n      targets.push({\r\n        element,\r\n        eventable,\r\n        props: { interactable },\r\n      });\r\n    }\r\n  }\r\n\r\n  scope.interactables.forEachSelector(collectSelectors);\r\n});\r\n\r\nmerge(Interactable.eventTypes, pointerEvents.types);\r\n","const utils   = require('./utils');\r\nconst extend  = require('./utils/extend');\r\nconst events  = require('./utils/events');\r\nconst signals = require('./utils/Signals').new();\r\n\r\nconst scope = {\r\n  signals,\r\n  events,\r\n  utils,\r\n\r\n  documents: [],  // all documents being listened to\r\n\r\n  addDocument: function (doc, win) {\r\n    // do nothing if document is already known\r\n    if (utils.contains(scope.documents, doc)) { return false; }\r\n\r\n    win = win || scope.getWindow(doc);\r\n\r\n    scope.documents.push(doc);\r\n    events.documents.push(doc);\r\n\r\n    // don't add an unload event for the main document\r\n    // so that the page may be cached in browser history\r\n    if (doc !== scope.document) {\r\n      events.add(win, 'unload', scope.onWindowUnload);\r\n    }\r\n\r\n    signals.fire('add-document', { doc, win });\r\n  },\r\n\r\n  removeDocument: function (doc, win) {\r\n    const index = utils.indexOf(scope.documents, doc);\r\n\r\n    win = win || scope.getWindow(doc);\r\n\r\n    events.remove(win, 'unload', scope.onWindowUnload);\r\n\r\n    scope.documents.splice(index, 1);\r\n    events.documents.splice(index, 1);\r\n\r\n    signals.fire('remove-document', { win, doc });\r\n  },\r\n\r\n  onWindowUnload: function () {\r\n    scope.removeDocument(this.document, this);\r\n  },\r\n};\r\n\r\nextend(scope, require('./utils/window'));\r\nextend(scope, require('./utils/domObjects'));\r\n\r\nmodule.exports = scope;\r\n","const { indexOf } = require('./arr');\r\n\r\nclass Signals {\r\n  constructor () {\r\n    this.listeners = {\r\n      // signalName: [listeners],\r\n    };\r\n  }\r\n\r\n  on (name, listener) {\r\n    if (!this.listeners[name]) {\r\n      this.listeners[name] = [listener];\r\n      return;\r\n    }\r\n\r\n    this.listeners[name].push(listener);\r\n  }\r\n\r\n  off (name, listener) {\r\n    if (!this.listeners[name]) { return; }\r\n\r\n    const index = indexOf(this.listeners[name], listener);\r\n\r\n    if (index !== -1) {\r\n      this.listeners[name].splice(index, 1);\r\n    }\r\n  }\r\n\r\n  fire (name, arg) {\r\n    const targetListeners = this.listeners[name];\r\n\r\n    if (!targetListeners) { return; }\r\n\r\n    for (let i = 0; i < targetListeners.length; i++) {\r\n      if (targetListeners[i](arg, name) === false) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nSignals.new = function () {\r\n  return new Signals();\r\n};\r\n\r\nmodule.exports = Signals;\r\n","function indexOf (array, target) {\r\n  for (let i = 0, len = array.length; i < len; i++) {\r\n    if (array[i] === target) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nfunction contains (array, target) {\r\n  return indexOf(array, target) !== -1;\r\n}\r\n\r\nfunction merge (target, source) {\r\n  for (let i = 0; i < source.length; i++) {\r\n    target.push(source[i]);\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nmodule.exports = {\r\n  indexOf,\r\n  contains,\r\n  merge,\r\n};\r\n","const win        = require('./window');\r\nconst isType     = require('./isType');\r\nconst domObjects = require('./domObjects');\r\n\r\nconst browser = {\r\n  // Does the browser support touch input?\r\n  supportsTouch: !!(('ontouchstart' in win.window) || isType.isFunction(win.window.DocumentTouch)\r\n                     && domObjects.document instanceof win.DocumentTouch),\r\n\r\n  // Does the browser support PointerEvents\r\n  supportsPointerEvent: !!domObjects.PointerEvent,\r\n\r\n  isIE8: ('attachEvent' in win.window) && !('addEventListener' in win.window),\r\n\r\n  // Opera Mobile must be handled differently\r\n  isOperaMobile: (navigator.appName === 'Opera'\r\n      && browser.supportsTouch\r\n      && navigator.userAgent.match('Presto')),\r\n\r\n  // scrolling doesn't change the result of getClientRects on iOS 7\r\n  isIOS7: (/iP(hone|od|ad)/.test(navigator.platform)\r\n           && /OS 7[^\\d]/.test(navigator.appVersion)),\r\n\r\n  isIe9OrOlder: domObjects.document.all && !win.window.atob,\r\n\r\n  // prefix matchesSelector\r\n  prefixedMatchesSelector: 'matches' in Element.prototype\r\n    ? 'matches': 'webkitMatchesSelector' in Element.prototype\r\n    ? 'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype\r\n    ? 'mozMatchesSelector': 'oMatchesSelector' in Element.prototype\r\n    ? 'oMatchesSelector': 'msMatchesSelector',\r\n\r\n  useMatchesSelectorPolyfill: false,\r\n\r\n  pEventTypes: (domObjects.PointerEvent\r\n    ? (domObjects.PointerEvent === win.window.MSPointerEvent\r\n      ? { up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\r\n          out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' }\r\n      : { up: 'pointerup', down: 'pointerdown', over: 'pointerover',\r\n          out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' })\r\n    : null),\r\n\r\n  // because Webkit and Opera still use 'mousewheel' event type\r\n  wheelEvent: 'onmousewheel' in domObjects.document? 'mousewheel': 'wheel',\r\n\r\n};\r\n\r\nbrowser.useMatchesSelectorPolyfill = !isType.isFunction(Element.prototype[browser.prefixedMatchesSelector]);\r\n\r\nmodule.exports = browser;\r\n","const domObjects = {};\r\nconst win = require('./window').window;\r\n\r\nfunction blank () {}\r\n\r\ndomObjects.document           = win.document;\r\ndomObjects.DocumentFragment   = win.DocumentFragment   || blank;\r\ndomObjects.SVGElement         = win.SVGElement         || blank;\r\ndomObjects.SVGSVGElement      = win.SVGSVGElement      || blank;\r\ndomObjects.SVGElementInstance = win.SVGElementInstance || blank;\r\ndomObjects.HTMLElement        = win.HTMLElement        || win.Element;\r\n\r\ndomObjects.Event        = win.Event;\r\ndomObjects.Touch        = win.Touch || blank;\r\ndomObjects.PointerEvent = (win.PointerEvent || win.MSPointerEvent);\r\n\r\nmodule.exports = domObjects;\r\n","const win        = require('./window');\r\nconst browser    = require('./browser');\r\nconst isType     = require('./isType');\r\nconst domObjects = require('./domObjects');\r\n\r\nconst domUtils = {\r\n  nodeContains: function (parent, child) {\r\n    while (child) {\r\n      if (child === parent) {\r\n        return true;\r\n      }\r\n\r\n      child = child.parentNode;\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  closest: function (element, selector) {\r\n    while (isType.isElement(element)) {\r\n      if (domUtils.matchesSelector(element, selector)) { return element; }\r\n\r\n      element = domUtils.parentNode(element);\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  parentNode: function (node) {\r\n    let parent = node.parentNode;\r\n\r\n    if (isType.isDocFrag(parent)) {\r\n      // skip past #shado-root fragments\r\n      while ((parent = parent.host) && isType.isDocFrag(parent)) {\r\n        continue;\r\n      }\r\n\r\n      return parent;\r\n    }\r\n\r\n    return parent;\r\n  },\r\n\r\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\r\n  matchesSelectorPolyfill: browser.useMatchesSelectorPolyfill\r\n    ? function (element, selector, elems) {\r\n      elems = elems || element.parentNode.querySelectorAll(selector);\r\n\r\n      for (let i = 0, len = elems.length; i < len; i++) {\r\n        if (elems[i] === element) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n    : null,\r\n\r\n  matchesSelector: function (element, selector, nodeList) {\r\n    if (browser.useMatchesSelectorPolyfill) {\r\n      return domUtils.matchesSelectorPolyfill(element, selector, nodeList);\r\n    }\r\n\r\n    // remove /deep/ from selectors if shadowDOM polyfill is used\r\n    if (win.window !== win.realWindow) {\r\n      selector = selector.replace(/\\/deep\\//g, ' ');\r\n    }\r\n\r\n    return element[browser.prefixedMatchesSelector](selector);\r\n  },\r\n\r\n  // Test for the element that's \"above\" all other qualifiers\r\n  indexOfDeepestElement: function (elements) {\r\n    let deepestZoneParents = [];\r\n    let dropzoneParents = [];\r\n    let dropzone;\r\n    let deepestZone = elements[0];\r\n    let index = deepestZone? 0: -1;\r\n    let parent;\r\n    let child;\r\n    let i;\r\n    let n;\r\n\r\n    for (i = 1; i < elements.length; i++) {\r\n      dropzone = elements[i];\r\n\r\n      // an element might belong to multiple selector dropzones\r\n      if (!dropzone || dropzone === deepestZone) {\r\n        continue;\r\n      }\r\n\r\n      if (!deepestZone) {\r\n        deepestZone = dropzone;\r\n        index = i;\r\n        continue;\r\n      }\r\n\r\n      // check if the deepest or current are document.documentElement or document.rootElement\r\n      // - if the current dropzone is, do nothing and continue\r\n      if (dropzone.parentNode === dropzone.ownerDocument) {\r\n        continue;\r\n      }\r\n      // - if deepest is, update with the current dropzone and continue to next\r\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\r\n        deepestZone = dropzone;\r\n        index = i;\r\n        continue;\r\n      }\r\n\r\n      if (!deepestZoneParents.length) {\r\n        parent = deepestZone;\r\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\r\n          deepestZoneParents.unshift(parent);\r\n          parent = parent.parentNode;\r\n        }\r\n      }\r\n\r\n      // if this element is an svg element and the current deepest is\r\n      // an HTMLElement\r\n      if (deepestZone instanceof domObjects.HTMLElement\r\n          && dropzone instanceof domObjects.SVGElement\r\n          && !(dropzone instanceof domObjects.SVGSVGElement)) {\r\n\r\n        if (dropzone === deepestZone.parentNode) {\r\n          continue;\r\n        }\r\n\r\n        parent = dropzone.ownerSVGElement;\r\n      }\r\n      else {\r\n        parent = dropzone;\r\n      }\r\n\r\n      dropzoneParents = [];\r\n\r\n      while (parent.parentNode !== parent.ownerDocument) {\r\n        dropzoneParents.unshift(parent);\r\n        parent = parent.parentNode;\r\n      }\r\n\r\n      n = 0;\r\n\r\n      // get (position of last common ancestor) + 1\r\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\r\n        n++;\r\n      }\r\n\r\n      const parents = [\r\n        dropzoneParents[n - 1],\r\n        dropzoneParents[n],\r\n        deepestZoneParents[n],\r\n      ];\r\n\r\n      child = parents[0].lastChild;\r\n\r\n      while (child) {\r\n        if (child === parents[1]) {\r\n          deepestZone = dropzone;\r\n          index = i;\r\n          deepestZoneParents = [];\r\n\r\n          break;\r\n        }\r\n        else if (child === parents[2]) {\r\n          break;\r\n        }\r\n\r\n        child = child.previousSibling;\r\n      }\r\n    }\r\n\r\n    return index;\r\n  },\r\n\r\n  matchesUpTo: function (element, selector, limit) {\r\n    while (isType.isElement(element)) {\r\n      if (domUtils.matchesSelector(element, selector)) {\r\n        return true;\r\n      }\r\n\r\n      element = domUtils.parentNode(element);\r\n\r\n      if (element === limit) {\r\n        return domUtils.matchesSelector(element, selector);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  },\r\n\r\n  getActualElement: function (element) {\r\n    return (element instanceof domObjects.SVGElementInstance\r\n      ? element.correspondingUseElement\r\n      : element);\r\n  },\r\n\r\n  getScrollXY: function (relevantWindow) {\r\n    relevantWindow = relevantWindow || win.window;\r\n    return {\r\n      x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\r\n      y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\r\n    };\r\n  },\r\n\r\n  getElementClientRect: function (element) {\r\n    const clientRect = (element instanceof domObjects.SVGElement\r\n      ? element.getBoundingClientRect()\r\n      : element.getClientRects()[0]);\r\n\r\n    return clientRect && {\r\n      left  : clientRect.left,\r\n      right : clientRect.right,\r\n      top   : clientRect.top,\r\n      bottom: clientRect.bottom,\r\n      width : clientRect.width  || clientRect.right  - clientRect.left,\r\n      height: clientRect.height || clientRect.bottom - clientRect.top,\r\n    };\r\n  },\r\n\r\n  getElementRect: function (element) {\r\n    const clientRect = domUtils.getElementClientRect(element);\r\n\r\n    if (!browser.isIOS7 && clientRect) {\r\n      const scroll = domUtils.getScrollXY(win.getWindow(element));\r\n\r\n      clientRect.left   += scroll.x;\r\n      clientRect.right  += scroll.x;\r\n      clientRect.top    += scroll.y;\r\n      clientRect.bottom += scroll.y;\r\n    }\r\n\r\n    return clientRect;\r\n  },\r\n\r\n  getPath: function (element) {\r\n    const path = [];\r\n\r\n    while (element) {\r\n      path.push(element);\r\n      element = domUtils.parentNode(element);\r\n    }\r\n\r\n    return path;\r\n  },\r\n};\r\n\r\nmodule.exports = domUtils;\r\n","const arr       = require('./arr');\r\nconst isType    = require('./isType');\r\nconst domUtils  = require('./domUtils');\r\nconst indexOf   = arr.indexOf;\r\nconst contains  = arr.contains;\r\nconst getWindow = require('./window').getWindow;\r\nconst pExtend   = require('./pointerExtend');\r\n\r\nconst useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window);\r\nconst addEvent       = useAttachEvent?  'attachEvent': 'addEventListener';\r\nconst removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener';\r\nconst on             = useAttachEvent? 'on': '';\r\n\r\nconst elements          = [];\r\nconst targets           = [];\r\nconst attachedListeners = [];\r\n\r\n// {\r\n//   type: {\r\n//     selectors: ['selector', ...],\r\n//     contexts : [document, ...],\r\n//     listeners: [[listener, useCapture], ...]\r\n//   }\r\n//  }\r\nconst delegatedEvents = {};\r\n\r\nconst documents = [];\r\n\r\nfunction add (element, type, listener, useCapture) {\r\n  let elementIndex = indexOf(elements, element);\r\n  let target = targets[elementIndex];\r\n\r\n  if (!target) {\r\n    target = {\r\n      events: {},\r\n      typeCount: 0,\r\n    };\r\n\r\n    elementIndex = elements.push(element) - 1;\r\n    targets.push(target);\r\n\r\n    attachedListeners.push((useAttachEvent ? {\r\n      supplied: [],\r\n      wrapped : [],\r\n      useCount: [],\r\n    } : null));\r\n  }\r\n\r\n  if (!target.events[type]) {\r\n    target.events[type] = [];\r\n    target.typeCount++;\r\n  }\r\n\r\n  if (!contains(target.events[type], listener)) {\r\n    let ret;\r\n\r\n    if (useAttachEvent) {\r\n      const { supplied, wrapped, useCount } = attachedListeners[elementIndex];\r\n      const listenerIndex = indexOf(supplied, listener);\r\n\r\n      const wrappedListener = wrapped[listenerIndex] || function (event) {\r\n        if (!event.immediatePropagationStopped) {\r\n          event.target = event.srcElement;\r\n          event.currentTarget = element;\r\n\r\n          event.preventDefault           = event.preventDefault           || preventDef;\r\n          event.stopPropagation          = event.stopPropagation          || stopProp;\r\n          event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\r\n\r\n          if (/mouse|click/.test(event.type)) {\r\n            event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\r\n            event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\r\n          }\r\n\r\n          listener(event);\r\n        }\r\n      };\r\n\r\n      ret = element[addEvent](on + type, wrappedListener, !!useCapture);\r\n\r\n      if (listenerIndex === -1) {\r\n        supplied.push(listener);\r\n        wrapped.push(wrappedListener);\r\n        useCount.push(1);\r\n      }\r\n      else {\r\n        useCount[listenerIndex]++;\r\n      }\r\n    }\r\n    else {\r\n      ret = element[addEvent](type, listener, !!useCapture);\r\n    }\r\n    target.events[type].push(listener);\r\n\r\n    return ret;\r\n  }\r\n}\r\n\r\nfunction remove (element, type, listener, useCapture) {\r\n  const elementIndex = indexOf(elements, element);\r\n  const target = targets[elementIndex];\r\n\r\n  if (!target || !target.events) {\r\n    return;\r\n  }\r\n\r\n  let wrappedListener = listener;\r\n  let listeners;\r\n  let listenerIndex;\r\n\r\n  if (useAttachEvent) {\r\n    listeners = attachedListeners[elementIndex];\r\n    listenerIndex = indexOf(listeners.supplied, listener);\r\n    wrappedListener = listeners.wrapped[listenerIndex];\r\n  }\r\n\r\n  if (type === 'all') {\r\n    for (type in target.events) {\r\n      if (target.events.hasOwnProperty(type)) {\r\n        remove(element, type, 'all');\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (target.events[type]) {\r\n    const len = target.events[type].length;\r\n\r\n    if (listener === 'all') {\r\n      for (let i = 0; i < len; i++) {\r\n        remove(element, type, target.events[type][i], !!useCapture);\r\n      }\r\n      return;\r\n    }\r\n    else {\r\n      for (let i = 0; i < len; i++) {\r\n        if (target.events[type][i] === listener) {\r\n          element[removeEvent](on + type, wrappedListener, !!useCapture);\r\n          target.events[type].splice(i, 1);\r\n\r\n          if (useAttachEvent && listeners) {\r\n            listeners.useCount[listenerIndex]--;\r\n            if (listeners.useCount[listenerIndex] === 0) {\r\n              listeners.supplied.splice(listenerIndex, 1);\r\n              listeners.wrapped.splice(listenerIndex, 1);\r\n              listeners.useCount.splice(listenerIndex, 1);\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (target.events[type] && target.events[type].length === 0) {\r\n      target.events[type] = null;\r\n      target.typeCount--;\r\n    }\r\n  }\r\n\r\n  if (!target.typeCount) {\r\n    targets.splice(elementIndex, 1);\r\n    elements.splice(elementIndex, 1);\r\n    attachedListeners.splice(elementIndex, 1);\r\n  }\r\n}\r\n\r\nfunction addDelegate (selector, context, type, listener, useCapture) {\r\n  if (!delegatedEvents[type]) {\r\n    delegatedEvents[type] = {\r\n      selectors: [],\r\n      contexts : [],\r\n      listeners: [],\r\n    };\r\n\r\n    // add delegate listener functions\r\n    for (let i = 0; i < documents.length; i++) {\r\n      add(documents[i], type, delegateListener);\r\n      add(documents[i], type, delegateUseCapture, true);\r\n    }\r\n  }\r\n\r\n  const delegated = delegatedEvents[type];\r\n  let index;\r\n\r\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\r\n    if (delegated.selectors[index] === selector\r\n        && delegated.contexts[index] === context) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (index === -1) {\r\n    index = delegated.selectors.length;\r\n\r\n    delegated.selectors.push(selector);\r\n    delegated.contexts .push(context);\r\n    delegated.listeners.push([]);\r\n  }\r\n\r\n  // keep listener and useCapture flag\r\n  delegated.listeners[index].push([listener, useCapture]);\r\n}\r\n\r\nfunction removeDelegate (selector, context, type, listener, useCapture) {\r\n  const delegated = delegatedEvents[type];\r\n  let matchFound = false;\r\n  let index;\r\n\r\n  if (!delegated) { return; }\r\n\r\n  // count from last index of delegated to 0\r\n  for (index = delegated.selectors.length - 1; index >= 0; index--) {\r\n    // look for matching selector and context Node\r\n    if (delegated.selectors[index] === selector\r\n        && delegated.contexts[index] === context) {\r\n\r\n      const listeners = delegated.listeners[index];\r\n\r\n      // each item of the listeners array is an array: [function, useCaptureFlag]\r\n      for (let i = listeners.length - 1; i >= 0; i--) {\r\n        const fn = listeners[i][0];\r\n        const useCap = listeners[i][1];\r\n\r\n        // check if the listener functions and useCapture flags match\r\n        if (fn === listener && useCap === useCapture) {\r\n          // remove the listener from the array of listeners\r\n          listeners.splice(i, 1);\r\n\r\n          // if all listeners for this interactable have been removed\r\n          // remove the interactable from the delegated arrays\r\n          if (!listeners.length) {\r\n            delegated.selectors.splice(index, 1);\r\n            delegated.contexts .splice(index, 1);\r\n            delegated.listeners.splice(index, 1);\r\n\r\n            // remove delegate function from context\r\n            remove(context, type, delegateListener);\r\n            remove(context, type, delegateUseCapture, true);\r\n\r\n            // remove the arrays if they are empty\r\n            if (!delegated.selectors.length) {\r\n              delegatedEvents[type] = null;\r\n            }\r\n          }\r\n\r\n          // only remove one listener\r\n          matchFound = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (matchFound) { break; }\r\n    }\r\n  }\r\n}\r\n\r\n// bound to the interactable context when a DOM event\r\n// listener is added to a selector interactable\r\nfunction delegateListener (event, useCapture) {\r\n  const fakeEvent = {};\r\n  const delegated = delegatedEvents[event.type];\r\n  const eventTarget = (domUtils.getActualElement(event.path\r\n    ? event.path[0]\r\n    : event.target));\r\n  let element = eventTarget;\r\n\r\n  useCapture = useCapture? true: false;\r\n\r\n  // duplicate the event so that currentTarget can be changed\r\n  pExtend(fakeEvent, event);\r\n\r\n  fakeEvent.originalEvent = event;\r\n  fakeEvent.preventDefault = preventOriginalDefault;\r\n\r\n  // climb up document tree looking for selector matches\r\n  while (isType.isElement(element)) {\r\n    for (let i = 0; i < delegated.selectors.length; i++) {\r\n      const selector = delegated.selectors[i];\r\n      const context = delegated.contexts[i];\r\n\r\n      if (domUtils.matchesSelector(element, selector)\r\n          && domUtils.nodeContains(context, eventTarget)\r\n          && domUtils.nodeContains(context, element)) {\r\n\r\n        const listeners = delegated.listeners[i];\r\n\r\n        fakeEvent.currentTarget = element;\r\n\r\n        for (let j = 0; j < listeners.length; j++) {\r\n          if (listeners[j][1] === useCapture) {\r\n            listeners[j][0](fakeEvent);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    element = domUtils.parentNode(element);\r\n  }\r\n}\r\n\r\nfunction delegateUseCapture (event) {\r\n  return delegateListener.call(this, event, true);\r\n}\r\n\r\nfunction preventDef () {\r\n  this.returnValue = false;\r\n}\r\n\r\nfunction preventOriginalDefault () {\r\n  this.originalEvent.preventDefault();\r\n}\r\n\r\nfunction stopProp () {\r\n  this.cancelBubble = true;\r\n}\r\n\r\nfunction stopImmProp () {\r\n  this.cancelBubble = true;\r\n  this.immediatePropagationStopped = true;\r\n}\r\n\r\nmodule.exports = {\r\n  add,\r\n  remove,\r\n\r\n  addDelegate,\r\n  removeDelegate,\r\n\r\n  delegateListener,\r\n  delegateUseCapture,\r\n  delegatedEvents,\r\n  documents,\r\n\r\n  useAttachEvent,\r\n\r\n  _elements: elements,\r\n  _targets: targets,\r\n  _attachedListeners: attachedListeners,\r\n};\r\n","module.exports = function extend (dest, source) {\r\n  for (const prop in source) {\r\n    dest[prop] = source[prop];\r\n  }\r\n  return dest;\r\n};\r\n","const { closest, parentNode, getElementRect } = require('./domUtils');\r\nconst { isElement, isFunction, trySelector }  = require('./isType');\r\n\r\nmodule.exports = function (interactable, element) {\r\n  let origin = interactable.options.origin;\r\n\r\n  if (origin === 'parent') {\r\n    origin = parentNode(element);\r\n  }\r\n  else if (origin === 'self') {\r\n    origin = interactable.getRect(element);\r\n  }\r\n  else if (trySelector(origin)) {\r\n    origin = closest(element, origin) || { x: 0, y: 0 };\r\n  }\r\n\r\n  if (isFunction(origin)) {\r\n    origin = origin(interactable && element);\r\n  }\r\n\r\n  if (isElement(origin))  {\r\n    origin = getElementRect(origin);\r\n  }\r\n\r\n  origin.x = ('x' in origin)? origin.x : origin.left;\r\n  origin.y = ('y' in origin)? origin.y : origin.top;\r\n\r\n  return origin;\r\n};\r\n","module.exports = (x, y) =>  Math.sqrt(x * x + y * y);\r\n","const extend = require('./extend');\r\nconst win    = require('./window');\r\n\r\nconst utils = {\r\n  warnOnce: function (method, message) {\r\n    let warned = false;\r\n\r\n    return function () {\r\n      if (!warned) {\r\n        win.window.console.warn(message);\r\n        warned = true;\r\n      }\r\n\r\n      return method.apply(this, arguments);\r\n    };\r\n  },\r\n\r\n  // http://stackoverflow.com/a/5634528/2280888\r\n  _getQBezierValue: function (t, p1, p2, p3) {\r\n    const iT = 1 - t;\r\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\r\n  },\r\n\r\n  getQuadraticCurvePoint: function (startX, startY, cpX, cpY, endX, endY, position) {\r\n    return {\r\n      x:  utils._getQBezierValue(position, startX, cpX, endX),\r\n      y:  utils._getQBezierValue(position, startY, cpY, endY),\r\n    };\r\n  },\r\n\r\n  // http://gizma.com/easing/\r\n  easeOutQuad: function (t, b, c, d) {\r\n    t /= d;\r\n    return -c * t*(t-2) + b;\r\n  },\r\n\r\n  copyAction: function (dest, src) {\r\n    dest.name  = src.name;\r\n    dest.axis  = src.axis;\r\n    dest.edges = src.edges;\r\n\r\n    return dest;\r\n  },\r\n\r\n  extend     : extend,\r\n  hypot      : require('./hypot'),\r\n  getOriginXY: require('./getOriginXY'),\r\n};\r\n\r\nextend(utils, require('./arr'));\r\nextend(utils, require('./isType'));\r\nextend(utils, require('./domUtils'));\r\nextend(utils, require('./pointerUtils'));\r\n\r\nmodule.exports = utils;\r\n","const scope   = require('../scope');\r\nconst utils   = require('./index');\r\nconst browser = require('./browser');\r\n\r\nconst finder = {\r\n  methodOrder: [ 'simulationResume', 'mouse', 'hasPointer', 'idle' ],\r\n\r\n  search: function (pointer, eventType, eventTarget) {\r\n    const mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\r\n                        // MSPointerEvent.MSPOINTER_TYPE_MOUSE\r\n                        || pointer.pointerType === 4);\r\n    const pointerId = utils.getPointerId(pointer);\r\n    const details = { pointer, pointerId, mouseEvent, eventType, eventTarget };\r\n\r\n    for (const method of finder.methodOrder) {\r\n      const interaction = finder[method](details);\r\n\r\n      if (interaction) {\r\n        return interaction;\r\n      }\r\n    }\r\n  },\r\n\r\n  // try to resume simulation with a new pointer\r\n  simulationResume: function ({ mouseEvent, eventType, eventTarget }) {\r\n    if (!/down|start/i.test(eventType)) {\r\n      return null;\r\n    }\r\n\r\n    for (const interaction of scope.interactions) {\r\n      let element = eventTarget;\r\n\r\n      if (interaction.simulation && interaction.simulation.allowResume\r\n          && (interaction.mouse === mouseEvent)) {\r\n        while (element) {\r\n          // if the element is the interaction element\r\n          if (element === interaction.element) {\r\n            return interaction;\r\n          }\r\n          element = utils.parentNode(element);\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  // if it's a mouse interaction\r\n  mouse: function ({ pointerId, mouseEvent, eventType }) {\r\n    if (!mouseEvent && (browser.supportsTouch || browser.supportsPointerEvent)) {\r\n      return null;\r\n    }\r\n\r\n    let firstNonActive;\r\n\r\n    for (const interaction of scope.interactions) {\r\n      if (interaction.mouse) {\r\n        // if it's a down event, skip interactions with running simulations\r\n        if (interaction.simulation && !utils.contains(interaction.pointerIds, pointerId)) { continue; }\r\n\r\n        // if the interaction is active, return it immediately\r\n        if (interaction.interacting()) {\r\n          return interaction;\r\n        }\r\n        // otherwise save it and look for another active interaction\r\n        else if (!firstNonActive) {\r\n          firstNonActive = interaction;\r\n        }\r\n      }\r\n    }\r\n\r\n    // if no active mouse interaction was found use the first inactive mouse\r\n    // interaction\r\n    if (firstNonActive) {\r\n      return firstNonActive;\r\n    }\r\n\r\n    // Find any interaction specifically for mouse.\r\n    // ignore the interaction if the eventType is a mousedown, and a simulation\r\n    // is active\r\n    for (const interaction of scope.interactions) {\r\n      if (interaction.mouse && !(/down/.test(eventType) && interaction.simulation)) {\r\n        return interaction;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n\r\n  // get interaction that has this pointer\r\n  hasPointer: function ({ pointerId }) {\r\n    for (const interaction of scope.interactions) {\r\n      if (utils.contains(interaction.pointerIds, pointerId)) {\r\n        return interaction;\r\n      }\r\n    }\r\n  },\r\n\r\n  // get first idle interaction\r\n  idle: function ({ mouseEvent }) {\r\n    for (const interaction of scope.interactions) {\r\n      // if there's already a pointer held down\r\n      if (interaction.pointerIds.length === 1) {\r\n        const target = interaction.target;\r\n        // don't add this pointer if there is a target interactable and it\r\n        // isn't gesturable\r\n        if (target && !target.options.gesture.enabled) {\r\n          continue;\r\n        }\r\n      }\r\n      // maximum of 2 pointers per interaction\r\n      else if (interaction.pointerIds.length >= 2) {\r\n        continue;\r\n      }\r\n\r\n      if (!interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\r\n        return interaction;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  },\r\n};\r\n\r\nmodule.exports = finder;\r\n","const win        = require('./window');\r\nconst isWindow   = require('./isWindow');\r\nconst domObjects = require('./domObjects');\r\n\r\nconst isType = {\r\n  isElement  : function (o) {\r\n    if (!o || (typeof o !== 'object')) { return false; }\r\n\r\n    const _window = win.getWindow(o) || win.window;\r\n\r\n    return (/object|function/.test(typeof _window.Element)\r\n      ? o instanceof _window.Element //DOM2\r\n      : o.nodeType === 1 && typeof o.nodeName === 'string');\r\n  },\r\n\r\n  isArray    : null,\r\n\r\n  isWindow   : function (thing) { return thing === win.window || isWindow(thing); },\r\n\r\n  isDocFrag  : function (thing) { return isType.isObject(thing) && thing.nodeType === 11; },\r\n\r\n  isObject   : function (thing) { return !!thing && (typeof thing === 'object'); },\r\n\r\n  isFunction : function (thing) { return typeof thing === 'function'; },\r\n\r\n  isNumber   : function (thing) { return typeof thing === 'number'  ; },\r\n\r\n  isBool     : function (thing) { return typeof thing === 'boolean' ; },\r\n\r\n  isString   : function (thing) { return typeof thing === 'string'  ; },\r\n\r\n  trySelector: function (value) {\r\n    if (!isType.isString(value)) { return false; }\r\n\r\n    // an exception will be raised if it is invalid\r\n    domObjects.document.querySelector(value);\r\n    return true;\r\n  },\r\n};\r\n\r\nisType.isArray = function (thing) {\r\n  return (isType.isObject(thing)\r\n      && (typeof thing.length !== 'undefined')\r\n      && isType.isFunction(thing.splice));\r\n};\r\n\r\nmodule.exports = isType;\r\n","module.exports = (thing) => !!(thing && thing.Window) && (thing instanceof thing.Window);\r\n","function pointerExtend (dest, source) {\r\n  for (const prop in source) {\r\n    const prefixedPropREs = module.exports.prefixedPropREs;\r\n    let deprecated = false;\r\n\r\n    // skip deprecated prefixed properties\r\n    for (const vendor in prefixedPropREs) {\r\n      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\r\n        deprecated = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!deprecated) {\r\n      dest[prop] = source[prop];\r\n    }\r\n  }\r\n  return dest;\r\n}\r\n\r\npointerExtend.prefixedPropREs = {\r\n  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\r\n};\r\n\r\nmodule.exports = pointerExtend;\r\n","const hypot         = require('./hypot');\r\nconst browser       = require('./browser');\r\nconst dom           = require('./domObjects');\r\nconst isType        = require('./isType');\r\nconst pointerExtend = require('./pointerExtend');\r\n\r\nconst pointerUtils = {\r\n  copyCoords: function (dest, src) {\r\n    dest.page = dest.page || {};\r\n    dest.page.x = src.page.x;\r\n    dest.page.y = src.page.y;\r\n\r\n    dest.client = dest.client || {};\r\n    dest.client.x = src.client.x;\r\n    dest.client.y = src.client.y;\r\n\r\n    dest.timeStamp = src.timeStamp;\r\n  },\r\n\r\n  setCoordDeltas: function (targetObj, prev, cur) {\r\n    targetObj.page.x    = cur.page.x    - prev.page.x;\r\n    targetObj.page.y    = cur.page.y    - prev.page.y;\r\n    targetObj.client.x  = cur.client.x  - prev.client.x;\r\n    targetObj.client.y  = cur.client.y  - prev.client.y;\r\n    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;\r\n\r\n    // set pointer velocity\r\n    const dt = Math.max(targetObj.timeStamp / 1000, 0.001);\r\n\r\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\r\n    targetObj.page.vx      = targetObj.page.x / dt;\r\n    targetObj.page.vy      = targetObj.page.y / dt;\r\n\r\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\r\n    targetObj.client.vx    = targetObj.client.x / dt;\r\n    targetObj.client.vy    = targetObj.client.y / dt;\r\n  },\r\n\r\n  isNativePointer: function  (pointer) {\r\n    return (pointer instanceof dom.Event || pointer instanceof dom.Touch);\r\n  },\r\n\r\n  // Get specified X/Y coords for mouse or event.touches[0]\r\n  getXY: function (type, pointer, xy) {\r\n    xy = xy || {};\r\n    type = type || 'page';\r\n\r\n    xy.x = pointer[type + 'X'];\r\n    xy.y = pointer[type + 'Y'];\r\n\r\n    return xy;\r\n  },\r\n\r\n  getPageXY: function (pointer, page) {\r\n    page = page || {};\r\n\r\n    // Opera Mobile handles the viewport and scrolling oddly\r\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\r\n      pointerUtils.getXY('screen', pointer, page);\r\n\r\n      page.x += window.scrollX;\r\n      page.y += window.scrollY;\r\n    }\r\n    else {\r\n      pointerUtils.getXY('page', pointer, page);\r\n    }\r\n\r\n    return page;\r\n  },\r\n\r\n  getClientXY: function (pointer, client) {\r\n    client = client || {};\r\n\r\n    if (browser.isOperaMobile && pointerUtils.isNativePointer(pointer)) {\r\n      // Opera Mobile handles the viewport and scrolling oddly\r\n      pointerUtils.getXY('screen', pointer, client);\r\n    }\r\n    else {\r\n      pointerUtils.getXY('client', pointer, client);\r\n    }\r\n\r\n    return client;\r\n  },\r\n\r\n  getPointerId: function (pointer) {\r\n    return isType.isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\r\n  },\r\n\r\n  setCoords: function (targetObj, pointers, timeStamp) {\r\n    const pointer = (pointers.length > 1\r\n                     ? pointerUtils.pointerAverage(pointers)\r\n                     : pointers[0]);\r\n\r\n    const tmpXY = {};\r\n\r\n    pointerUtils.getPageXY(pointer, tmpXY);\r\n    targetObj.page.x = tmpXY.x;\r\n    targetObj.page.y = tmpXY.y;\r\n\r\n    pointerUtils.getClientXY(pointer, tmpXY);\r\n    targetObj.client.x = tmpXY.x;\r\n    targetObj.client.y = tmpXY.y;\r\n\r\n    targetObj.timeStamp = isType.isNumber(timeStamp) ? timeStamp :new Date().getTime();\r\n  },\r\n\r\n  pointerExtend: pointerExtend,\r\n\r\n  getTouchPair: function (event) {\r\n    const touches = [];\r\n\r\n    // array of touches is supplied\r\n    if (isType.isArray(event)) {\r\n      touches[0] = event[0];\r\n      touches[1] = event[1];\r\n    }\r\n    // an event\r\n    else {\r\n      if (event.type === 'touchend') {\r\n        if (event.touches.length === 1) {\r\n          touches[0] = event.touches[0];\r\n          touches[1] = event.changedTouches[0];\r\n        }\r\n        else if (event.touches.length === 0) {\r\n          touches[0] = event.changedTouches[0];\r\n          touches[1] = event.changedTouches[1];\r\n        }\r\n      }\r\n      else {\r\n        touches[0] = event.touches[0];\r\n        touches[1] = event.touches[1];\r\n      }\r\n    }\r\n\r\n    return touches;\r\n  },\r\n\r\n  pointerAverage: function (pointers) {\r\n    const average = {\r\n      pageX  : 0,\r\n      pageY  : 0,\r\n      clientX: 0,\r\n      clientY: 0,\r\n      screenX: 0,\r\n      screenY: 0,\r\n    };\r\n\r\n    for (const pointer of pointers) {\r\n      for (const prop in average) {\r\n        average[prop] += pointer[prop];\r\n      }\r\n    }\r\n    for (const prop in average) {\r\n      average[prop] /= pointers.length;\r\n    }\r\n\r\n    return average;\r\n  },\r\n\r\n  touchBBox: function (event) {\r\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\r\n      return;\r\n    }\r\n\r\n    const touches = pointerUtils.getTouchPair(event);\r\n    const minX = Math.min(touches[0].pageX, touches[1].pageX);\r\n    const minY = Math.min(touches[0].pageY, touches[1].pageY);\r\n    const maxX = Math.max(touches[0].pageX, touches[1].pageX);\r\n    const maxY = Math.max(touches[0].pageY, touches[1].pageY);\r\n\r\n    return {\r\n      x: minX,\r\n      y: minY,\r\n      left: minX,\r\n      top: minY,\r\n      width: maxX - minX,\r\n      height: maxY - minY,\r\n    };\r\n  },\r\n\r\n  touchDistance: function (event, deltaSource) {\r\n    deltaSource = deltaSource;\r\n\r\n    const sourceX = deltaSource + 'X';\r\n    const sourceY = deltaSource + 'Y';\r\n    const touches = pointerUtils.getTouchPair(event);\r\n\r\n\r\n    const dx = touches[0][sourceX] - touches[1][sourceX];\r\n    const dy = touches[0][sourceY] - touches[1][sourceY];\r\n\r\n    return hypot(dx, dy);\r\n  },\r\n\r\n  touchAngle: function (event, prevAngle, deltaSource) {\r\n    deltaSource = deltaSource;\r\n\r\n    const sourceX = deltaSource + 'X';\r\n    const sourceY = deltaSource + 'Y';\r\n    const touches = pointerUtils.getTouchPair(event);\r\n    const dx = touches[1][sourceX] - touches[0][sourceX];\r\n    const dy = touches[1][sourceY] - touches[0][sourceY];\r\n    const angle = 180 * Math.atan2(dy , dx) / Math.PI;\r\n\r\n    return  angle;\r\n  },\r\n};\r\n\r\nmodule.exports = pointerUtils;\r\n","const vendors = ['ms', 'moz', 'webkit', 'o'];\r\nlet lastTime = 0;\r\nlet request;\r\nlet cancel;\r\n\r\nfor (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\r\n  request = window[vendors[x] + 'RequestAnimationFrame'];\r\n  cancel = window[vendors[x] +'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n}\r\n\r\nif (!request) {\r\n  request = function (callback) {\r\n    const currTime = new Date().getTime();\r\n    const timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n    const id = setTimeout(function () { callback(currTime + timeToCall); },\r\n                          timeToCall);\r\n\r\n    lastTime = currTime + timeToCall;\r\n    return id;\r\n  };\r\n}\r\n\r\nif (!cancel) {\r\n  cancel = function (id) {\r\n    clearTimeout(id);\r\n  };\r\n}\r\n\r\nmodule.exports = {\r\n  request,\r\n  cancel,\r\n};\r\n","const win = module.exports;\r\nconst isWindow = require('./isWindow');\r\n\r\nfunction init (window) {\r\n  // get wrapped window if using Shadow DOM polyfill\r\n\r\n  win.realWindow = window;\r\n\r\n  // create a TextNode\r\n  const el = window.document.createTextNode('');\r\n\r\n  // check if it's wrapped by a polyfill\r\n  if (el.ownerDocument !== window.document\r\n      && typeof window.wrap === 'function'\r\n    && window.wrap(el) === el) {\r\n    // return wrapped window\r\n    win.window = window.wrap(window);\r\n  }\r\n\r\n  // no Shadow DOM polyfil or native implementation\r\n  win.window = window;\r\n}\r\n\r\nif (typeof window === 'undefined') {\r\n  win.window     = undefined;\r\n  win.realWindow = undefined;\r\n}\r\nelse {\r\n  init(window);\r\n}\r\n\r\nwin.getWindow = function getWindow (node) {\r\n  if (isWindow(node)) {\r\n    return node;\r\n  }\r\n\r\n  const rootNode = (node.ownerDocument || node);\r\n\r\n  return rootNode.defaultView || rootNode.parentWindow || win.window;\r\n};\r\n\r\nwin.init = init;\r\n"],"sourceRoot":"/source/"}